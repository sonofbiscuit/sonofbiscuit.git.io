<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="LAB4: Preemtive Multitasking   抢占式多任务处理您将在多个同时活跃的用户模式环境中实现抢占式多任务处理。 在A部分中，您将向JOS添加多处理器支持，实现循环调度，并添加基本的环境管理系统调用(创建和销毁环境的调用，以及分配&#x2F;映射内存的调用)。 在B部分中，您将实现一个类unix的fork()，它允许用户模式环境创建自身的副本。 最后，在C部分中，您将添加对进程间通信(">
<meta property="og:type" content="article">
<meta property="og:title" content="6-828Lab4">
<meta property="og:url" content="http://example.com/2022/07/04/6-828Lab4/index.html">
<meta property="og:site_name" content="我的一些记录">
<meta property="og:description" content="LAB4: Preemtive Multitasking   抢占式多任务处理您将在多个同时活跃的用户模式环境中实现抢占式多任务处理。 在A部分中，您将向JOS添加多处理器支持，实现循环调度，并添加基本的环境管理系统调用(创建和销毁环境的调用，以及分配&#x2F;映射内存的调用)。 在B部分中，您将实现一个类unix的fork()，它允许用户模式环境创建自身的副本。 最后，在C部分中，您将添加对进程间通信(">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705140300109.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/v2-869caa0c51df2aa8be0e868f38e1d322_1440w.jpg">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705153621702.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705161234358.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705161244343.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705162615525.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705163912143.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705172629111.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705172824320.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705180117691.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220706103342874.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220707135436275.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4482847-a33e11e5c9c54849.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/496">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/4482847-210592f47937410a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492">
<meta property="article:published_time" content="2022-07-04T14:41:44.000Z">
<meta property="article:modified_time" content="2022-07-08T06:33:20.988Z">
<meta property="article:tag" content="6.828,操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705140300109.png">


<link rel="canonical" href="http://example.com/2022/07/04/6-828Lab4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/07/04/6-828Lab4/","path":"2022/07/04/6-828Lab4/","title":"6-828Lab4"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>6-828Lab4 | 我的一些记录</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">我的一些记录</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LAB4-Preemtive-Multitasking-%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">LAB4: Preemtive Multitasking   抢占式多任务处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E6%94%AF%E6%8C%81%E5%92%8C%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%8D%8F%E4%BD%9C"><span class="nav-number">1.1.</span> <span class="nav-text">Part A: Multiprocessor Support and Cooperative Multitasking多处理器支持和多任务协作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-1-Multiprocessor-Support"><span class="nav-number">1.1.1.</span> <span class="nav-text">Exercise 1: Multiprocessor Support</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-2-Application-Processor-Bootstrap"><span class="nav-number">1.1.2.</span> <span class="nav-text">Exercise 2: Application Processor Bootstrap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Per-CPU-State-and-Initialization-CPU%E7%A7%81%E6%9C%89%E7%8A%B6%E6%80%81%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.3.</span> <span class="nav-text">Per-CPU State and Initialization(CPU私有状态和初始化)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-3"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Exercise 3.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-4"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">Exercise 4.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise5-Locking"><span class="nav-number">1.1.4.</span> <span class="nav-text">Exercise5: Locking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise6-Round-Robin-Scheduling-%E8%BD%AE%E8%AF%A2%E8%B0%83%E5%BA%A6"><span class="nav-number">1.1.5.</span> <span class="nav-text">Exercise6: Round-Robin Scheduling 轮询调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-7-System-Calls-for-Environment-Creation-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.1.6.</span> <span class="nav-text">Exercise 7: System Calls for Environment Creation(系统调用: 创建进程)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-B-Copy-on-Write-Fork-%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%E7%9A%84Fork"><span class="nav-number">1.2.</span> <span class="nav-text">Part B: Copy-on-Write Fork 写时拷贝的Fork</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#User-level-page-fault-handling-%E7%94%A8%E6%88%B7%E7%BA%A7%E5%88%AB%E7%9A%84%E9%A1%B5%E9%94%99%E8%AF%AF"><span class="nav-number">1.2.1.</span> <span class="nav-text">User-level page fault handling 用户级别的页错误</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-8-%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.0.1.</span> <span class="nav-text">Exercise 8: 设置页错误处理函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-9"><span class="nav-number">1.2.1.0.2.</span> <span class="nav-text">Exercise 9.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-10"><span class="nav-number">1.2.1.0.3.</span> <span class="nav-text">Exercise 10.</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-11"><span class="nav-number">1.2.1.0.4.</span> <span class="nav-text">Exercise 11.</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementing-Copy-on-Write-Fork"><span class="nav-number">1.2.2.</span> <span class="nav-text">Implementing Copy-on-Write Fork</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Exercise-12"><span class="nav-number">1.2.2.0.1.</span> <span class="nav-text">Exercise 12.</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part-C-%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86-amp-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">1.3.</span> <span class="nav-text">Part C: 抢占式多进程处理 &amp; 进程间通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Part-I-%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E4%BB%A5%E5%8F%8A%E6%8A%A2%E5%8D%A0"><span class="nav-number">1.3.1.</span> <span class="nav-text">Part I: 时钟中断以及抢占</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-13"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Exercise 13.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-14"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">Exercise 14.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Part-II-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-Inter-Process-communication-IPC"><span class="nav-number">1.3.2.</span> <span class="nav-text">Part II: 进程间通信(Inter-Process communication)IPC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-15"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">Exercise 15.</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/04/6-828Lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          6-828Lab4
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-04 22:41:44" itemprop="dateCreated datePublished" datetime="2022-07-04T22:41:44+08:00">2022-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-08 14:33:20" itemprop="dateModified" datetime="2022-07-08T14:33:20+08:00">2022-07-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="LAB4-Preemtive-Multitasking-抢占式多任务处理"><a href="#LAB4-Preemtive-Multitasking-抢占式多任务处理" class="headerlink" title="LAB4: Preemtive Multitasking   抢占式多任务处理"></a>LAB4: Preemtive Multitasking   抢占式多任务处理</h1><p>您将在多个同时活跃的用户模式环境中实现抢占式多任务处理。</p>
<p>在A部分中，您将向JOS添加多处理器支持，实现循环调度，并添加基本的环境管理系统调用(创建和销毁环境的调用，以及分配/映射内存的调用)。</p>
<p>在B部分中，您将实现一个类unix的fork()，它允许用户模式环境创建自身的副本。</p>
<p>最后，在C部分中，您将添加对进程间通信(IPC)的支持，允许不同的用户模式环境显式地相互通信和同步。您还将添加对硬件时钟中断和抢占的支持</p>
<h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking多处理器支持和多任务协作"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking多处理器支持和多任务协作" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking多处理器支持和多任务协作"></a>Part A: Multiprocessor Support and Cooperative Multitasking多处理器支持和多任务协作</h2><p>我们首先需要把 JOS 扩展到在多处理器系统中运行。然后实现一些新的 JOS 系统调用来允许用户进程创建新的进程。我们还要实现协同轮询调度，允许内核在当前进程自愿放弃CPU（或退出cpu）时从一个环境切换到另一个环境。</p>
<p>我们即将使 JOS 能够支持“对称多处理” (<strong>Symmetric MultiProcessing, SMP</strong>)。这种模式使所有 CPU 能对等地访问内存、I/O 总线等系统资源。虽然 CPU 在 SMP 下以同样的方式工作，在启动过程中他们可以被分为两个类型：引导处理器(<strong>BootStrap Processor, BSP</strong>) 负责初始化系统以及启动操作系统；应用处理器( <strong>Application Processors, AP</strong> ) 在操作系统拉起并运行后由 BSP 激活。哪个 CPU 作为 BSP 由硬件和 BIOS 决定。也就是说目前我们所有的 JOS 代码都运行在 BSP 上。<br>在 SMP 系统中，每个 CPU 都有一个附属的 LAPIC 单元。LAPIC 单元用于传递中断，并给它所属的 CPU 一个唯一的 ID。在 lab4 中，我们将会用到 LAPIC 单元的以下基本功能 ( 见kern/lapic.c中 )：</p>
<ul>
<li>读取 APIC ID 来判断我们的代码运行在哪个 CPU 之上。(see  <code>cpunum()</code> )</li>
<li>从 BSP 发送<code>STARTUP</code> 跨处理器中断 (InterProcessor Interrupt, IPI) 来启动 AP。(see <code>lapic_startap()</code> )</li>
<li>在 part C 中，我们为 LAPIC 的内置计时器编程来触发时钟中断以支持抢占式多任务处理。(see <code>apic_init()</code> )</li>
</ul>
<p>处理器通过<strong>映射在内存上的 I/O (Memory-Mapped I/O, MMIO)</strong> 来访问它的 LAPIC。在 MMIO 中，<strong>物理内存</strong>的一部分被<strong>硬连接</strong>到一些 I/O 设备的寄存器，因此，访问内存的 load/store 指令可以被用于访问设备的寄存器。实际上，我们在 lab1 中已经接触过这样的 IO hole，如<code>0xA0000</code>被用来写 VGA 显示缓冲。LAPIC 开始于<strong>物理地址</strong><code>0xFE000000</code> ( 4GB以下32MB处 )。如果用以前的映射算法（将<code>0xF0000000</code> 映射到 <code>0x00000000</code>，也就是说内核空间最高只能到物理地址<code>0x0FFFFFFF</code>）显然太高了。因此，JOS 在 <code>MMIOBASE</code> (即 虚拟地址<code>0xEF800000</code>) 预留了 4MB 来映射这类设备。我们需要写一个函数来分配这个空间并在其中映射设备内存。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705140300109.png" alt="image-20220705140300109"></p>
<p><strong>LAPIC 和 IOAPIC</strong></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/v2-869caa0c51df2aa8be0e868f38e1d322_1440w.jpg" alt="LAPIC 和 IOAPIC"></p>
<p>APIC全称是Advanced Programmable Interrupt Controller，高级可编程中断控制器。它是在奔腾P54C之后被引入进来的。</p>
<p>在现在的计算机它通常由两个部分组成，分别为<strong>LAPIC（Local APIC，本地高级可编程中断控制器）</strong>和<strong>IOAPIC(I/O高级可编程中断控制器）</strong>。</p>
<p>LAPIC在CPU中，IOAPIC通常位于南桥。</p>
<p>APIC是在PIC (Programmable Interrupt Controller) 的基础上发展而来的</p>
<p><strong>IOAPIC:</strong> IOAPIC的主要作用是中断的分发。最初有一条专门的APIC总线用于IOAPIC和LAPIC通信，在Pentium4 和Xeon 系列CPU出现后，他们的通信被合并到系统总线中。</p>
<h3 id="Exercise-1-Multiprocessor-Support"><a href="#Exercise-1-Multiprocessor-Support" class="headerlink" title="Exercise 1: Multiprocessor Support"></a><strong>Exercise 1: Multiprocessor Support</strong></h3><p>Implement <code>mmio_map_region</code> in <code>kern/pmap.c</code>. To see how this is used, look at the beginning of <code>lapic_init</code> in <code>kern/lapic.c</code>. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p>
<p>*<em>void <em>mmio_map_region(physaddr_t pa, size_t size)</em></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Reserve size bytes in the MMIO region and map [pa,pa+size) at this location.  Return the base of the reserved region.</span><br><span class="line">在MMIO区域保留大小为size字节的区域，然后把[pa, pa+size]映射到此区域，返回该区域的base.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">mmio_map_region</span><span class="params">(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Where to start the next region.  Initially, this is the</span></span><br><span class="line">   <span class="comment">// beginning of the MMIO region.  Because this is static, its</span></span><br><span class="line">   <span class="comment">// value will be preserved between calls to mmio_map_region</span></span><br><span class="line">   <span class="comment">// (just like nextfree in boot_alloc).</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Hint: The staff solution uses boot_map_region.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// Your code here:</span></span><br><span class="line">   <span class="comment">// panic(&quot;mmio_map_region not implemented&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取整页数</span></span><br><span class="line">    <span class="keyword">size_t</span> roundup_sz = ROUNDUP(size, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(base+roundup_sz &gt; MMIOLIM)&#123;</span><br><span class="line">        panic(<span class="string">&quot;mmio_map_region: out of MMIOLIM.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    boot_map_region(kern_pgdir, base, roundup_sz, pa, PTE_PCD|PTE_PWT|PTE_W);</span><br><span class="line">    <span class="keyword">uintptr_t</span> res_region_base = base;</span><br><span class="line">    base += roundup_sz;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)res_region_base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>void lapic_init(void)</strong></p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705153621702.png" alt="image-20220705153621702" style="zoom:50%;" />

<p>该函数一开始就调用了<code>mmin_map_region</code>函数，pa为lapicaddr，size为4096 = 4KB，即将从lapicaddr开始的4KB的物理地址映射到虚拟地址(保留区域)，以便我们能访问，然后返回保留区域的起始地址。</p>
<h3 id="Exercise-2-Application-Processor-Bootstrap"><a href="#Exercise-2-Application-Processor-Bootstrap" class="headerlink" title="Exercise 2: Application Processor Bootstrap"></a>Exercise 2: Application Processor Bootstrap</h3><p>在启动 APs 之前，BSP 需要先搜集多处理器系统的信息，例如 CPU 的总数，CPU 各自的 APIC ID，LAPIC 单元的 MMIO 地址。<code>kern/mpconfig.c</code> 中的 <code>mp_init()</code> 函数通过阅读 BIOS 区域内存中的 MP 配置表来获取这些信息。<br><code>boot_aps()</code> 函数驱动了 AP 的引导。APs 从实模式开始，如同 <code>boot/boot.S</code> 中 bootloader 的启动过程。因此 <code>boot_aps()</code> 将 AP 的入口代码 (<code>kern/mpentry.S</code>) 拷贝到实模式可以寻址的内存区域 (<code>0x7000</code>, <code>MPENTRY_PADDR</code>)。<br>此后，<code>boot_aps()</code> 通过发送 <code>STARTUP</code> 这个跨处理器中断到各 LAPIC 单元的方式，逐个激活 APs。激活方式为：初始化 AP 的 <code>CS:IP</code> 值使其从入口代码执行。通过一些简单的设置，AP 开启分页进入保护模式，然后调用 C 语言编写的 <code>mp_main()</code>。<code>boot_aps()</code> 等待 AP 发送 <code>CPU_STARTED</code> 信号，然后再唤醒下一个。</p>
<p>Read <code>boot_aps()</code> and <code>mp_main()</code> in <code>kern/init.c</code>, and the assembly code in <code>kern/mpentry.S</code>. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in <code>kern/pmap.c</code>to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated <code>check_page_free_list()</code> test (but might fail the updated <code>check_kern_pgdir()</code> test, which we will fix soon).</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705161234358.png" alt="image-20220705161234358"></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705161244343.png" alt="image-20220705161244343"></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705162615525.png" alt="image-20220705162615525"></p>
<p><strong>real mode表示我们看到的都是直接的物理地址</strong></p>
<p><strong>Question</strong></p>
<ol>
<li>Compare <code>kern/mpentry.S</code> side by side with <code>boot/boot.S</code>. Bearing in mind that <code>kern/mpentry.S</code> is compiled and linked to run above <code>KERNBASE</code> just like everything else in the kernel, <strong>what is the purpose of macro <code>MPBOOTPHYS</code>?</strong> Why is it necessary in <code>kern/mpentry.S</code> but not in <code>boot/boot.S</code>? In other words, what could go wrong if it were omitted in <code>kern/mpentry.S</code>?<br>Hint: recall the differences between the link address and the load address that we have discussed in Lab 1.</li>
</ol>
<p>​    <code>MPBOOTPHYS</code>的作用：</p>
<p><code>kern/mpentry.S</code>是运行在kernbase之上的，因此在实地址模式下，无法进行寻址（即无法访问）。</p>
<p><strong>kern/mpentry.S</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># This code is similar to boot/boot.S except that</span><br><span class="line">#    - it does not need to enable A20</span><br><span class="line">#    - it uses MPBOOTPHYS to calculate absolute addresses of its</span><br><span class="line">#      symbols, rather than relying on the linker to fill them</span><br><span class="line"></span><br><span class="line">#define RELOC(x) ((x) - KERNBASE)</span><br><span class="line">#define MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR)</span><br></pre></td></tr></table></figure>

<p>((s) - mpentry_start + MPENTRY_PADDR) 表示把mpentry地址转换到MPENTRY_PADDR。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705163912143.png" alt="image-20220705163912143"></p>
<p><code>kern/init.c</code>中已经进行了内容的拷贝，因此boot.S不需要再次 进行拷贝。而mpentry.S需要宏进行拷贝。</p>
<h3 id="Per-CPU-State-and-Initialization-CPU私有状态和初始化"><a href="#Per-CPU-State-and-Initialization-CPU私有状态和初始化" class="headerlink" title="Per-CPU State and Initialization(CPU私有状态和初始化)"></a>Per-CPU State and Initialization(CPU私有状态和初始化)</h3><p>当写一个多处理器操作系统时，分清 CPU 的私有状态 ( per-CPU state) 及全局状态 (global state) 非常关键。 <code>kern/cpu.h</code> 定义了大部分的 per-CPU 状态。<br>我们需要注意的 per-CPU 状态有：</p>
<ul>
<li><p>Per-CPU 内核栈<br>因为多 CPU 可能同时陷入内核态，我们需要给每个处理器一个独立的内核栈。用户态切到内核态，内核将用户态时的堆栈寄存器的值保存在内核栈中，以便于从内核栈切换回进程栈时能找到用户栈的地址。</p>
<p><code>percpu_kstacks[NCPU][KSTKSIZE]</code><br>在 Lab2 中，我们将 BSP 的内核栈映射到了 KSTACKTOP 下方。相似地，在 Lab4 中，我们需要把每个 CPU 的内核栈都映射到这个区域，每个栈之间留下一个空页作为缓冲区避免 overflow。CPU 0 ，即 BSP 的栈还是从 <code>KSTACKTOP</code> 开始，间隔 <code>KSTACKGAP</code> 的距离就是 CPU 1 的栈，以此类推。</p>
</li>
<li><p>Per-CPU TSS 以及 TSS 描述符<br>为了指明每个 CPU 的内核栈位置，需要任务状态段 (Task State Segment, TSS)，其功能在 Lab3 中已经详细讲过。</p>
</li>
<li><p>Per-CPU 当前环境指针<br>因为每个 CPU 能够同时运行各自的用户进程，我们重新定义了基于<code>cpus[cpunum()]</code> 的 <code>curenv</code>。</p>
</li>
<li><p>Per-CPU 系统寄存器<br>所有的寄存器，包括系统寄存器，都是 CPU 私有的。因此，初始化这些寄存器的指令，例如 <code>lcr3(), ltr(), lgdt(), lidt()</code> 等，必须在每个 CPU 都执行一次。</p>
</li>
</ul>
<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3."></a>Exercise 3.</h4><p>Modify <code>mem_init_mp()</code> (in <code>kern/pmap.c</code>) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in <code>inc/memlayout.h</code>. The size of each stack is <code>KSTKSIZE</code> bytes plus <code>KSTKGAP</code> bytes of unmapped guard pages. Your code should pass the new check in <code>check_kern_pgdir()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">mem_init_mp</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// LAB 4: Your code here:</span></span><br><span class="line">    <span class="comment">// LAB 2 中只把BSP的内核栈 map 到了KSTACKTOP下方，这次把所有的cpu都进行map</span></span><br><span class="line">    <span class="comment">// 在 kern/cpu.h 中可以找到对 NCPU 以及全局变量 percpu_kstacks 的声明</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> start_addr = KSTACKTOP - KSTKSIZE;   <span class="comment">// 倒着来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = start_addr; i&lt;NCPU;++i)&#123;  <span class="comment">// i代表cpu编号</span></span><br><span class="line">        boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)start_addr, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);</span><br><span class="line">        start_addr-=(KSTKSIZE+KSTKGAP); <span class="comment">//gap是两个cpu之间的缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 即使从KSTACKTOP重新开始分配，之前的BSP会直接被覆盖掉，不会有影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a>Exercise 4.</h4><p>在 <code>inc/memlayout.h</code> 中可以看到之前分配BSP时，TSS0的定义</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705172629111.png" alt="image-20220705172629111"></p>
<p>这只是对单CPU而言的定义，那么对于多个cpu，就需要其他的TSS，<strong>如何寻找这个TSS？</strong>trap_init_percpu()注释中说明了</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705172824320.png" alt="image-20220705172824320"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize and load the per-CPU TSS and IDT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_init_percpu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// LAB 4: Your code here:</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span>* <span class="title">this_ts</span> =</span> &amp;thiscpu-&gt;cpu_ts;   <span class="comment">//!!!!!!!!!!!!</span></span><br><span class="line">   <span class="comment">// 一开始写成了struct Taskstate this_ts = thiscpu-&gt;cpu_ts;</span></span><br><span class="line">  <span class="comment">// 导致cpu的值并未改变，然后出现triple fault    ！！！！！！！！！！</span></span><br><span class="line">   <span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">   <span class="comment">// when we trap to the kernel.</span></span><br><span class="line">   ts.ts_esp0 = KSTACKTOP;</span><br><span class="line">   ts.ts_ss0 = GD_KD;</span><br><span class="line">   ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">   gdt[GD_TSS0 &gt;&gt; <span class="number">3</span>] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;ts),</span><br><span class="line">               <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   gdt[GD_TSS0 &gt;&gt; <span class="number">3</span>].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">   <span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">   ltr(GD_TSS0);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Load the IDT</span></span><br><span class="line">   lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>make qemu CPUS=4</code> (or <code>make qemu-nox CPUS=4</code>)</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705180117691.png" alt="image-20220705180117691"></p>
<h3 id="Exercise5-Locking"><a href="#Exercise5-Locking" class="headerlink" title="Exercise5: Locking"></a>Exercise5: Locking</h3><p>我们现在的代码在初始化 AP 后就会开始自旋。在进一步操作 AP 之前，我们要先处理几个 CPU 同时运行内核代码的竞争情况。最简单的方法是用一个大内核锁 (big kernel lock)。它是一个全局锁，在某个进程进入内核态时锁定，返回用户态时释放。这种模式下，用户进程可以并发地在 CPU 上运行，但是同一时间仅有一个进程可以在内核态，其他需要进入内核态的进程只能等待。<br><code>kern/spinlock.h</code> 声明了一个大内核锁 <code>kernel_lock</code>。它提供了 <code>lock_kernel()</code> 和 <code>unlock_kernel()</code> 方法用于获得和释放锁。<strong>在以下 4 个地方需要使用到大内核锁：</strong></p>
<ul>
<li>在 <code>i386_init()</code>，BSP 唤醒其他 CPU 之前获得内核锁</li>
<li>在 <code>mp_main()</code>，初始化 AP 之后获得内核锁，之后调用 <code>sched_yield()</code> 在 AP 上运行进程。</li>
<li>在 <code>trap()</code>，当从用户态陷入内核态时获得内核锁，通过检查 <code>tf_Cs</code> 的低 2bit 来确定该 trap 是由用户进程还是内核触发。</li>
<li>在 <code>env_run()</code>，在切换回用户模式前释放内核锁。</li>
</ul>
<p>Apply the big kernel lock as described above, by calling <code>lock_kernel()</code> and <code>unlock_kernel()</code> at the proper locations.</p>
<p><strong>kern/init.c/i386_init()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">   lock_kernel();</span><br><span class="line"><span class="comment">// Starting non-boot CPUs</span></span><br><span class="line">boot_aps();</span><br></pre></td></tr></table></figure>

<p><strong>init.c/mp_main()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line"><span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line"><span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">   lock_kernel();</span><br><span class="line">   sched_yield();</span><br></pre></td></tr></table></figure>

<p><strong>trap.c/trap()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;   <span class="comment">// 陷入了内核态</span></span><br><span class="line">   <span class="comment">// Trapped from user mode.</span></span><br><span class="line">   <span class="comment">// Acquire the big kernel lock before doing any</span></span><br><span class="line">   <span class="comment">// serious kernel work.</span></span><br><span class="line">   <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">       lock_kernel();</span><br><span class="line">   assert(curenv);</span><br></pre></td></tr></table></figure>

<p><strong>env.c/env_run()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">unlock_kernel();</span><br><span class="line">env_pop_tf(&amp;e-&gt;env_tf);</span><br></pre></td></tr></table></figure>



<p><strong>为什么要在这几处加大内核锁</strong><br>从根本上来讲，其设计的初衷就是保证独立性。由于分页机制的存在，内核以及每个用户进程都有自己的独立空间。而多进程并发的时候，如果两个进程同时陷入内核态，就无法保证独立性了。例如内核中有某个全局变量 A，cpu1 让 A=1， 而后 cpu2 却让 A=2，显然会互相影响。</p>
<p>BPS 启动 AP 前，获取内核锁，所以 AP 会在 mp_main 执行调度之前阻塞，在启动完 AP 后，BPS 执行调度，运行第一个进程，<code>env_run()</code> 函数中会释放内核锁，这样一来，其中一个 AP 就可以开始执行调度，运行其他进程。</p>
<p><strong>Question 2.</strong><br>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock</p>
<p>在某进程即将陷入内核态的时候（尚未获得锁），其实在 <code>trap()</code> 函数之前已经在 <code>trapentry.S</code> 中对内核栈进行了操作，压入了寄存器信息。如果共用一个内核栈，那显然会导致信息错误。</p>
<h3 id="Exercise6-Round-Robin-Scheduling-轮询调度"><a href="#Exercise6-Round-Robin-Scheduling-轮询调度" class="headerlink" title="Exercise6: Round-Robin Scheduling 轮询调度"></a>Exercise6: Round-Robin Scheduling 轮询调度</h3><p>下一个任务是让 JOS 内核能够以轮询方式在多个任务之间切换。其原理如下：</p>
<ul>
<li><code>kern/sched.c</code> 中的 <code>sched_yield()</code> 函数用来选择一个新的进程运行。它将从上一个运行的进程开始，按顺序循环搜索 <code>envs[]</code> 数组，选取第一个状态为 <code>ENV_RUNNABLE</code> 的进程执行。</li>
<li><code>sched_yield()</code>不能同时在两个CPU上运行同一个进程。如果一个进程已经在某个 CPU 上运行，其状态会变为 <code>ENV_RUNNING</code>。</li>
<li>程序中已经实现了一个新的系统调用 <code>sys_yield()</code>，进程可以用它来唤起内核的 <code>sched_yield()</code> 函数，从而将 CPU 资源移交给一个其他的进程</li>
</ul>
<p><strong>Exercise 6.</strong><br>Implement round-robin scheduling in <code>sched_yield()</code> as described above. Don’t forget to modify <code>syscall()</code> to dispatch <code>sys_yield()</code>.<br>Make sure to invoke <code>sched_yield()</code> in <code>mp_main</code>.<br>Modify <code>kern/init.c</code> to create three (or more!) environments that all run the program <code>user/yield.c</code>.</p>
<p>首先要找到正在运行的进程在envs[]中的序号。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220706103342874.png" alt="image-20220706103342874"></p>
<p><strong>sched.c/sched_yield()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Choose a user environment to run and run it.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched_yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Implement simple round-robin scheduling.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// Search through &#x27;envs&#x27; for an ENV_RUNNABLE environment in</span></span><br><span class="line">   <span class="comment">// circular fashion starting just after the env this CPU was</span></span><br><span class="line">   <span class="comment">// last running.  Switch to the first such environment found.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// If no envs are runnable, but the environment previously</span></span><br><span class="line">   <span class="comment">// running on this CPU is still ENV_RUNNING, it&#x27;s okay to</span></span><br><span class="line">   <span class="comment">// choose that environment.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// Never choose an environment that&#x27;s currently running on</span></span><br><span class="line">   <span class="comment">// another CPU (env_status == ENV_RUNNING). If there are</span></span><br><span class="line">   <span class="comment">// no runnable environments, simply drop through to the code</span></span><br><span class="line">   <span class="comment">// below to halt the cpu.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    idle = curenv;</span><br><span class="line">    <span class="keyword">size_t</span> running_idx = (idle == <span class="literal">NULL</span>)?:<span class="number">-1</span>:ENVX(idle-&gt;env_id);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i&lt;NENV;++i)&#123;</span><br><span class="line">        running_idx = (running_idx+<span class="number">1</span> == NENV)?<span class="number">0</span>:running_idx+<span class="number">1</span>; <span class="comment">// 0代表从头再搜，因为起始点可能在中间</span></span><br><span class="line">        <span class="keyword">if</span>(envs[running_idx].env_status == RUNNABLE)&#123;  <span class="comment">// 选取第一个状态为RUNNABLE的进程执行</span></span><br><span class="line">            env_run(&amp;envs[running_idx]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有可运行的环境，但是之前在此CPU上运行的环境仍然是ENV_RUNNING，则可以选择该环境</span></span><br><span class="line">    <span class="keyword">if</span>(idle &amp;&amp; envs[idle].env_status == ENV_RUNNING)&#123;</span><br><span class="line">        env_run(idle);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// sched_halt never returns</span></span><br><span class="line">   sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>inc/syscall.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* system call numbers */</span> 在syscall.h中有定义，syscall不是trap！！！</span><br><span class="line"></span><br><span class="line"><span class="comment">/* system call numbers */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	SYS_cputs = <span class="number">0</span>,</span><br><span class="line">	SYS_cgetc,</span><br><span class="line">	SYS_getenvid,</span><br><span class="line">	SYS_env_destroy,</span><br><span class="line">	SYS_page_alloc,</span><br><span class="line">	SYS_page_map,</span><br><span class="line">	SYS_page_unmap,</span><br><span class="line">	SYS_exofork,</span><br><span class="line">	SYS_env_set_status,</span><br><span class="line">	SYS_env_set_pgfault_upcall,</span><br><span class="line">	SYS_yield,</span><br><span class="line">	SYS_ipc_try_send,</span><br><span class="line">	SYS_ipc_recv,</span><br><span class="line">	NSYSCALLS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Question 3.</strong><br>In your implementation of <code>env_run()</code> you should have called <code>lcr3()</code>. Before and after the call to <code>lcr3()</code>, your code makes references (at least it should) to the variable <code>e</code>, the argument to <code>env_run</code>. Upon loading the <code>%cr3</code> register, the addressing context used by the MMU is instantly changed. But a virtual address (namely <code>e</code>) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer e be dereferenced both before and after the addressing switch?</p>
</blockquote>
<p>大意是问为什么通过 <code>lcr3()</code> 切换了页目录，还能照常对 <code>e</code> 解引用。回想在 lab3 中，曾经写过的函数 <code>env_setup_vm()</code>。它直接以内核的页目录作为模版稍做修改。因此两个页目录的 <code>e</code> 地址映射到同一物理地址。</p>
<blockquote>
<p><strong>Question 4.</strong><br>Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?</p>
</blockquote>
<p>在进程陷入内核时，会保存当前的运行信息，这些信息都保存在内核栈上。而当从内核态回到用户态时，会恢复之前保存的运行信息。<br>具体到 JOS 代码中，保存发生在 <code>kern/trapentry.S</code>，恢复发生在 <code>kern/env.c</code>。可以对比两者的代码。<br><strong>保存：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define TRAPHANDLER_NOEC(name, num)</span><br><span class="line">    .globl name;                            </span><br><span class="line">    .type name, @function;                      </span><br><span class="line">    .align 2;                           </span><br><span class="line">    name:                               </span><br><span class="line">    pushl $0;                           </span><br><span class="line">    pushl $(num);                           </span><br><span class="line">    jmp _alltraps</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">_alltraps:</span><br><span class="line">pushl %ds    // 保存当前段寄存器</span><br><span class="line">pushl %es</span><br><span class="line">pushal    // 保存其他寄存器</span><br><span class="line"></span><br><span class="line">movw $GD_KD, %ax</span><br><span class="line">movw %ax, %ds</span><br><span class="line">movw %ax, %es</span><br><span class="line">pushl %esp    //  保存当前栈顶指针</span><br><span class="line">call trap</span><br></pre></td></tr></table></figure>

<p><strong>恢复：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">env_pop_tf(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    // Record the CPU we are running on for user-space debugging</span><br><span class="line">    curenv-&gt;env_cpunum = cpunum();</span><br><span class="line"></span><br><span class="line">    asm volatile(</span><br><span class="line">        &quot;\tmovl %0,%%esp\n&quot;    // 恢复栈顶指针</span><br><span class="line">        &quot;\tpopal\n&quot;    // 恢复其他寄存器</span><br><span class="line">        &quot;\tpopl %%es\n&quot;    // 恢复段寄存器</span><br><span class="line">        &quot;\tpopl %%ds\n&quot;</span><br><span class="line">        &quot;\taddl $0x8,%%esp\n&quot; /* skip tf_trapno and tf_errcode */</span><br><span class="line">        &quot;\tiret\n&quot;</span><br><span class="line">        : : &quot;g&quot; (tf) : &quot;memory&quot;);</span><br><span class="line">    panic(&quot;iret failed&quot;);  /* mostly to placate the compiler */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">➜  lab git:(lab4) ✗ make qemu-nox CPUS=2</span><br><span class="line">***</span><br><span class="line">*** Use Ctrl-a x to exit qemu</span><br><span class="line">***</span><br><span class="line">qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log -smp 2 </span><br><span class="line">6828 decimal is 15254 octal!</span><br><span class="line">Physical memory: 131072K available, base = 640K, extended = 130432K</span><br><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_alloc() succeeded!</span><br><span class="line">check_page() succeeded!</span><br><span class="line">check_kern_pgdir() succeeded!</span><br><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_installed_pgdir() succeeded!</span><br><span class="line">SMP: CPU 0 found 2 CPU(s)</span><br><span class="line">enabled interrupts: 1 2</span><br><span class="line">SMP: CPU 1 starting</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">[00000000] new env 00001001</span><br><span class="line">[00000000] new env 00001002</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Hello, I am environment 00001000.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Hello, I am environment 00001001.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP fIncoming TRAP frame at 0xefffffbc</span><br><span class="line">rame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Hello, I am environment 00001002.</span><br><span class="line">xeffeffbc</span><br><span class="line">Back in environment 00001000, iteration 0.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001001, iteration 0.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001002, iteration 0.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001000, iteration 1.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001001, iteration 1.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001002, iteration 1.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001000, iteration 2.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001001, iteration 2.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001002, iteration 2.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001000, iteration 3.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001001, iteration 3.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001002, iteration 3.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001000, iteration 4.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">All done in environment 00001000.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001001, iteration 4.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">All done in environment 00001001.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001002, iteration 4.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">[00001001] exiting gracefully</span><br><span class="line">[00001001] free env 00001001</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">All done in environment 00001002.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">[00001002] exiting gracefully</span><br><span class="line">[00001002] free env 00001002</span><br><span class="line">No runnable environments in the system!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cpu=2时，三个进程通过sys_yield切换了5次。</p>
<h3 id="Exercise-7-System-Calls-for-Environment-Creation-系统调用-创建进程"><a href="#Exercise-7-System-Calls-for-Environment-Creation-系统调用-创建进程" class="headerlink" title="Exercise 7: System Calls for Environment Creation(系统调用: 创建进程)"></a>Exercise 7: System Calls for Environment Creation(系统调用: 创建进程)</h3><p>现在我们的内核已经可以运行多个进程，并在其中切换了。不过，现在它仍然只能运行内核最初设定好的程序 (<code>kern/init.c</code>) 。现在我们即将实现一个新的系统调用，它允许进程创建并开始新的进程。<br>Unix 提供了 <code>fork()</code> 这个原始的系统调用来创建进程。<code>fork()</code>将会拷贝父进程的整个地址空间来创建子进程。在用户空间里，父子进程之间的唯一区别就是它们的进程 ID。<code>fork()</code>在父进程中返回其子进程的进程 ID，而在子进程中返回 0。父子进程之间是完全独立的，任意一方修改内存，另一方都不会受到影响。<br>我们将为 JOS 实现一个更原始的系统调用来创建新的进程。涉及到的系统调用如下：</p>
<ul>
<li><code>sys_exofork</code>:<br>这个系统调用将会创建一个空白进程：在其用户空间中没有映射任何物理内存，并且它是不可运行的。刚开始时，它拥有和父进程相同的寄存器状态。<code>sys_exofork</code> 将会在父进程返回其子进程的<code>envid_t</code>，子进程返回 0（当然，由于子进程还无法运行，也无法返回值，直到运行：）</li>
<li><code>sys_env_set_status</code>:<br>设置指定进程的状态。这个系统调用通常用于在新进程的地址空间和寄存器初始化完成后，将其标记为可运行。</li>
<li><code>sys_page_alloc</code>:<br>分配一个物理页并将其映射到指定进程的指定虚拟地址上。</li>
<li><code>sys_page_map</code>:<br>从一个进程中拷贝一个页面映射（而非物理页的内容）到另一个。即共享内存。</li>
<li><code>sys_page_unmap</code>:<br>删除到指定进程的指定虚拟地址的映射。</li>
</ul>
<blockquote>
<p><strong>Exercise 7.</strong><br>Implement the system calls described above in <code>kern/syscall.c</code>. You will need to use various functions in <code>kern/pmap.c</code> and <code>kern/env.c</code>, particularly <code>envid2env()</code>. For now, whenever you call <code>envid2env()</code>, pass 1 in the <code>checkperm</code> parameter. Be sure you check for any invalid system call arguments, returning <code>-E_INVAL</code> in that case. Test your JOS kernel with <code>user/dumbfork</code> and make sure it works before proceeding.</p>
</blockquote>
<p>一个比较冗长的练习。重点应该放在阅读 <code>user/dumbfork.c</code> 上，以便理解各个系统调用的作用。<br>在 <code>user/dumbfork.c</code> 中，核心是 <code>duppage()</code> 函数。它利用 <code>sys_page_alloc()</code> 为子进程分配空闲物理页，再使用<code>sys_page_map()</code> 将该新物理页映射到内核 <strong>(内核的 env_id = 0)</strong> 的交换区 <code>UTEMP</code>，方便在内核态进行 <code>memmove</code> 拷贝操作。在拷贝结束后，利用 <code>sys_page_unmap()</code> 将交换区的映射删除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> dstenv, <span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is NOT what you should do in your fork.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_alloc</span>(dstenv, addr, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_map</span>(dstenv, addr, <span class="number">0</span>, UTEMP, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sys_page_map: %e&quot;</span>, r);</span><br><span class="line">    <span class="built_in">memmove</span>(UTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_unmap</span>(<span class="number">0</span>, UTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sys_page_unmap: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sys_exofork() 函数</strong></p>
<p>该函数主要是分配了一个新的进程，但是没有做内存复制等处理。唯一值得注意的就是如何使子进程返回0。<br><code>sys_exofork()</code>是一个非常特殊的系统调用，它的定义与实现在 <code>inc/lib.h</code> 中，而不是 <code>lib/syscall.c</code> 中。并且，它必须是 inline 的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This must be inlined.  Exercise for reader: why?</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">envid_t</span> __attribute__((always_inline))</span><br><span class="line"><span class="built_in">sys_exofork</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">envid_t</span> ret;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;int %2&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">             : <span class="string">&quot;=a&quot;</span> (ret)</span></span></span><br><span class="line"><span class="params"><span class="function">             : <span class="string">&quot;a&quot;</span> (SYS_exofork), <span class="string">&quot;i&quot;</span> (T_SYSCALL))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，它的返回值是 <code>%eax</code> 寄存器的值。那么，它到底是什么时候返回？这就涉及到对整个 进程-&gt;内核-&gt;进程 的过程的理解。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> envid_t</span><br><span class="line">sys_exofork(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_exofork not implemented&quot;);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span></span> *e;</span><br><span class="line">    int r = env_alloc(&amp;e, curenv-&gt;env_id);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_tf = curenv-&gt;env_tf;</span><br><span class="line">    e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数中，子进程复制了父进程的 trapframe，此后把 trapframe 中的 eax 的值设为了0。最后，返回了子进程的 id。注意，根据 <code>kern/trap.c</code> 中的 <code>trap_dispatch()</code> 函数，这个返回值仅仅是存放在了父进程的 trapframe 中，还没有返回。而是在返回用户态的时候，即在 <code>env_run()</code> 中调用 <code>env_pop_tf()</code> 时，才把 trapframe 中的值赋值给各个寄存器。这时候 <code>lib/syscall.c</code> 中的函数 <code>syscall()</code> 才获得真正的返回值。因此，在这里对子进程 trapframe 的修改，可以使得子进程返回0。</p>
<p><strong>sys_page_alloc() 函数</strong><br>在进程 envid 的目标地址 va 分配一个权限为 perm 的页面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_page_alloc</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_page_alloc not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> ((~perm &amp; (PTE_U|PTE_P)) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; (~(PTE_U|PTE_P|PTE_AVAIL|PTE_W))) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || <span class="built_in">PGOFF</span>(va) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL; </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pginfo</span> =</span> <span class="built_in">page_alloc</span>(ALLOC_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (!pginfo) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">envid2env</span>(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    r = <span class="built_in">page_insert</span>(e-&gt;env_pgdir, pginfo, va, perm);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">page_free</span>(pginfo);</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sys_page_map() 函数</strong><br>简单来说，就是建立跨进程的映射。</p>
<p>在srcenvid地址空间的’srcva’映射到dstenvid地址空间的’dstva’，并赋予’perm ‘权限。Perm具有与sys_page_alloc相同的限制，但它也不能授予对只读页面的写访问权。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_page_map</span><span class="params">(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_page_map not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva &gt;= UTOP || <span class="built_in">PGOFF</span>(srcva) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)dstva &gt;= UTOP || <span class="built_in">PGOFF</span>(dstva) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; PTE_U) == <span class="number">0</span> || (perm &amp; PTE_P) == <span class="number">0</span> || (perm &amp; ~PTE_SYSCALL) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">src_e</span>, *<span class="title">dst_e</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">envid2env</span>(srcenvid, &amp;src_e, <span class="number">1</span>)&lt;<span class="number">0</span> || <span class="built_in">envid2env</span>(dstenvid, &amp;dst_e, <span class="number">1</span>)&lt;<span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    <span class="keyword">pte_t</span> *src_ptab;    </span><br><span class="line">    <span class="comment">// page_look_up()   返回映射到虚拟地址 va 的页面</span></span><br><span class="line">    <span class="comment">// page_insert()  建立一个虚拟地址与物理页的映射</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> <span class="built_in">page_lookup</span>(src_e-&gt;env_pgdir, srcva, &amp;src_ptab);   <span class="comment">// 查询srcva的page</span></span><br><span class="line">    <span class="keyword">if</span> ((*src_ptab &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (perm &amp; PTE_W) == <span class="number">1</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">page_insert</span>(dst_e-&gt;env_pgdir, pp, dstva, perm) &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_NO_MEM;   <span class="comment">// srcpage 映射到dstva</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sys_page_unmap() 函数</strong><br>取消映射。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_page_unmap</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span>  <span class="comment">//取消envid的地址空间中地址va的页映射</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_remove().</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">// panic(&quot;sys_page_unmap not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || <span class="built_in">PGOFF</span>(va) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">envid2env</span>(envid, &amp;e, <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;    <span class="comment">// 获取envid对应的进程</span></span><br><span class="line">    <span class="built_in">page_remove</span>(e-&gt;env_pgdir, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sys_env_set_status() 函数</strong><br>设置状态，在子进程内存 map 结束后再使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_env_set_status</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_env_set_status not implemented&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) <span class="keyword">return</span> -E_INVAL;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">envid2env</span>(envid, &amp;e, <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    e-&gt;env_status = status;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，不要忘记在 <code>kern/syscall.c</code> 中添加新的系统调用类型，注意参数的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> SYS_exofork:</span><br><span class="line">        retVal = (<span class="keyword">int32_t</span>)<span class="built_in">sys_exofork</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_env_set_status:</span><br><span class="line">        retVal = <span class="built_in">sys_env_set_status</span>(a1, a2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_page_alloc:</span><br><span class="line">        retVal = <span class="built_in">sys_page_alloc</span>(a1,(<span class="keyword">void</span> *)a2, (<span class="keyword">int</span>)a3);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_page_map:</span><br><span class="line">        retVal = <span class="built_in">sys_page_map</span>(a1, (<span class="keyword">void</span> *)a2, a3, (<span class="keyword">void</span>*)a4, (<span class="keyword">int</span>)a5);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_page_unmap:</span><br><span class="line">        retVal = <span class="built_in">sys_page_unmap</span>(a1, (<span class="keyword">void</span> *)a2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>make grade 成功。至此，part A 结束。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/10f822b3deda">https://www.jianshu.com/p/10f822b3deda</a></p>
<h2 id="Part-B-Copy-on-Write-Fork-写时拷贝的Fork"><a href="#Part-B-Copy-on-Write-Fork-写时拷贝的Fork" class="headerlink" title="Part B: Copy-on-Write Fork 写时拷贝的Fork"></a>Part B: Copy-on-Write Fork 写时拷贝的Fork</h2><p>在Part A中，通过把父进程的所有内存数据拷贝到子进程实现了<code>fork()</code>， 这也是 Unix 系统早期的实现。这个拷贝到过程是 <code>fork()</code> 时最昂贵的操作。<br>然而，调用了 <code>fork()</code> 之后往往立即就会在子进程中调用 <code>exec()</code> ，将子进程的内存更换为新的程序，例如 shell 经常干的（<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/64385b80210b">HW:Shell</a>)。这样，复制父进程的内存这个操作就完全浪费了。</p>
<p>因此，后来的 Unix 系统让父、子进程共享同一片物理内存，直到某个进程修改了内存。这被称作 <em>copy-on-write</em>。为了实现它，<code>fork()</code>时内核只拷贝页面的映射关系，而不拷贝其内容，同时将共享的页面标记为只读 (read-only)。当父子进程中任一方向内存中写入数据时，就会触发 page fault。此时，Unix 就知道应该分配一个私有的可写内存给这个进程。这个优化使得 <code>fork()</code> + <code>exec()</code> 连续操作变得非常廉价。在执行 <code>exec()</code> 之前，只需要拷贝一个页面，即当前的栈。</p>
<p>在 Part B 中，我们将实现上述更佳实现方式的 <code>fork()</code>。</p>
<h3 id="User-level-page-fault-handling-用户级别的页错误"><a href="#User-level-page-fault-handling-用户级别的页错误" class="headerlink" title="User-level page fault handling 用户级别的页错误"></a>User-level page fault handling 用户级别的页错误</h3><p>内核必须要记录进程不同区域出现页面错误时的处理方法。例如，一个栈区域的 page fault 会分配并映射一个新的页。一个 BSS 区域（用于存放程序中未初始化的全局变量、静态变量）的页错误会分配一个新的页面，初始化为0，再映射。<br>用户级别的页错误处理流程为：</p>
<ol>
<li>页错误异常，陷入内核</li>
<li>内核修改 <code>%esp</code> 切换到进程的异常栈，修改 <code>%eip</code> 让进程运行 _pgfault_upcall</li>
<li>_pgfault_upcall 将运行 page fault handler，此后不通过内核切换回正常栈</li>
</ol>
<p><strong>EIP为：返回本次调用后，下一条指令的地址。</strong></p>
<p><strong>ESP：存放当前线程的栈顶指针。</strong></p>
<p><strong>EBP：存放当前线程的栈底指针。</strong></p>
<p>在采用段式内存管理的架构中（比如intel的80x86系统），bss段（Block Started by Symbolsegment）通常是指用来存放程序中未初始化的全局变量的一块内存区域，一般在初始化时bss段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。</p>
<h5 id="Exercise-8-设置页错误处理函数"><a href="#Exercise-8-设置页错误处理函数" class="headerlink" title="Exercise 8: 设置页错误处理函数"></a>Exercise 8: 设置页错误处理函数</h5><p>为处理自己的页错误，进程需要在 JOS 注册一个 page fault handler entrypoint。进程通过 <code>sys_env_set_pgfault_upcall</code> 注册自己的 entrypoint，并在 <code>Env</code> 结构体中新增 <code>env_pgfault_upcall</code> 来记录该信息。</p>
<blockquote>
<p><strong>Exercise 8.</strong><br>Implement the <code>sys_env_set_pgfault_upcall</code> system call. Be sure to enable permission checking when looking up the environment ID of the target environment, since this is a “dangerous” system call.</p>
</blockquote>
<p><strong>进程的正常栈和异常栈</strong></p>
<p>正常运行时，JOS 的进程会运行在正常栈上，<code>ESP</code> 从<code>USTACKTOP</code>开始往下生长，栈上的数据存放在 <code>[USTACKTOP-PGSIZE, USTACKTOP-1]</code> 上。当出现页错误时，内核会把进程在一个新的栈（异常栈）上面重启，运行指定的用户级别页错误处理函数。也就是说完成了一次进程内的栈切换。这个过程与 trap 的过程很相似。<br>JOS 的异常栈也只有一个物理页大小，并且它的栈顶定义在虚拟内存 <code>UXSTACKTOP</code> 处。当运行在这个栈上时，用户级别页错误处理函数可以使用 JOS 的系统调用来映射新的页，以修复页错误。<br>每个需要支持用户级页错误处理的函数都需要分配自己的异常栈。可以使用 <code>sys_page_alloc()</code> 这个系统调用来实现。</p>
<p><strong>用户页错误处理函数</strong></p>
<p>现在我们需要修改 <code>kern/trap.c</code> 以支持用户级别的页错误处理。<br>如果没有注册 page fault handler，JOS内核就直接销毁进程。否则，内核就会初始化一个 trap frame 记录寄存器状态，在异常栈上处理页错误，恢复进程的执行。<code>UTrapframe</code> 在异常栈栈上如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time eflags</span><br><span class="line">trap-time eip</span><br><span class="line">trap-time eax       start of struct PushRegs</span><br><span class="line">trap-time ecx</span><br><span class="line">trap-time edx</span><br><span class="line">trap-time ebx</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time ebp</span><br><span class="line">trap-time esi</span><br><span class="line">trap-time edi       end of struct PushRegs</span><br><span class="line">tf_err (error code)</span><br><span class="line">fault_va            &lt;-- %esp when handler is run</span><br></pre></td></tr></table></figure>

<p>相比 trap 时使用的 <code>Trapframe</code>，多了记录错误位置的 <code>fault_va</code>，少了段选择器<code>%cs, %ds, %ss</code>。这反映了两者最大的不同：是否发生了进程的切换。<br>如果异常发生时，进程已经在异常栈上运行了，这就说明 page fault handler 本身出现了问题。这时，我们就应该在 <code>tf-&gt;tf_esp</code> 处分配新的栈，而不是在 <code>UXSTACKTOP</code>。首先需要 push 一个空的 32bit word 作为占位符，然后是一个 <code>UTrapframe</code> 结构体。<br>为检查 <code>tf-&gt;tf_esp</code> 是否已经在异常栈上了，只要检查它是否在区间 <code>[UXSTACKTOP-PGSIZE, UXSTACKTOP-1]</code> 上即可。</p>
<p><strong>以下9，10，11三个练习，建议按照调用顺序来看，即 11（设置handler）-&gt;9（切换到异常栈）-&gt;10（运行handler，切换回正常栈）。</strong></p>
<h5 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9."></a><strong>Exercise 9.</strong></h5><blockquote>
<p>Implement the code in <code>page_fault_handler</code> in <code>kern/trap.c</code> required to dispatch page faults to the user-mode handler. Be sure to take appropriate precautions when writing into the exception stack. (What happens if the user environment runs out of space on the exception stack?)</p>
</blockquote>
<p><em>可参考 Exercise 10 的 <code>lib/pfentry.S</code> 中的注释</em><br>较有难度的一个练习。首先需要理解用户级别的页错误处理的步骤是：<br><strong>进程A(正常栈) -&gt; 内核 -&gt; 进程A(异常栈) -&gt; 进程A(正常栈)</strong><br>那么内核的工作就是修改进程 A 的某些寄存器，并初始化异常栈，确保能顺利切换到异常栈运行。需要注意的是，由于修改了eip， <code>env_run()</code> 是不会返回的，因此不会继续运行后面销毁进程的代码。<br>值得注意的是，如果是嵌套的页错误，为了能实现递归处理，栈留出 32bit 的空位，直接向下生长。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">page_fault_handler(<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span></span> *tf)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t fault_va;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">    fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) panic(<span class="string">&quot;Page fault in kernel-mode&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span>(curenv-&gt;env_pgfault_upcall)&#123;  <span class="comment">// Page fault upcall entry point</span></span><br><span class="line">        <span class="comment">// 建立异常栈</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span></span>* utf;  <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">if</span>(tf-&gt;tf_esp &lt; UXSTACKTOP &amp;&amp; tf-&gt;tf-&gt;esp &gt;=UXSTACKTOP-PGSIZE)&#123;</span><br><span class="line">            utf = (<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span></span> *)(tf-&gt;tf_esp - <span class="number">4</span> - sizeof(<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span></span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            utf = (<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span></span> *)(UXSTACKTOP - sizeof(<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span></span>));</span><br><span class="line">        &#125;</span><br><span class="line">        user_mem_assert(curenv, (void *)utf, sizeof(<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span></span>), PTE_U | PTE_W | PTE_P);</span><br><span class="line">        <span class="comment">// 检查用户是否有权限读取，无权限则摧毁，之后不再进行</span></span><br><span class="line">        <span class="comment">// 转存寄存器信息</span></span><br><span class="line">        utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">        utf-&gt;utf_err = tf-&gt;tf_trapno;</span><br><span class="line">        utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">        utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">        utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">        utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line">        <span class="comment">// 修改 esp 完成栈切换，修改 eip 运行 handler</span></span><br><span class="line">        tf-&gt;tf_eip = (uintptr_t)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">        <span class="comment">// tf-&gt;esp = (uintptr_t)utf - 1; 不需要减1</span></span><br><span class="line">        tf-&gt;tf_esp = (uintptr_t)utf;</span><br><span class="line">        env_run(curenv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">    cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">        curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Question</strong><br>What happens if the user environment runs out of space on the exception stack?</p>
</blockquote>
<p>在 <code>inc/memlayout.h</code> 中可以找到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UXSTACKTOP  UTOP</span></span><br><span class="line"><span class="comment">// Next page left invalid to guard against exception stack overflow;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220707135436275.png" alt="image-20220707135436275"></p>
<p>下面一页是空页，内核和用户访问都会报错。</p>
<p><strong>用户模式页错误入口</strong></p>
<p>在处理完页错误之后，现在我们需要编写汇编语句实现从异常栈到正常栈的切换。</p>
<h5 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10."></a>Exercise 10.</h5><p>Implement the <code>_pgfault_upcall</code> routine in <code>lib/pfentry.S</code>. The interesting part is returning to the original point in the user code that caused the page fault. You’ll return directly there, without going back through the kernel. The hard part is simultaneously switching stacks and re-loading the EIP.</p>
<p>汇编苦手，写的很艰难，最终还是参考了<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.csdn.net/bysui/article/details/51842817">别人的答案</a>。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    <span class="comment">// 调用用户定义的页错误处理函数</span></span><br><span class="line">    <span class="comment">// Call the C page fault handler.</span></span><br><span class="line">    pushl %esp          <span class="comment">// function argument: pointer to UTF</span></span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $<span class="number">4</span>, %esp           <span class="comment">// pop function argument</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    movl <span class="number">48</span>(%esp), %ebp</span><br><span class="line">    subl $<span class="number">4</span>, %ebp</span><br><span class="line">    movl %ebp, <span class="number">48</span>(%esp)</span><br><span class="line">    movl <span class="number">40</span>(%esp), %eax</span><br><span class="line">    movl %eax, (%ebp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore the trap-time registers.  After you do this, you</span></span><br><span class="line">    <span class="comment">// can no longer modify any general-purpose registers.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// 跳过 utf_err 以及 utf_fault_va</span></span><br><span class="line">    addl $<span class="number">8</span>, %esp</span><br><span class="line">    <span class="comment">// popal 同时 esp 会增加，执行结束后 %esp 指向 utf_eip</span></span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore eflags from the stack.  After you do this, you can</span></span><br><span class="line">    <span class="comment">// no longer use arithmetic operations or anything else that</span></span><br><span class="line">    <span class="comment">// modifies eflags.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// 跳过 utf_eip</span></span><br><span class="line">    addl $<span class="number">4</span>, %esp</span><br><span class="line">    <span class="comment">// 恢复 eflags</span></span><br><span class="line">    popfl</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch back to the adjusted trap-time stack.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// 恢复 trap-time 的栈顶</span></span><br><span class="line">    popl %esp</span><br><span class="line">    <span class="comment">// Return to re-execute the instruction that faulted.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// ret 指令相当于 popl %eip</span></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>首先必须要理解异常栈的结构，下图所示的是嵌套异常时的情况。其中左边表示内容，右边表示地址。需要注意的是，上一次异常的栈顶之下间隔 4byte，就是一个新的异常。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4482847-a33e11e5c9c54849.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/496" alt="img"></p>
<p>uxstack.png</p>
<p>最难理解的是这一部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl <span class="number">48</span>(%esp), %ebp  <span class="comment">// 使 %ebp 指向 utf_esp</span></span><br><span class="line">subl $<span class="number">4</span>, %ebp</span><br><span class="line">movl %ebp, <span class="number">48</span>(%esp)  <span class="comment">// 更新 utf_esp 值为 utf_esp-4</span></span><br><span class="line">movl <span class="number">40</span>(%esp), %eax</span><br><span class="line">movl %eax, (%ebp)  <span class="comment">// 将 utf_esp-4 地址的内容改为 utf_eip</span></span><br></pre></td></tr></table></figure>

<p>经过这一部分的修改，异常栈更新为（红字标出）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4482847-210592f47937410a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492" alt="img"></p>
<p>uxstack_new.png</p>
<p>此后就是恢复各寄存器，最后的 <code>ret</code> 指令相当于 <code>popl %eip</code>，指令寄存器的值修改为 <code>utf_eip</code>，达到了返回的效果。</p>
<h5 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11."></a><strong>Exercise 11.</strong></h5><blockquote>
<p>Finish <code>set_pgfault_handler()</code> in <code>lib/pgfault.c</code>.</p>
</blockquote>
<p>该练习是用户用来指定缺页异常处理方式的函数。代码比较简单，但是需要区分清楚 <code>handler</code>，<code>_pgfault_handler</code>，<code>_pgfault_upcall</code> 三个变量。</p>
<ol>
<li><code>handler</code> 是传入的用户自定义页错误处理函数指针。</li>
<li><code>_pgfault_upcall</code> 是一个全局变量，在 <code>lib/pfentry.S</code> 中完成的初始化。它是页错误处理的总入口，页错误除了运行 page fault handler，还需要切换回正常栈。</li>
<li><code>_pgfault_handler</code> 被赋值为handler，会在 <code>_pgfault_upcall</code> 中被调用，是页错误处理的一部分。具体代码是：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    <span class="comment">// Call the C page fault handler.</span></span><br><span class="line">    pushl %esp          <span class="comment">// function argument: pointer to UTF</span></span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $<span class="number">4</span>, %esp</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">set_pgfault_handler</span><span class="params">(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// First time through!</span></span><br><span class="line">        <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">        <span class="comment">// panic(&quot;set_pgfault_handler not implemented&quot;);</span></span><br><span class="line">        <span class="keyword">envid_t</span> e_id = <span class="built_in">sys_getenvid</span>();</span><br><span class="line">        r = <span class="built_in">sys_page_alloc</span>(e_id, (<span class="keyword">void</span> *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;pgfault_handler: %e&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// r = sys_env_set_pgfault_upcall(e_id, handler);</span></span><br><span class="line">        r = <span class="built_in">sys_env_set_pgfault_upcall</span>(e_id, _pgfault_upcall);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;pgfault_handler: %e&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">    _pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若是第一次调用，需要首先分配一个页面作为异常栈，并且将该进程的 upcall 设置为 Exercise 10 中的程序。此后如果需要改变handler，不需要再重复这个工作。<br>最后直接通过 <code>make grade</code> 测试，满足要求。</p>
<blockquote>
<p><strong>Question</strong><br>Why <code>user/faultalloc</code> and <code>user/faultallocbad</code> behave differently?</p>
</blockquote>
<p>两者的 page fault handler 一样，但是一个使用 <code>cprintf()</code> 输出，另一个使用 <code>sys_cput()</code> 输出。<br><code>sys_cput()</code>直接通过 <code>lib/syscall.c</code> 发起系统调用，其实现在 <code>kern/syscall.c</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sys_cputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">    <span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="built_in">user_mem_assert</span>(curenv, s, len, PTE_U);</span><br><span class="line">    <span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;%.*s&quot;</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它检查了内存，因此在这里 panic 了。中途没有触发过页错误。</p>
<p>而 <code>cprintf()</code> 的实现可以在 <code>lib/printf.c</code> 中找到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vcprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">printbuf</span> <span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    b.idx = <span class="number">0</span>;</span><br><span class="line">    b.cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vprintfmt</span>((<span class="keyword">void</span>*)putch, &amp;b, fmt, ap);</span><br><span class="line">    <span class="built_in">sys_cputs</span>(b.buf, b.idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b.cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">cprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_start</span>(ap, fmt);</span><br><span class="line">    cnt = <span class="built_in">vcprintf</span>(fmt, ap);</span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它在调用 <code>sys_cputs()</code> 之前，首先在用户态执行了 <code>vprintfmt()</code> 将要输出的字符串存入结构体 <code>b</code> 中。在此过程中试图访问 <code>0xdeadbeef</code> 地址，触发并处理了页错误（其处理方式是在错误位置处分配一个字符串，内容是 <code>&quot;this string was faulted in at ...&quot;</code>），因此在继续调用 <code>sys_cputs()</code> 时不会出现 panic。</p>
<h3 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h3><p>如同 <code>dumbfork()</code> 一样，<code>fork()</code> 也要创建一个新进程，并且在新进程中建立与父进程同样的内存映射。关键的不同点是，**<code>dumbfork()</code> 拷贝了物理页的内容，而 <code>fork()</code> 仅拷贝了映射关系，仅在某个进程需要改写某一页的内容时，才拷贝这一页的内容。其基本流程如下：**</p>
<ol>
<li>父进程使用 <code>set_pgfault_handler</code>将 <code>pgfault()</code> 设为 page fault handler</li>
<li>父进程使用 <code>sys_exofork()</code> 建立一个子进程</li>
<li>对每个在 <code>UTOP</code> 之下可写页面以及 COW 页面（用 <code>PTE_COW</code> 标识），父进程调用 <code>duppage</code> 将其“映射”到子进程，同时将其权限改为只读，并用 <code>PTE_COW</code> 位来与一般只读页面区别<br>异常栈的分配方式与此不同，需要在子进程中分配一个新页面。因为 page fault handler 会实实在在地向异常栈写入内容，并在异常栈上运行。如果异常栈页面都用 COW 机制，那就没有能够执行拷贝这个过程的载体了</li>
<li>父进程会为子进程设置 user page fault entrypoint</li>
<li>子进程已经就绪，父进程将其设为 runnable</li>
</ol>
<p>进程第一次往一个 COW page 写入内容时，会发生 page fault，其流程为：</p>
<ol>
<li>内核将 page fault 传递至 <code>_pgfault_upcall</code>，它会调用 <code>pgfault()</code> handler</li>
<li><code>pgfault()</code> 检查错误类型，以及页面是否标记为<code>PTE_COW</code></li>
<li><code>pgfault()</code> 分配一个新的页面并将 fault page 的内容拷贝进去，然后将旧的映射覆盖，使其映射到该新页面。</li>
</ol>
<h5 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12."></a><strong>Exercise 12.</strong></h5><blockquote>
<p>Implement <code>fork</code>, <code>duppage</code> and <code>pgfault</code> in <code>lib/fork.c</code>.<br>Test your code with the <code>forktree</code> program.</p>
</blockquote>
<p>非常难的一个练习。</p>
<ul>
<li><p><strong>fork() 函数</strong></p>
<p>首先从主函数 <code>fork()</code> 入手，其大体结构可以仿造 <code>user/dumbfork.c</code> 写，但是有关键几处不同：</p>
<ul>
<li>设置 page fault handler，即 page fault upcall 调用的函数</li>
<li>duppage 的范围不同，<code>fork()</code> 不需要复制内核区域的映射</li>
<li>为子进程设置 page fault upcall，之所以这么做，是因为 <code>sys_exofork()</code> 并不会复制父进程的 <code>e-&gt;env_pgfault_upcall</code> 给子进程。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">envid_t</span></span></span><br><span class="line"><span class="function"><span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;fork not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_pgfault_handler</span>(pgfault);</span><br><span class="line">    <span class="keyword">envid_t</span> e_id = <span class="built_in">sys_exofork</span>();</span><br><span class="line">    <span class="keyword">if</span> (e_id &lt; <span class="number">0</span>) <span class="built_in">panic</span>(<span class="string">&quot;fork: %e&quot;</span>, e_id);</span><br><span class="line">    <span class="keyword">if</span> (e_id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        thisenv = &amp;envs[<span class="built_in">ENVX</span>(<span class="built_in">sys_getenvid</span>())];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parent</span></span><br><span class="line">    <span class="comment">// extern unsigned char end[];</span></span><br><span class="line">    <span class="comment">// for ((uint8_t *) addr = UTEXT; addr &lt; end; addr += PGSIZE)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uintptr_t</span> addr = UTEXT; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (uvpd[<span class="built_in">PDX</span>(addr)] &amp; PTE_P) &amp;&amp; (uvpt[<span class="built_in">PGNUM</span>(addr)] &amp; PTE_P) ) &#123;</span><br><span class="line">            <span class="comment">// dup page to child</span></span><br><span class="line">            <span class="built_in">duppage</span>(e_id, <span class="built_in">PGNUM</span>(addr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// alloc page for exception stack</span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">sys_page_alloc</span>(e_id, (<span class="keyword">void</span> *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="built_in">panic</span>(<span class="string">&quot;fork: %e&quot;</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DO NOT FORGET</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall();</span><br><span class="line">    r = <span class="built_in">sys_env_set_pgfault_upcall</span>(e_id, _pgfault_upcall);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="built_in">panic</span>(<span class="string">&quot;fork: set upcall for child fail, %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark the child environment runnable</span></span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_env_set_status</span>(e_id, ENV_RUNNABLE)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sys_env_set_status: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>duppage() 函数</strong></p>
<p>该函数的作用是复制父、子进程的页面映射。尤其注意一个权限问题。由于 <code>sys_page_map()</code> 页面的权限有硬性要求，因此必须要修正一下权限。之前没有修正导致一直报错，后来发现页面权限为 <code>0x865</code>，不符合 <code>sys_page_map()</code> 要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;duppage not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">envid_t</span> this_env_id = <span class="built_in">sys_getenvid</span>();</span><br><span class="line">    <span class="keyword">void</span> * va = (<span class="keyword">void</span> *)(pn * PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> perm = uvpt[pn] &amp; <span class="number">0xFFF</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (perm &amp; PTE_W) || (perm &amp; PTE_COW) ) &#123;</span><br><span class="line">        <span class="comment">// marked as COW and read-only</span></span><br><span class="line">        perm |= PTE_COW;</span><br><span class="line">        perm &amp;= ~PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// IMPORTANT: adjust permission to the syscall</span></span><br><span class="line">    perm &amp;= PTE_SYSCALL;</span><br><span class="line">    <span class="comment">// cprintf(&quot;fromenvid = %x, toenvid = %x, dup page %d, addr = %08p, perm = %03x\n&quot;,this_env_id, envid, pn, va, perm);</span></span><br><span class="line">    <span class="keyword">if</span>((r = <span class="built_in">sys_page_map</span>(this_env_id, va, envid, va, perm)) &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;duppage: %e&quot;</span>,r);</span><br><span class="line">    <span class="keyword">if</span>((r = <span class="built_in">sys_page_map</span>(this_env_id, va, this_env_id, va, perm)) &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;duppage: %e&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>pgfault() 函数</strong></p>
<p>这是 _pgfault_upcall 中调用的页错误处理函数。在调用之前，父子进程的页错误地址都引用同一页物理内存，该函数作用是分配一个物理页面使得两者独立。<br>首先，它分配一个页面，映射到了交换区 <code>PFTEMP</code> 这个虚拟地址，然后通过 <code>memmove()</code> 函数将 <code>addr</code> 所在页面拷贝至 <code>PFTEMP</code>，此时有两个物理页保存了同样的内容。再将 <code>addr</code> 也映射到 <code>PFTEMP</code> 对应的物理页，最后解除了 <code>PFTEMP</code> 的映射，此时就只有 <code>addr</code> 指向新分配的物理页了，如此就完成了错误处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">pgfault</span><span class="params">(struct UTrapframe *utf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">    <span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line">    <span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line">    <span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((err &amp; FEC_WR)==<span class="number">0</span> || (uvpt[<span class="built_in">PGNUM</span>(addr)] &amp; PTE_COW)==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;pgfault: invalid user trap frame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line">    <span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line">    <span class="comment">// page to the old page&#x27;s address.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;pgfault not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">envid_t</span> envid = <span class="built_in">sys_getenvid</span>();</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_alloc</span>(envid, (<span class="keyword">void</span> *)PFTEMP, PTE_P | PTE_W | PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;pgfault: page allocation failed %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    addr = <span class="built_in">ROUNDDOWN</span>(addr, PGSIZE);</span><br><span class="line">    <span class="built_in">memmove</span>(PFTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_unmap</span>(envid, addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;pgfault: page unmap failed (%e)&quot;</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_map</span>(envid, PFTEMP, envid, addr, PTE_P | PTE_W |PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;pgfault: page map failed (%e)&quot;</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_unmap</span>(envid, PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;pgfault: page unmap failed (%e)&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>make run-forktree</code> 验证结果</p>
</li>
</ul>
<p>  ref：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d9b6dcce1c48">https://www.jianshu.com/p/d9b6dcce1c48</a></p>
<h2 id="Part-C-抢占式多进程处理-amp-进程间通信"><a href="#Part-C-抢占式多进程处理-amp-进程间通信" class="headerlink" title="Part C: 抢占式多进程处理 &amp; 进程间通信"></a>Part C: 抢占式多进程处理 &amp; 进程间通信</h2><p>作为 lab4 的最后一步，我们要修改内核使之能抢占一些不配合的进程占用的资源，以及允许进程之间的通信。</p>
<h3 id="Part-I-时钟中断以及抢占"><a href="#Part-I-时钟中断以及抢占" class="headerlink" title="Part I: 时钟中断以及抢占"></a>Part I: 时钟中断以及抢占</h3><p>尝试运行一下 <code>user/spin</code> 测试，该测试建立一个子进程，该子进程获得 CPU 资源后就进入死循环，这样内核以及父进程都无法再次获得 CPU。这显然是操作系统需要避免的。为了允许内核从一个正在运行的进程抢夺 CPU 资源，我们需要支持来自硬件时钟的外部硬件中断。</p>
<p><strong>Interrupt discipline</strong></p>
<p>外部中断用 IRQ(Interrupt Request) 表示。一共有 16 种 IRQ，在 <code>picirq.c</code>中将其增加了 <code>IRQ_OFFSET</code> 的偏移映射到了 IDT。<br>在 <code>inc/trap.h</code> 中， <code>IRQ_OFFSET</code> 被定义为 32。因此，IDT[32] 包含了时钟中断的处理入口地址。<br>联想 Lab3 中的内容：</p>
<blockquote>
<p>x86 的所有异常可以用中断向量 0<del>31 表示，对应 IDT 的第 0</del>31 项。例如，页错误产生一个中断向量为 14 的异常。大于 32 的中断向量表示的都是中断</p>
</blockquote>
<p>相对 xv6，在 JOS 中我们中了一个关键的简化：在内核态时禁用外部设备中断。外部中断使用 <code>%eflag</code> 寄存器的 <code>FL_IF</code> 位控制。当该位置 1 时，开启中断。由于我们的简化，我们只在进入以及离开内核时需要修改这个位。</p>
<p>我们需要确保在用户态时 <code>FL_IF</code> 置 1，使得当有中断发生时，可以被处理。我们在 bootloader 的第一条指令 <code>cli</code>就关闭了中断，然后再也没有开启过。</p>
<h4 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13."></a>Exercise 13.</h4><p>Modify <code>kern/trapentry.S</code> and <code>kern/trap.c</code> to initialize the appropriate entries in the IDT and provide handlers for IRQs 0 through 15. Then modify the code in <code>env_alloc()</code> in kern/env.c to ensure that user environments are always run with interrupts enabled.</p>
<p>比较简单，跟 Lab3 中的 Exercise 4 大同小异。相关的常数定义在 <code>inc/trap.h</code> 中可以找到。<br>在 <code>kern/trapentry.S</code> 中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// IRQs</span><br><span class="line">TRAPHANDLER(handler32, IRQ_OFFSET + IRQ_TIMER)</span><br><span class="line">TRAPHANDLER(handler33, IRQ_OFFSET + IRQ_KBD)</span><br><span class="line">TRAPHANDLER(handler36, IRQ_OFFSET + IRQ_SERIAL)</span><br><span class="line">TRAPHANDLER(handler39, IRQ_OFFSET + IRQ_SPURIOUS)</span><br><span class="line">TRAPHANDLER(handler46, IRQ_OFFSET + IRQ_IDE)</span><br><span class="line">TRAPHANDLER(handler51, IRQ_OFFSET + IRQ_ERROR)</span><br></pre></td></tr></table></figure>

<p>在 <code>kern/trap.c</code> 的 <code>trap_init()</code> 中加入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// IRQs</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler32</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler33</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler36</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler39</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler46</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler51</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// IRQs</span></span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], <span class="number">0</span>, GD_KT, handler32, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD], <span class="number">0</span>, GD_KT, handler33, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], <span class="number">0</span>, GD_KT, handler36, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="number">0</span>, GD_KT, handler39, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE], <span class="number">0</span>, GD_KT, handler46, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], <span class="number">0</span>, GD_KT, handler51, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在 <code>kern/env.c</code> 的 <code>env_alloc()</code> 中加入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable interrupts while in user mode.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure>

<p><strong>Handling Clock Interrupts</strong></p>
<p>在 <code>user/spin</code> 程序中，子进程开启后就陷入死循环，此后 kernel 无法再获得控制权。我们需要让硬件周期性地产生时钟中断，强制将控制权交给 kernel，使得我们能够切换到其他进程。</p>
<h4 id="Exercise-14"><a href="#Exercise-14" class="headerlink" title="Exercise 14."></a><strong>Exercise 14.</strong></h4><p>Modify the kernel’s <code>trap_dispatch()</code> function so that it calls <code>sched_yield()</code> to find and run a different environment whenever a clock interrupt takes place.</p>
<p>直接在 <code>trap_dispatch()</code> 中添加时钟中断的分支即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle clock interrupts. Don&#x27;t forget to acknowledge the</span></span><br><span class="line"><span class="comment">// interrupt using lapic_eoi() before calling the scheduler!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">    lapic_eoi();</span><br><span class="line">    sched_yield();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Part-II-进程间通信-Inter-Process-communication-IPC"><a href="#Part-II-进程间通信-Inter-Process-communication-IPC" class="headerlink" title="Part II: 进程间通信(Inter-Process communication)IPC"></a>Part II: 进程间通信(Inter-Process communication)IPC</h3><p><strong>IPC in JOS</strong></p>
<p>我们将实现两个系统调用：<code>sys_ipc_recv</code> 以及 <code>sys_ipc_try_send</code> ，再将他们封装为两个库函数，<code>ipc_recv</code> 和 <code>ipc_send</code> 以支持通信。<br>实际上，进程之间发送的信息是由两个部分组成，一个 <code>int32_t</code>，一个页面映射(可选)。</p>
<p><strong>发送和接收消息</strong></p>
<p>进程使用 <code>sys_ipc_recv</code> 来接收消息。该系统调用会将程序挂起，让出 CPU 资源，直到收到消息。在这个时期，任一进程都能给他发送信息，不限于父子进程。<br>为了发送信息，进程会调用 <code>sys_ipc_try_send</code>，以接收者的进程 id 以及要发送的值为参数。如果接收者已经调用了 <code>sys_ipc_recv</code> ，则成功发送消息并返回0。否则返回 <code>E_IPC_NOT_RECV</code> 表明目标进程并没有接收消息。<br><code>ipc_send</code> 库函数将会反复执行 <code>sys_ipc_try_send</code> 直到成功。</p>
<p><strong>传递页面</strong></p>
<p>当进程调用 <code>sys_ipc_recv</code> 并提供一个虚拟地址 <code>dstva</code> (必须位于用户空间) 时，进程表示它希望能接收一个页面映射。如果发送者发送一个页面，该页面就会被映射到接收者的 <code>dstva</code>。同时，之前位于 <code>dstva</code> 的页面映射会被覆盖。</p>
<p>当进程调用 <code>sys_ipc_try_send</code> 并提供一个虚拟地址 <code>srcva</code> (必须位于用户空间)，表明发送者希望发送位于 <code>srcva</code>的页面给接收者，权限设置为 <code>perm</code>。</p>
<p><strong>在一个成功的 IPC 之后，发送者和接受者将共享一个物理页。</strong></p>
<h4 id="Exercise-15"><a href="#Exercise-15" class="headerlink" title="Exercise 15."></a><strong>Exercise 15.</strong></h4><p>Implement <code>sys_ipc_recv</code> and <code>sys_ipc_try_send</code> in kern/syscall.c. Read the comments on both before implementing them, since they have to work together. When you call <code>envid2env</code> in these routines, you should set the <code>checkperm</code> flag to 0, meaning that any environment is allowed to send IPC messages to any other environment, and the kernel does no special permission checking other than verifying that the target envid is valid.<br>Then implement the <code>ipc_recv</code> and <code>ipc_send</code> functions in <code>lib/ipc.c</code>.</p>
<p>首先需要仔细阅读 <code>inc/env.h</code> 了解用于传递消息的数据结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lab 4 IPC</span></span><br><span class="line"><span class="keyword">bool</span> env_ipc_recving;       <span class="comment">// 当前进程的状态,表明当前进程是否处于接受状态。</span></span><br><span class="line"><span class="keyword">void</span> *env_ipc_dstva;        <span class="comment">// VA at which to map received page</span></span><br><span class="line"><span class="keyword">uint32_t</span> env_ipc_value;     <span class="comment">// 当前进程接收到的数据（如果用页来传递数据）。</span></span><br><span class="line"><span class="keyword">envid_t</span> env_ipc_from;       <span class="comment">// envid of the sender</span></span><br><span class="line"><span class="keyword">int</span> env_ipc_perm;       <span class="comment">// Perm of page mapping received</span></span><br></pre></td></tr></table></figure>

<p>然后需要注意的是通信流程。</p>
<ol>
<li>调用 <code>ipc_recv</code>，设置好 Env 结构体中的相关 field</li>
<li>调用 <code>ipc_send</code>，它会通过 envid 找到接收进程，并读取 Env 中刚才设置好的 field，进行通信。</li>
<li>最后返回实际上是在 <code>ipc_send</code> 中设置好 reg_eax，在调用结束，退出内核态时返回。</li>
</ol>
<p><strong>lib/ipc.c</strong></p>
<p>ipc_recv()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span></span></span><br><span class="line"><span class="function"><span class="title">ipc_recv</span><span class="params">(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">   <span class="comment">// panic(&quot;ipc_recv not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span>(pg!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        r = sys_ipc_recv(pg);  <span class="comment">// pg是个虚拟地址（必须位于用户空间），表示希望能接受一个页面映射到此虚拟地址</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r = sys_ipc_recv(UTOP);  <span class="comment">// 如果不需要共享界面，则把虚拟地址设置为UTOP</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// fail</span></span><br><span class="line">        <span class="keyword">if</span> (from_env_store != <span class="literal">NULL</span>) *from_env_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (perm_store != <span class="literal">NULL</span>) *perm_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (from_env_store != <span class="literal">NULL</span>)</span><br><span class="line">            *from_env_store = thisenv-&gt;env_ipc_from;  <span class="comment">// 存取ipc sender&#x27;s page</span></span><br><span class="line">        <span class="keyword">if</span> (perm_store != <span class="literal">NULL</span>)</span><br><span class="line">            *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">        <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ipc_send</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ipc_send</span><span class="params">(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">   <span class="comment">// panic(&quot;ipc_send not implemented&quot;);</span></span><br><span class="line">    <span class="comment">// sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)</span></span><br><span class="line">    <span class="comment">// 发送位于srcva出得界面给接收者</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span>(pg == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pg = (<span class="keyword">void</span>*) UTOP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        r = sys_ipc_try_send(to_env, val, pg, perm);</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span> &amp;&amp; r!=-E_IPC_NOT_RECV)&#123;</span><br><span class="line">            panic(<span class="string">&quot;ipc send failed.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;<span class="keyword">while</span>(r!=<span class="number">0</span>);   <span class="comment">// 一直尝试发送</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>kern/syscall.c</strong></p>
<p>与 <code>sys_page_map()</code> 非常相似，但是其中最大的区别在于，ipc 通信并不限于父子进程之间，而 <code>sys_page_map()</code> 最初设计的作用就是用于 <code>fork()</code>。</p>
<p>sys_ipc_try_send</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_ipc_try_send</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva, <span class="keyword">unsigned</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">   <span class="comment">// panic(&quot;sys_ipc_try_send not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">envid_t</span> src_envid = sys_getenvid();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">dst_e</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(envid2env(env_id, &amp;dst_e, <span class="number">0</span>)&lt;<span class="number">0</span>)&#123;  <span class="comment">// Converts an envid to an env pointer.</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dst_e-&gt;env_ipc_recving == <span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pass the value</span></span><br><span class="line">    dst_e-&gt;env_ipc_value = value;</span><br><span class="line">    dst_e-&gt;env_ipc_perm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass the page</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva &lt; UTOP) &#123;</span><br><span class="line">        <span class="comment">// customerize 0x200 as PTE_NO_CHECK</span></span><br><span class="line">        <span class="keyword">unsigned</span> tmp_perm = perm | <span class="number">0x200</span>;</span><br><span class="line">        <span class="comment">// sys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, int perm)</span></span><br><span class="line">        <span class="comment">// Map the page of memory at &#x27;srcva&#x27; in srcenvid&#x27;s address space</span></span><br><span class="line">        <span class="comment">// at &#x27;dstva&#x27; in dstenvid&#x27;s address space with permission &#x27;perm&#x27;.</span></span><br><span class="line">        <span class="keyword">int</span> r = sys_page_map(src_envid, srcva, envid, (<span class="keyword">void</span> *)dst_e-&gt;env_ipc_dstva, tmp_perm);  <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">        dst_e-&gt;env_ipc_perm = perm;</span><br><span class="line">    &#125;</span><br><span class="line">    dst_e-&gt;env_ipc_from = src_envid;</span><br><span class="line">    dst_e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    dst_e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    dst_e-&gt;env_ipc_recving = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_page_map</span><span class="params">(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_page_map not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva &gt;= UTOP || PGOFF(srcva) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)dstva &gt;= UTOP || PGOFF(dstva) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; PTE_U) == <span class="number">0</span> || (perm &amp; PTE_P) == <span class="number">0</span> || (perm &amp; ~PTE_SYSCALL) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">src_e</span>, *<span class="title">dst_e</span>;</span></span><br><span class="line">    <span class="comment">// add for lab4 exercise 15 for ipc.</span></span><br><span class="line">    <span class="comment">// customerize 0x200 as PTE_NO_CHECK</span></span><br><span class="line">    <span class="comment">// and we assume 0x200 is not used elsewhere, so we restore perm here.</span></span><br><span class="line">    <span class="keyword">bool</span> check_perm = (perm &amp; <span class="number">0x200</span>);</span><br><span class="line">    perm &amp;= (~<span class="number">0x200</span>);</span><br><span class="line">    <span class="keyword">if</span> (envid2env(srcenvid, &amp;src_e, !check_perm)&lt;<span class="number">0</span> || envid2env(dstenvid, &amp;dst_e, !check_perm)&lt;<span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    <span class="keyword">pte_t</span> *src_ptab;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_lookup(src_e-&gt;env_pgdir, srcva, &amp;src_ptab);</span><br><span class="line">    <span class="keyword">if</span> ((*src_ptab &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (perm &amp; PTE_W) == <span class="number">1</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> (page_insert(dst_e-&gt;env_pgdir, pp, dstva, perm) &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/6-828-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 6.828,操作系统</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/28/6-828Lab3/" rel="prev" title="6.828Lab3">
                  <i class="fa fa-chevron-left"></i> 6.828Lab3
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/08/6-828Lab5/" rel="next" title="6-828Lab5">
                  6-828Lab5 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
