<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="Lab 5: File system, Spawn and ShellIntroductionIn this lab, you will implement spawn, a library call that loads and runs on-disk executables. 然后，您将充实内核和库操作系统，使其足以在控制台上运行shell。这些特性需要一个文件系统，本实验室介绍了一个简单的">
<meta property="og:type" content="article">
<meta property="og:title" content="6-828Lab5">
<meta property="og:url" content="http://example.com/2022/07/08/6-828Lab5/index.html">
<meta property="og:site_name" content="我的一些记录">
<meta property="og:description" content="Lab 5: File system, Spawn and ShellIntroductionIn this lab, you will implement spawn, a library call that loads and runs on-disk executables. 然后，您将充实内核和库操作系统，使其足以在控制台上运行shell。这些特性需要一个文件系统，本实验室介绍了一个简单的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/disk.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/file.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220708171856337.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/lab5_7_open()%E5%8E%9F%E7%90%86.png">
<meta property="article:published_time" content="2022-07-08T06:34:18.000Z">
<meta property="article:modified_time" content="2022-07-22T12:18:29.745Z">
<meta property="article:tag" content="操作系统,6.828">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/disk.png">


<link rel="canonical" href="http://example.com/2022/07/08/6-828Lab5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/07/08/6-828Lab5/","path":"2022/07/08/6-828Lab5/","title":"6-828Lab5"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>6-828Lab5 | 我的一些记录</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">我的一些记录</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab-5-File-system-Spawn-and-Shell"><span class="nav-number">1.</span> <span class="nav-text">Lab 5: File system, Spawn and Shell</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">1.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#File-system-preliminaries%EF%BC%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%AD%A5%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">File system preliminaries（文件系统初步）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#On-Disk-File-System-Structure"><span class="nav-number">1.2.1.</span> <span class="nav-text">On-Disk File System Structure</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Sectors-and-Blocks"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">Sectors and Blocks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Superblocks"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">Superblocks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File-Meta-data"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">File Meta-data</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Directories-versus-Regular-Files-%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">Directories versus Regular Files(目录与普通文件)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-File-System"><span class="nav-number">1.3.</span> <span class="nav-text">The File System</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Disk-Access"><span class="nav-number">1.3.1.</span> <span class="nav-text">Disk Access</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-1"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Exercise 1:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Block-Cache"><span class="nav-number">1.3.2.</span> <span class="nav-text">The Block Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-2%EF%BC%9A"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">Exercise 2：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Block-Bitmap"><span class="nav-number">1.3.3.</span> <span class="nav-text">The Block Bitmap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-3%EF%BC%9A"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">Exercise 3：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#File-Operations"><span class="nav-number">1.3.4.</span> <span class="nav-text">File Operations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-4"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">Exercise 4:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-file-system-interface"><span class="nav-number">1.3.5.</span> <span class="nav-text">The file system interface</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-5"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">Exercise 5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-6"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">Exercise 6</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spawning-Processes"><span class="nav-number">1.4.</span> <span class="nav-text">Spawning Processes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-7"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">Exercise 7</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sharing-library-state-across-fork-and-spawn"><span class="nav-number">1.4.1.</span> <span class="nav-text">Sharing library state across fork and spawn</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-8"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Exercise 8</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-keyboard-interface"><span class="nav-number">1.5.</span> <span class="nav-text">The keyboard interface</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Shell"><span class="nav-number">1.6.</span> <span class="nav-text">The Shell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/08/6-828Lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          6-828Lab5
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-08 14:34:18" itemprop="dateCreated datePublished" datetime="2022-07-08T14:34:18+08:00">2022-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-22 20:18:29" itemprop="dateModified" datetime="2022-07-22T20:18:29+08:00">2022-07-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Lab-5-File-system-Spawn-and-Shell"><a href="#Lab-5-File-system-Spawn-and-Shell" class="headerlink" title="Lab 5: File system, Spawn and Shell"></a>Lab 5: File system, Spawn and Shell</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In this lab, you will implement <code>spawn</code>, a library call that loads and runs on-disk executables. 然后，您将充实内核和库操作系统，使其足以在控制台上运行shell。这些特性需要一个文件系统，本实验室介绍了一个简单的读写文件系统。</p>
<table>
<thead>
<tr>
<th>file</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>fs/fs.c</code></td>
<td>操纵文件系统磁盘上结构的代码。</td>
</tr>
<tr>
<td><code>fs/bc.c</code></td>
<td>一个建立在用户级页面错误处理设施之上的简单块缓存。</td>
</tr>
<tr>
<td><code>fs/ide.c</code></td>
<td>最小的基于pio(非中断驱动)的IDE驱动程序代码。</td>
</tr>
<tr>
<td><code>fs/serv.c</code></td>
<td>使用文件系统IPCS与客户机环境交互的文件系统服务器。</td>
</tr>
<tr>
<td><code>lib/fd.c</code></td>
<td>实现通用类unix文件描述符接口的代码。</td>
</tr>
<tr>
<td><code>lib/file.c</code></td>
<td>用于磁盘上文件类型的驱动程序，实现为文件系统IPC客户机。</td>
</tr>
<tr>
<td><code>lib/console.c</code></td>
<td>控制台输入/输出文件类型的驱动程序。</td>
</tr>
<tr>
<td><code>lib/spawn.c</code></td>
<td><code>spawn</code>库调用的代码框架。</td>
</tr>
</tbody></table>
<h2 id="File-system-preliminaries（文件系统初步）"><a href="#File-system-preliminaries（文件系统初步）" class="headerlink" title="File system preliminaries（文件系统初步）"></a>File system preliminaries（文件系统初步）</h2><p>我们要完成一个相对简单的文件系统，其可以实现创建、读、写以及删除在分层目录结构中组织的文件。目前我们的OS只支持单用户，因此我们的文件系统也不支持UNIX文件拥有或权限的概念。同时也不支持硬链接、符号链接、时间戳或是特别的设备文件。</p>
<h3 id="On-Disk-File-System-Structure"><a href="#On-Disk-File-System-Structure" class="headerlink" title="On-Disk File System Structure"></a>On-Disk File System Structure</h3><p>大多数UNIX文件系统将可用磁盘空间划分为两种主要类型的区域:inode区域和数据区域。UNIX文件系统为文件系统中的每个文件分配一个inode;一个文件的inode保存着关于该文件的关键元数据，比如它的属性和指向其数据块的指针。数据区域被划分为更大的数据块(通常为8KB或更多)，文件系统在其中存储文件数据和目录元数据。目录项包含文件名和指向索引节点的指针;如果文件系统中的多个目录条目引用了该文件的inode，则该文件被称为硬链接文件。由于我们的文件系统不支持硬链接，我们不需要这种间接级别，因此可以进行方便的简化:我们的文件系统根本不使用inode，而只是将一个文件(或子目录)的所有元数据存储在描述该文件的(唯一的)目录条目中。</p>
<p>文件和目录在逻辑上都由一系列数据块组成，这些数据块可以分散在磁盘中，就像环境的虚拟地址空间的页面可以分散在物理内存中一样。文件系统环境隐藏了块布局的细节，提供了在文件中任意偏移位置读取和写入字节序列的接口。文件系统环境在内部处理对目录的所有修改，作为执行文件创建和删除等操作的一部分。我们的文件系统允许用户环境直接读取目录元数据(例如，使用read)，这意味着用户环境可以自己执行目录扫描操作(例如，实现ls程序)，而不必依赖于对文件系统的额外特殊调用。这种目录扫描方法的缺点是，它使应用程序依赖于目录元数据的格式，在不更改或至少重新编译应用程序的情况下，很难更改文件系统的内部布局，这也是大多数现代UNIX变体不鼓励使用这种方法的原因。</p>
<h4 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h4><p>扇区是对磁盘的概念，块是对OS的概念。 块的 size 必须是扇区size 的整数倍。</p>
<h4 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h4><p>文件系统通常在磁盘上的“易于查找”位置保留某些磁盘块（例如从最开始或最后）以保存描述文件系统属性的元数据，例如块大小 ，磁盘大小，查找根目录所需的任何元数据，上次挂载文件系统的时间，文件系统上次检查错误的时间等等。 这些特殊块称为超级块。</p>
<p>我们的文件系统将只有一个超级块，它始终位于磁盘上的第1块。它的布局由struct Super在<code>inc/fs.h</code>中定义。<strong>块0通常保留来保存引导加载程序和分区表</strong>，因此文件系统通常不使用第一个磁盘块。许多“真正的”文件系统维护多个超级块，复制到磁盘上几个间隔很宽的区域，因此，如果其中一个超级块损坏或磁盘在该区域出现了媒体错误，仍然可以找到其他超级块，并使用它们访问文件系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_magic;        <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_nblocks;        <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>        <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>Superblock, Inode, Dentry 和 File 都属于元数据(Metadata)，</strong>根据维基百科中的解释，<strong>所谓元数据，就是描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。Linux/Unix 文件系统的元数据以多级结构保存</strong>。</p>
<p>superblock：记录此filesystem 的整体信息，包括inode[表情]ock的总量、使用量、剩余量， 以及档案系统的格式与相关信息等；<br>inode：记录档案的属性，一个档案占用一个inode，同时记录此档案的资料所在的block 号码；<br>block：实际记录档案的内容，若档案太大时，会占用多个block 。</p>
<p>Superblock 是文件系统最基本的元数据，它定义了文件系统的类似、大小、状态，和其他元数据结构的信息（元数据的元数据）。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/disk.png" alt="Disk layout"></p>
<h4 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h4><p>The layout of the meta-data describing a file in our file system is described by struct File in <code>inc/fs.h</code>. Unlike in most “real” file systems, for simplicity we will use this one File structure to represent file meta-data</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> f_name[MAXNAMELEN];    <span class="comment">// filename</span></span><br><span class="line">    <span class="keyword">off_t</span> f_size;            <span class="comment">// file size in bytes</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_type;        <span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block pointers.</span></span><br><span class="line">    <span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_direct[NDIRECT];    <span class="comment">// direct blocks</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_indirect;        <span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad out to 256 bytes; must do arithmetic in case we&#x27;re compiling</span></span><br><span class="line">    <span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line">    <span class="keyword">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));    <span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/file.png" alt="File structure"></p>
<h4 id="Directories-versus-Regular-Files-目录与普通文件"><a href="#Directories-versus-Regular-Files-目录与普通文件" class="headerlink" title="Directories versus Regular Files(目录与普通文件)"></a>Directories versus Regular Files(目录与普通文件)</h4><p>我们的文件系统中的超级块包含一个 <code>File</code>结构，其保存了文件系统根目录的元数据。这个目录文件的内容是一系列文件结构体，其描述了文件系统根目录下的文件和目录。任何根目录下的子目录可能包含更多表示子子目录的文件结构体，以此类推。</p>
<h2 id="The-File-System"><a href="#The-File-System" class="headerlink" title="The File System"></a>The File System</h2><p>我们实现的文件系统的关键部分是:</p>
<ul>
<li><p>读数据到缓存中并能写回到磁盘；</p>
</li>
<li><p>分配磁盘块; </p>
</li>
<li><p>将文件偏移映射到磁盘块; </p>
</li>
<li><p>并在IPC接口中实现读，写和打开。</p>
</li>
</ul>
<h3 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h3><p>操作系统中的文件系统环境需要能够访问磁盘，但是我们还没有在内核中实现任何磁盘访问功能。我们没有采用传统的“单片”操作系统策略，即在内核中添加IDE磁盘驱动程序以及允许文件系统访问它的必要系统调用，而是将IDE磁盘驱动程序作为用户级文件系统环境的一部分来实现。我们仍然需要稍微修改内核，以便让文件系统环境拥有实现磁盘访问所需的权限。</p>
<p>只要我们依赖于轮询、基于“编程I/O”(PIO)的磁盘访问，并且不使用磁盘中断，就很容易通过这种方式在用户空间中实现磁盘访问。也可以在用户模式下实现中断驱动的设备驱动程序(例如，L3和L4内核就可以做到这一点)，但难度更大，因为内核必须字段设备中断并将它们分派到正确的用户模式环境中。</p>
<p>x86处理器使用EFLAGS寄存器中的IOPL位来确定是否允许保护模式代码执行特殊的设备I/O指令，如in和OUT指令。因为我们需要访问的所有IDE磁盘寄存器都位于x86的I/O空间中，而不是内存映射的，所以给文件系统环境“I/O特权”是我们唯一需要做的事情，以便允许文件系统访问这些寄存器。实际上，EFLAGS寄存器中的IOPL位为内核提供了一种简单的“全或无”方法来控制用户模式代码是否可以访问I/O空间。在我们的示例中，我们希望文件系统环境能够访问I/O空间，但是我们根本不希望任何其他环境能够访问I/O空间。</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1:"></a>Exercise 1:</h4><p> i386_init通过将类型ENV_TYPE_FS传递给环境创建函数env_create来标识文件系统环境。在env.c中修改env_create，使它赋予文件系统环境I/O权限，但不赋予任何其他环境该权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">env_create</span><span class="params">(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span>   <span class="comment">// 新建一个进程</span></span><br><span class="line">    <span class="keyword">int</span> r = env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;env_create: env alloc error: %e&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配成功</span></span><br><span class="line">    e-&gt;env_type = type;</span><br><span class="line">    <span class="comment">// 添加文件权限</span></span><br><span class="line">    <span class="keyword">if</span>(type == ENV_TYPE_FS)&#123;</span><br><span class="line">        e-&gt;env_tf.tf_eflages |= FL_IOPL_MASK</span><br><span class="line">    &#125;</span><br><span class="line">    load_icode(e, binary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Question</strong></p>
<ol>
<li><p>Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?</p>
<p>不需要，因为在环境切换时，会保存eflags的值，后续也会使用env_pop_tf来恢复eflags的值。</p>
</li>
</ol>
<h3 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h3><p>在我们的文件系统中，我们将在处理器的虚拟内存系统的帮助下实现一个简单的“缓冲区缓存”(实际上只是块缓存)。块缓存的代码在<code>fs/bc.c</code>中。</p>
<p>我们的文件系统只能处理3GB或更小的磁盘。我们在文件系统环境的地址空间中保留了一个很大的、固定的3GB区域，从0x10000000 (DISKMAP)到0xD0000000 (DISKMAP+DISKMAX)，作为磁盘的“内存映射”版本。例如，磁盘块0映射到虚拟地址0x10000000，磁盘块1映射到虚拟地址0x10001000，依此类推。fs/bc.c中的diskaddr函数实现了从磁盘块号到虚拟地址的转换(以及一些完整性检查)。</p>
<p>将整个磁盘读入内存需要很长时间，因此我们将实现一种<strong>请求页面调度</strong>，当进程在运行时需要访问某部分程序和数据时，若发现请求页面不在内存，便提出请求，由OS将其所需页面调入内存。这样，我们就可以假装整个磁盘都在内存中。</p>
<h4 id="Exercise-2："><a href="#Exercise-2：" class="headerlink" title="Exercise 2："></a><strong>Exercise 2：</strong></h4><p>implement the <code>bc_pgfault</code> and <code>flush_block</code> functions in <code>fs/bc.c</code>. </p>
<p><code>bc_pgfault</code> is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, 只不过它的工作是从磁盘加载页面以响应页面错误. </p>
<p>When writing this, keep in mind that</p>
<p>​    (1) <code>addr</code> may not be aligned to a block boundary and </p>
<p>​    (2) <code>ide_read</code> operates in sectors, not blocks.</p>
<p>如果需要，flush_block函数应该将一个块写入磁盘。如果块甚至不在块缓存中(也就是说，页面没有映射)，或者它不是脏的，则Flush_block不应该做任何事情。我们将使用VM硬件来跟踪磁盘块自上次从磁盘读取或写入磁盘以来是否被修改过。要查看一个块是否需要写入，我们只需查看uvpt条目中是否设置了PTE_D“脏”位。PTE_D位由处理器设置，以响应对该页的写操作;参见386参考手册第五章5.2.4.3。)将块写入磁盘后，flush_block应该使用sys_page_map清除PTE_D位。</p>
<p>采用了wb</p>
<p><strong>块号与扇区号有一定的区别，在完成这两个函数时，要注意区分这两个概念。 JOS 块大小位4kB，扇区大小为512B，每次读写一个块，就需要读写4个扇区。因此，JOS使用了一个宏定义<code>#define BLKSECTS (BLKSIZE / SECTSIZE)</code>来描述两者的关系。</strong></p>
<p><strong>bc_pgfault()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">bc_pgfault</span><span class="params">(struct UTrapframe *utf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">   <span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">   <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check that the fault was within the block cache region</span></span><br><span class="line">   <span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">      panic(<span class="string">&quot;page fault in FS: eip %08x, va %08x, err %04x&quot;</span>,</span><br><span class="line">            utf-&gt;utf_eip, addr, utf-&gt;utf_err);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Sanity check the block number.</span></span><br><span class="line">   <span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">      panic(<span class="string">&quot;reading non-existent block %08x\n&quot;</span>, blockno);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allocate a page in the disk map region, read the contents</span></span><br><span class="line">   <span class="comment">// of the block from the disk into that page.</span></span><br><span class="line">   <span class="comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span></span><br><span class="line">   <span class="comment">// the disk.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// LAB 5: you code here:</span></span><br><span class="line">    addr = (<span class="keyword">void</span>*) ROUNDUP(addr, PGSIZE);</span><br><span class="line">    <span class="comment">// Allocate a page of memory and map it at &#x27;addr&#x27; with permission &#x27;PTE_P|PTE_W|PTE_U&#x27; in the address space of &#x27;envid&#x27;.</span></span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_alloc(<span class="number">0</span>,addr,PTE_P|PTE_W|PTE_U))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;in bc_pgfault, sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (r = ide_read(blockno*BLKSECTS, addr, BLKSECTS)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;in bc_pgfault, ide_read: %e&quot;</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Clear the dirty bit for the disk block page since we just read the</span></span><br><span class="line">   <span class="comment">// block from disk</span></span><br><span class="line">   <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check that the block we read was allocated. (exercise for</span></span><br><span class="line">   <span class="comment">// the reader: why do we do this *after* reading the block</span></span><br><span class="line">   <span class="comment">// in?)</span></span><br><span class="line">   <span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">      panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>flush_block()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果需要，将包含VA的块的内容清除到磁盘，然后使用sys_page_map清除PTE_D位。</span></span><br><span class="line"><span class="comment">// 如果该块不在块缓存中或不是脏的，则不做任何操作。</span></span><br><span class="line"><span class="comment">// Hint: Use va_is_mapped, va_is_dirty, and ide_write.</span></span><br><span class="line"><span class="comment">// Hint: Use the PTE_SYSCALL constant when calling sys_page_map.</span></span><br><span class="line"><span class="comment">// Hint: Don&#x27;t forget to round addr down.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">flush_block</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))    <span class="comment">// 越界</span></span><br><span class="line">      panic(<span class="string">&quot;flush_block of bad va %08x&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">   <span class="comment">//panic(&quot;flush_block not implemented&quot;);</span></span><br><span class="line">    addr = (<span class="keyword">void</span> *)ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> (va_is_mapped(addr) &amp;&amp; va_is_dirty(addr)) &#123;  <span class="comment">// 映射过并且为脏</span></span><br><span class="line">        ide_write(blockno*BLKSECTS, addr , BLKSECTS);  <span class="comment">// 写回到磁盘</span></span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)   <span class="comment">// 清空PTE_D (脏)位</span></span><br><span class="line">            panic(<span class="string">&quot;in flush_block, sys_page_map: %e&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fs/fs.c中的fs_init()将会初始化super和bitmap全局指针变量。</p>
<p>至此对于文件系统进程只要访问虚拟内存[DISKMAP, DISKMAP+DISKMAX]范围中的地址addr，就会访问到磁盘((uint32_t)addr - DISKMAP) / BLKSIZE block中的数据。</p>
<p>如果block数据还没复制到内存物理页，bc_pgfault()缺页处理函数会将数据从磁盘拷贝到某个物理页，并且将addr映射到该物理页。这样FS进程只需要访问虚拟地址空间[DISKMAP, DISKMAP+DISKMAX]就能访问磁盘了。</p>
<p><strong>JOS FS进程地址空间和磁盘映射：</strong></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220708171856337.png" alt="image-20220708171856337"></p>
<h3 id="The-Block-Bitmap"><a href="#The-Block-Bitmap" class="headerlink" title="The Block Bitmap"></a>The Block Bitmap</h3><p>在fs_init设置位图(btimap)指针之后，我们可以将位图视为一个位的压缩数组，磁盘上的每个块对应一个位。例如，<code>block_is_free</code>，它只是检查位图中给定的块是否被标记为空闲。</p>
<h4 id="Exercise-3："><a href="#Exercise-3：" class="headerlink" title="Exercise 3："></a>Exercise 3：</h4><p>使用free_block作为模型来实现fs/fs.c中的alloc_block，它应该在位图中找到一个空闲的磁盘块，标记它已被使用，并返回该块的编号。当您分配一个块时，您应该立即使用flush_block将更改后的位图块刷新到磁盘，以帮助文件系统保持一致性。</p>
<p><strong>我们以一个实例来分析 bitmap的工作原理， 若标记第35个块（块号为34）为使用状态， 则将bitmap[1] 的第 2 （34%32）位标记为 0。 讲道理应该位图位为0是free的呀，JOS这里反过来了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search the bitmap for a free block and allocate it.  When you</span></span><br><span class="line"><span class="comment">// allocate a block, immediately flush the changed bitmap block</span></span><br><span class="line"><span class="comment">// to disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return block number allocated on success,</span></span><br><span class="line"><span class="comment">// -E_NO_DISK if we are out of blocks.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: use free_block as an example for manipulating the bitmap.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">alloc_block</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// The bitmap consists of one or more blocks.  A single bitmap block</span></span><br><span class="line">   <span class="comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span></span><br><span class="line">   <span class="comment">// super-&gt;s_nblocks blocks in the disk altogether.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">   <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;super-&gt;s_nblocks;++i)&#123;</span><br><span class="line">        <span class="comment">// block_is_free(): Check to see if the block bitmap indicates that block &#x27;blockno&#x27; is free.</span></span><br><span class="line">        <span class="comment">// Return 1 if the block is free, 0 if not.</span></span><br><span class="line">        <span class="keyword">if</span>(block_is_free(i))&#123;  <span class="comment">// 没有使用，则标记为已使用</span></span><br><span class="line">            bitmap[i/<span class="number">32</span>] &amp;=  ~(<span class="number">1</span>&lt;&lt;(i%<span class="number">32</span>));</span><br><span class="line">            flush_block(&amp;bitmap[i/<span class="number">32</span>]);  <span class="comment">// 写回并重置脏位</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//panic(&quot;alloc_block not implemented&quot;);</span></span><br><span class="line">   <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a>File Operations</h3><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4:"></a>Exercise 4:</h4><p>实现file_block_walk和file_get_block。file_block_walk将文件中的块偏移量映射到struct file或间接块中该块的指针，非常像pgdir_walk对页表所做的。File_get_block更进一步，映射到实际的磁盘块，如果需要，分配一个新的磁盘块。</p>
<p>file_block_walk 获得文件第<code>filebno</code>块的地址（其本身是个指针），编写需要注意以下几点。</p>
<ul>
<li><code>ppdiskbno</code> 是块指针（记录块的地址）</li>
<li><code>f_indirect</code> 直接记录块号，而不是记地址。</li>
<li><strong>Don’t forget to clear any block you allocate.</strong> 对分配的块进行清零操作后，要写入 disk 中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the disk block number slot for the &#x27;filebno&#x27;th block in file &#x27;f&#x27;.</span></span><br><span class="line"><span class="comment">// Set &#x27;*ppdiskbno&#x27; to point to that slot.</span></span><br><span class="line"><span class="comment">// The slot will be one of the f-&gt;f_direct[] entries,</span></span><br><span class="line"><span class="comment">// or an entry in the indirect block.</span></span><br><span class="line"><span class="comment">// When &#x27;alloc&#x27; is set, this function will allocate an indirect block</span></span><br><span class="line"><span class="comment">// if necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">// 0 on success (but note that *ppdiskbno might equal 0).</span></span><br><span class="line"><span class="comment">// -E_NOT_FOUND if the function needed to allocate an indirect block, but</span></span><br><span class="line"><span class="comment">//    alloc was 0.</span></span><br><span class="line"><span class="comment">// -E_NO_DISK if there&#x27;s no space on the disk for an indirect block.</span></span><br><span class="line"><span class="comment">// -E_INVAL if filebno is out of range (it&#x27;s &gt;= NDIRECT + NINDIRECT).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Analogy: This is like pgdir_walk for files.</span></span><br><span class="line"><span class="comment">// Hint: Don&#x27;t forget to clear any block you allocate.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">file_block_walk</span><span class="params">(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">uint32_t</span> **ppdiskbno, <span class="keyword">bool</span> alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// filenno   file block number</span></span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;file_block_walk not implemented&quot;);</span></span><br><span class="line">    <span class="comment">// ppdiskbno 块指针</span></span><br><span class="line">    <span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;   <span class="comment">// NDIRECT: Number of block pointers in a File descriptor</span></span><br><span class="line">        <span class="comment">// but note that *ppdiskbno might equal 0</span></span><br><span class="line">        <span class="keyword">if</span>(ppdiskbno)</span><br><span class="line">            *ppdiskbno = &amp;(f-&gt;f_direct[filebno]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filebno &gt;= NDIRECT + NINDIRECT)  <span class="comment">// NINDIRECT: Number of direct block pointers in an indirect block</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件还没分配</span></span><br><span class="line">    filebno -= NDIRECT;</span><br><span class="line">    <span class="keyword">if</span> (!!f-&gt;f_indirect) &#123;  <span class="comment">// !!把非0转换为1，而0还是0</span></span><br><span class="line">        <span class="keyword">if</span> (alloc == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">        <span class="comment">// 分配一个 indirect block</span></span><br><span class="line">        <span class="keyword">uint32_t</span> blockno;</span><br><span class="line">        <span class="keyword">if</span> ( (blockno = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> blockno;</span><br><span class="line">        <span class="comment">// f_indirect 直接记录块号，而不是记地址</span></span><br><span class="line">        <span class="comment">// f-&gt;f_indirect = (uint32_t)diskaddr(blockno);</span></span><br><span class="line">        f-&gt;f_indirect = blockno;</span><br><span class="line">        <span class="built_in">memset</span>(diskaddr(blockno), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">        flush_block(diskaddr(blockno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ppdiskbno)</span><br><span class="line">        *ppdiskbno = (<span class="keyword">uint32_t</span> *)diskaddr(f-&gt;f_indirect) + filebno;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set *blk to the address in memory where the filebno&#x27;th</span></span><br><span class="line"><span class="comment">// block of file &#x27;f&#x27; would be mapped.</span></span><br><span class="line"><span class="comment">// 将*blk设置为文件&#x27;f&#x27;的第filebno块在内存中的映射地址。</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">// -E_NO_DISK if a block needed to be allocated but the disk is full.</span></span><br><span class="line"><span class="comment">// -E_INVAL if filebno is out of range.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: Use file_block_walk and alloc_block.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">file_get_block</span><span class="params">(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">char</span> **blk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *pdiskbno;  <span class="comment">// 块的块号指针</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ( (r = file_block_walk(f, filebno, &amp;pdiskbno, <span class="number">1</span>))&lt; <span class="number">0</span>)  <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> r;  <span class="comment">// 找到文件第filebno块的位置pdiskbno</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*pdiskbno == <span class="number">0</span>) &#123;  <span class="comment">// 这个位置还没分配</span></span><br><span class="line">        <span class="comment">// 文件块还未分配</span></span><br><span class="line">        <span class="keyword">if</span> ( (r = alloc_block()) &lt; <span class="number">0</span>)   <span class="comment">// alloc_block 在位图中搜索一个空闲块并分配它。当您分配一个块时，立即将更改的位图块刷新到磁盘。</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        *pdiskbno = r;</span><br><span class="line">        <span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">        flush_block(diskaddr(r));  <span class="comment">// wb</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终指向块</span></span><br><span class="line">    *blk = diskaddr(*pdiskbno);  <span class="comment">// // Return the virtual address of this disk block.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// panic(&quot;file_get_block not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h3><p>由于其他环境无法直接调用文件系统环境中的函数，因此我们将通过 RPC 或在JOS的IPC机制上构建的RPC抽象来公开对文件系统环境的访问。 </p>
<p>RPC(Remote Procedure Call)。它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib/fd.c)  |   |   (fs/fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +-------------------+</span><br></pre></td></tr></table></figure>

<p>本质上RPC还是借助IPC机制实现的，普通进程通过IPC向FS进程间发送具体操作和操作数据，然后FS进程执行文件操作，最后又将结果通过IPC返回给普通进程。从上图中可以看到客户端的代码在lib/fd.c和lib/file.c两个文件中。服务端的代码在fs/fs.c和fs/serv.c两个文件中。<br>相关数据结构之间的关系可用下图来表示：</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/lab5_7_open()%E5%8E%9F%E7%90%86.png" alt="lab5_7_open原理.png"></p>
<p>文件系统服务端代码在fs/serv.c中，serve()中有一个无限循环，接收IPC请求，将对应的请求分配到对应的处理函数，然后将结果通过IPC发送回去。<br>对于客户端来说：发送一个32位的值作为请求类型，发送一个Fsipc结构作为请求参数，该数据结构通过IPC的页共享发给FS进程，在FS进程可以通过访问fsreq(0x0ffff000)来访问客户进程发来的Fsipc结构。<br>对于服务端来说：FS进程返回一个32位的值作为返回码，对于FSREQ_READ和FSREQ_STAT这两种请求类型，还额外通过IPC返回一些数据。</p>
<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p>Implement <code>serve_read</code> in <code>fs/serv.c.</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">serve_read</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc)</span>  <span class="comment">// 从指定文件中读取出内容，返回给调用者</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> =</span> &amp;ipc-&gt;read;  <span class="comment">// 指定文件</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> =</span> &amp;ipc-&gt;readRet;  <span class="comment">// 调用者</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (debug)</span><br><span class="line">      cprintf(<span class="string">&quot;serve_read %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Lab 5: Your code here:</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">openFile</span>* <span class="title">opf</span>;</span></span><br><span class="line">    <span class="keyword">if</span>((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;opf))&lt;<span class="number">0</span>)&#123;  <span class="comment">// Look up an open file for envid.</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((r = file_read(opf-&gt;o_file, ret-&gt;ret_buf, req-&gt;req_n, opf-&gt;o_fd-&gt;fd_offset))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    of-&gt;o_fd-&gt;fd_offset +=r;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><p>Implement <code>serve_write</code> in <code>fs/serv.c</code> and <code>devfile_write</code> in <code>lib/file.c</code>.</p>
<p><strong>serve_write</strong>: 在<code>file_write</code>中考虑了块边界的问题<code>bn = MIN(BLKSIZE - pos % BLKSIZE, offset + count - pos);</code>，因此我们同样不需要对 req_n 进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">serve_write</span><span class="params">(<span class="keyword">envid_t</span> envid, struct Fsreq_write *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">&quot;serve_write %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">of</span>;</span></span><br><span class="line">    <span class="keyword">int</span> reqn;</span><br><span class="line">    <span class="keyword">if</span> ( (r = openfile_lookup(envid, req-&gt;req_fileid, &amp;of)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    reqn = req-&gt;req_n &gt; PGSIZE? PGSIZE:req-&gt;req_n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( (r = file_write(of-&gt;o_file, req-&gt;req_buf, reqn, of-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    of-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>devfile_write</strong>:  <code>devfile_write</code>需要调用<code>fsipc</code>，其向文件服务器发送一个进程间请求，并等待回复。请求体保存在<code>fsipcbuf</code>中，回复部分也应该写回到 <code>fsipcbuf</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">devfile_write</span><span class="params">(struct Fd *fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 5: Your code here</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ( n &gt; <span class="keyword">sizeof</span> (fsipcbuf.write.req_buf)) </span><br><span class="line">        n = <span class="keyword">sizeof</span> (fsipcbuf.write.req_buf);</span><br><span class="line">    </span><br><span class="line">    fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">    fsipcbuf.write.req_n = n;</span><br><span class="line">    memmove(fsipcbuf.write.req_buf, buf, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  fsipc(FSREQ_WRITE, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spawning-Processes"><a href="#Spawning-Processes" class="headerlink" title="Spawning Processes"></a>Spawning Processes</h2><p><code>slib/spawn.c中的spawn()创建一个新的进程，从文件系统加载用户程序，然后启动该进程来运行这个程序。spawn()就像UNIX中的fork()后面马上跟着exec()。 </code>spawn(const char *prog, const char **argv)`做如下一系列动作：</p>
<ol>
<li>从文件系统打开prog程序文件</li>
<li>调用系统调用sys_exofork()创建一个新的Env结构</li>
<li>调用系统调用sys_env_set_trapframe()，设置新的Env结构的Trapframe字段（该字段包含寄存器信息）。</li>
<li>根据ELF文件中program herder，将用户程序以Segment读入内存，并映射到指定的线性地址处。</li>
<li>调用系统调用sys_env_set_status()设置新的Env结构状态为ENV_RUNNABLE。</li>
</ol>
<p>我们实现了<code>spawn</code>而不是UNIX风格的<code>exec</code>，因为在没有内核特殊帮助的情况下，<code>spawn</code>更容易以“exokernel fashion”从用户空间实现。</p>
<h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><p>spawn C依赖新的系统调用sys_env_set_trapframe来初始化新创建的环境的状态。 在kern/syscall.c中实现sys_env_set_trapframe(不要忘记在sycall()中调度新的系统调用)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set envid&#x27;s trap frame to &#x27;tf&#x27;.</span></span><br><span class="line"><span class="comment">// tf is modified to make sure that user environments always run at code</span></span><br><span class="line"><span class="comment">// protection level 3 (CPL 3), interrupts enabled, and IOPL of 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">// -E_BAD_ENV if environment envid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//    or the caller doesn&#x27;t have permission to change envid.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_env_set_trapframe</span><span class="params">(<span class="keyword">envid_t</span> envid, struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">   <span class="comment">// Remember to check whether the user has supplied us with a good</span></span><br><span class="line">   <span class="comment">// address!</span></span><br><span class="line">   <span class="comment">// panic(&quot;sys_env_set_trapframe not implemented&quot;);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ( (r = envid2env(envid, &amp;env, <span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 什么时候会出现没有权限访问的问题？</span></span><br><span class="line">    user_mem_assert(env, tf, <span class="keyword">sizeof</span>(struct Trapframe), PTE_U);</span><br><span class="line">    <span class="comment">// 直接整个结构体也是可以赋值的</span></span><br><span class="line">    env-&gt;env_tf = *tf;</span><br><span class="line">    env-&gt;env_tf.tf_cs |= <span class="number">0x3</span>;</span><br><span class="line">    env-&gt;env_tf.tf_eflags &amp;=  (~FL_IOPL_MASK);</span><br><span class="line">    env-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h3><p>在fork和spawn之间共享library的状态</p>
<p>在JOS中，每个设备类型都具有相应的<code>struct Dev</code>，其中包含指向实现读/写/等的函数指针。对于该设备类型。 <code>lib / fd.c</code>在此基础上实现了类似UNIX的通用文件描述符接口。 每个结构体Fd表示它的设备类型，<code>lib/fd.c</code>中的大多数函数只是将操作分派给适当的<code>struct Dev</code>中的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-device-class file descriptor operations</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dev_id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_name;</span><br><span class="line">    <span class="keyword">ssize_t</span> (*dev_read)(struct Fd *fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*dev_write)(struct Fd *fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*dev_close)(struct Fd *fd);</span><br><span class="line">    <span class="keyword">int</span> (*dev_stat)(struct Fd *fd, struct Stat *stat);</span><br><span class="line">    <span class="keyword">int</span> (*dev_trunc)(struct Fd *fd, <span class="keyword">off_t</span> length);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>UNIX文件描述符是一个大的概念，包含pipe，控制台I/O。在JOS中每种设备对应一个struct Dev结构，该结构包含函数指针，指向真正实现读写操作的函数。<br>lib/fd.c文件实现了UNIX文件描述符接口，但大部分函数都是简单对struct Dev结构指向的函数的包装。</p>
<p>我们希望共享文件描述符，JOS中定义PTE新的标志位PTE_SHARE，如果有个页表条目的PTE_SHARE标志位为1，那么这个PTE在fork()和spawn()中将被直接拷贝到子进程页表，从而让父进程和子进程共享相同的页映射关系，从而达到父子进程共享文件描述符的目的。</p>
<h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><p>修改lib/fork.c中的duppage()，使之正确处理有PTE_SHARE标志的页表条目。同时实现lib/spawn.c中的copy_shared_pages()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">void</span> *addr = (<span class="keyword">void</span>*) (pn * PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> (uvpt[pn] &amp; PTE_SHARE) &#123;</span><br><span class="line">        sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_SYSCALL);        <span class="comment">//对于标识为PTE_SHARE的页，拷贝映射关系，并且两个进程都有读写权限</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) &#123; <span class="comment">//对于UTOP以下的可写的或者写时拷贝的页，拷贝映射关系的同时，需要同时标记当前进程和子进程的页表项为PTE_COW</span></span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_U|PTE_P);    <span class="comment">//对于只读的页，只需要拷贝映射关系即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy the mappings for shared pages into the child address space.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copy_shared_pages</span><span class="params">(<span class="keyword">envid_t</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> addr;</span><br><span class="line">    <span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; UTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">            (uvpt[PGNUM(addr)] &amp; PTE_U) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_SHARE)) &#123;</span><br><span class="line">            sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span>*)addr, child, (<span class="keyword">void</span>*)addr, (uvpt[PGNUM(addr)] &amp; PTE_SYSCALL));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="The-keyboard-interface"><a href="#The-keyboard-interface" class="headerlink" title="The keyboard interface"></a>The keyboard interface</h2><p>目前我们只能在内核监视器中才能接收输入。<code>kern/console.c</code> already contains the keyboard and serial drivers that have been used by the kernel monitor since lab 1, but now you need to attach these to the rest of the system.</p>
<p><code>kern/console.c</code> 已经包含了从实验1开始内核监视器就在使用的键盘和串行驱动程序，但是现在您需要将它们附加到系统的其他部分。</p>
<p>在<code>/kern/console.c/cons_getc()</code>中的代码，实现了在 monitor 模式下（禁止中断）可以正常获取用户输入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poll for any pending input characters,</span></span><br><span class="line">    <span class="comment">// so that this function works even when interrupts are disabled</span></span><br><span class="line">    <span class="comment">// (e.g., when called from the kernel monitor).</span></span><br><span class="line">    serial_intr();</span><br><span class="line">    kbd_intr();</span><br></pre></td></tr></table></figure>

<p>在 trap.c 中加入中断处理函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (IRQ_OFFSET + IRQ_KBD):</span><br><span class="line">    lapic_eoi();</span><br><span class="line">    kbd_intr();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> (IRQ_OFFSET + IRQ_SERIAL):</span><br><span class="line">    lapic_eoi();</span><br><span class="line">    serial_intr();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<h2 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Lab5 主要介绍了文件系统的基本组成，为超级块分配易查找的位置，并在超级块中记录根目录文件，此后递进存储即实现了FS的多级目录。利用虚拟地址和MMIO实现了类似统一编址方式，我们可以很方便实现文件访问，其操作过程与内存访问很类似（在文件结构体中 walk 到块号）。</p>
<p>JOS在用户环境实现FS，FS接口是这个Lab的重点。其通过RPC公开接口，在JOS中利用IPC机制构建RPC抽象。regular env-&gt;read-&gt;ipc_send -&gt; ipc_recv-&gt;serve-&gt;file_read。<br>这实际上以微内核的方式实现的FS，FS的<code>serv</code>相当于一种微服务进程，其接收、解析内核转发的信息再执行相应的操作。消息通过一个页映射的<code>Union Fsipc</code>进行传递。</p>
<p><code>spawn</code>函数表现得像在Unix下创建子进程带有一个立刻执行<code>exec</code>的<code>fork</code>函数。exec()会把当前执行进程覆盖掉来执行外部程序，spawn()则会创建一个新的进程来执行。<strong>对于spawn的设计，还是有一些困惑，因为不明白 Unix-Style的exec是如何实现的，所以不能理解为什么spawn更容易在用户空间实现。</strong> </p>
<p>最后的Keyboard 接口和Shell都相对简单，比较容易理解。</p>
<ol>
<li>其他环境无法直接调用文件系统环境中的函数，要通过IPC，进程间消息传递实现。这里应该就是微内核的概念了。但为什么不能直接调用，是怎么实现不能直接调用的？是特意不让别的环境直接使用其函数吗？有没有方法可以实现不同用户程序可以直接调用其他用户程序的函数？</li>
</ol>
<p>不能直接调用，应该是因为每个用户态的代码都存在于自身的地址空间中，其他用户程序无法访问到。但是我如果在源代码中的某个环境直接#include并且调用另一个环境文件夹下的代码（例如fs），即在编译前就调用了，这会出现什么情况？这样就相当于是宏内核的概念了吗？ 或者是这样设计会增大代码的耦合性？这让我十分疑惑。毕竟这与越过系统调用不一样，系统调用有权限限制。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6-828/" rel="tag"># 操作系统,6.828</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/04/6-828Lab4/" rel="prev" title="6-828Lab4">
                  <i class="fa fa-chevron-left"></i> 6-828Lab4
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/08/6-828Lab6/" rel="next" title="6-828Lab6">
                  6-828Lab6 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
