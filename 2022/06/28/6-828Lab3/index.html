<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="LAB3: User Environments实验三中，you will implement the basic kernel facilities required to get a protected user-mode environment (i.e., “process”) running. 将实现运行受保护的用户模式环境（即进程）所需的基本内核功能。将增强JOS内核以设置数据结构来跟踪">
<meta property="og:type" content="article">
<meta property="og:title" content="6.828Lab3">
<meta property="og:url" content="http://example.com/2022/06/28/6-828Lab3/index.html">
<meta property="og:site_name" content="我的一些记录">
<meta property="og:description" content="LAB3: User Environments实验三中，you will implement the basic kernel facilities required to get a protected user-mode environment (i.e., “process”) running. 将实现运行受保护的用户模式环境（即进程）所需的基本内核功能。将增强JOS内核以设置数据结构来跟踪">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220629161158698.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220701172502082.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220703163747621.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220703163920093.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220703165253213.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704103409165.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704144047847.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704154830887.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704163653390.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704163812230.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704163804732.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704172003993.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704223729337.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704213103991.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704220321417.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704221209942.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704221230450.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704221854670.png">
<meta property="og:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704223813288.png">
<meta property="article:published_time" content="2022-06-28T14:15:45.000Z">
<meta property="article:modified_time" content="2022-07-08T06:33:47.988Z">
<meta property="article:tag" content="操作系统，6.828">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220629161158698.png">


<link rel="canonical" href="http://example.com/2022/06/28/6-828Lab3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/06/28/6-828Lab3/","path":"2022/06/28/6-828Lab3/","title":"6.828Lab3"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>6.828Lab3 | 我的一些记录</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">我的一些记录</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LAB3-User-Environments"><span class="nav-number">1.</span> <span class="nav-text">LAB3: User Environments</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-A-User-Environment-and-Expection-Handling"><span class="nav-number">2.</span> <span class="nav-text">Part A: User Environment and Expection Handling</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-1-Allocating-the-Environments-Array"><span class="nav-number">2.1.</span> <span class="nav-text">Exercise 1: Allocating the Environments Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-2-Creating-and-Running-Environments"><span class="nav-number">2.2.</span> <span class="nav-text">Exercise 2: Creating and Running Environments</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-3-Handling-Interrupts-and-Exceptions"><span class="nav-number">2.3.</span> <span class="nav-text">Exercise 3: Handling Interrupts and Exceptions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-4"><span class="nav-number">2.4.</span> <span class="nav-text">Exercise 4.</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><span class="nav-number">3.</span> <span class="nav-text">Part B: Page Faults, Breakpoints Exceptions, and System Calls</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise5-Handling-Page-Faults"><span class="nav-number">3.1.</span> <span class="nav-text">Exercise5: Handling Page Faults</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-6-The-Breakpoint-Exception"><span class="nav-number">3.2.</span> <span class="nav-text">Exercise 6: The Breakpoint Exception</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-7-System-calls"><span class="nav-number">3.3.</span> <span class="nav-text">Exercise 7: System calls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-8-User-mode-startup"><span class="nav-number">3.4.</span> <span class="nav-text">Exercise 8: User-mode startup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercise-9-Page-faults-and-memory-protection"><span class="nav-number">3.5.</span> <span class="nav-text">Exercise 9: Page faults and memory protection</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/28/6-828Lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          6.828Lab3
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-28 22:15:45" itemprop="dateCreated datePublished" datetime="2022-06-28T22:15:45+08:00">2022-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-08 14:33:47" itemprop="dateModified" datetime="2022-07-08T14:33:47+08:00">2022-07-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="LAB3-User-Environments"><a href="#LAB3-User-Environments" class="headerlink" title="LAB3: User Environments"></a>LAB3: User Environments</h1><p>实验三中，you will implement the basic kernel facilities required to get a protected user-mode environment (i.e., “process”) running. 将实现运行受保护的<strong>用户模式环境（即进程）</strong>所需的基本内核功能。将增强JOS内核以设置数据结构来跟踪 用户环境、创建单个用户环境、将程序映像（program image）加载到其中并开始运行。还需要使得JOS内核能够处理用户环境进行的任何调用和解决它所造成的一切异常情况。</p>
<p> <strong>killall XXX杀掉所有的进程 kill xxx(PID)杀死进程号xxx的进程,查看所有运行进程的命令:ps -aux</strong></p>
<h1 id="Part-A-User-Environment-and-Expection-Handling"><a href="#Part-A-User-Environment-and-Expection-Handling" class="headerlink" title="Part A: User Environment and Expection Handling"></a>Part A: User Environment and Expection Handling</h1><p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220629161158698.png" alt="image-20220629161158698"></p>
<p>inc/env.h 查看最大进程个数NENV为1024</p>
<p>kern/env.c 全局变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env指针指向一个由Env结构体组成的数组，同时，不活动的Env记录在env_free_list 中, 和之前的page_free_list很像</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> =</span> <span class="literal">NULL</span>;      <span class="comment">// All environments</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> =</span> <span class="literal">NULL</span>;    <span class="comment">// The current env    curenv记录着现在正在运行的进程，在第一个进程运行之前为空</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>  <span class="comment">// Free environment list</span></span><br><span class="line">               <span class="comment">// (linked by Env-&gt;env_link)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENVGENSHIFT    12    <span class="comment">// &gt;= LOGNENV</span></span></span><br></pre></td></tr></table></figure>

<p>inc/enc.h 中查看Env结构体的具体信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>   <span class="comment">// Saved registers </span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>     <span class="comment">// Next free Env</span></span><br><span class="line">   <span class="keyword">envid_t</span> env_id;          <span class="comment">// Unique environment identifier</span></span><br><span class="line">   <span class="keyword">envid_t</span> env_parent_id;    <span class="comment">// env_id of this env&#x27;s parent</span></span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span>    <span class="comment">// Indicates special system environments</span></span><br><span class="line">   <span class="keyword">unsigned</span> env_status;      <span class="comment">// Status of the environment</span></span><br><span class="line">   <span class="keyword">uint32_t</span> env_runs;    <span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Address space</span></span><br><span class="line">   <span class="keyword">pde_t</span> *env_pgdir;     <span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>env_id  进程的身份标识。</p>
<p>env_status 进程的运行状态。</p>
<p>env_link 类似于PageInfo中的pp_link，用于创建空闲进程链表，若进程槽已分配，则置为NULL。</p>
<p>env_tf 是一个Trapframe型的结构体（Trapframe是指中断、自陷、异常进入内核后，在堆栈上形成的一种数据结构），用于登记进程运行时的寄存器信息。</p>
<p>env_pgdir 指向进程运行所用的页目录，即描述了进程的用户地址空间。</p>
<p><em><strong>在JOS中，进程的运行实体是线程，而env_tf描述的实际上是所说的之行线程。文档中说明：当进程不在运行状态时，env_tf保存了进程的寄存器信息，内核在硬件控制权由用户转到内核时保存这些信息，使得进程可以在之后恢复到它交出控制权时的状态。</strong></em></p>
<h2 id="Exercise-1-Allocating-the-Environments-Array"><a href="#Exercise-1-Allocating-the-Environments-Array" class="headerlink" title="Exercise 1: Allocating the Environments Array"></a>Exercise 1: Allocating the Environments Array</h2><p>修改 kern/pmap.c 中的 mem_init() 来分配和映射 envs 数组。这个数组完全由 ENEV(1024) 个结构体Env组成，与分配 pages 数组的方式非常相似。同时像 pages 数组一样， 在UENVS(定义在inc/memlayout.h)上的用户，内存也该被映射为只读，这样用户进程就可以从这个数组中读取数据。</p>
<p><strong>You should run your code and make sure <code>check_kern_pgdir()</code> succeeds.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">mem_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> cr0;</span><br><span class="line">   <span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span></span><br><span class="line">   i386_detect_memory();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Remove this line when you&#x27;re ready to test this function.</span></span><br><span class="line">   <span class="comment">//panic(&quot;mem_init: This function is not finished\n&quot;);</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// create initial page directory.</span></span><br><span class="line">   kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">   <span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Recursively insert PD in itself as a page table, to form</span></span><br><span class="line">   <span class="comment">// a virtual page table at virtual address UVPT.</span></span><br><span class="line">   <span class="comment">// (For now, you don&#x27;t have understand the greater purpose of the</span></span><br><span class="line">   <span class="comment">// following line.)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">   kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span></span><br><span class="line">   <span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line">   <span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line">   <span class="comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span></span><br><span class="line">   <span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line">   <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Make &#x27;envs&#x27; point to an array of size &#x27;NENV&#x27; of &#x27;struct Env&#x27;.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Now that we&#x27;ve allocated the initial kernel data structures, we set</span></span><br><span class="line">   <span class="comment">// up the list of free physical pages. Once we&#x27;ve done so, all further</span></span><br><span class="line">   <span class="comment">// memory management will go through the page_* functions. In</span></span><br><span class="line">   <span class="comment">// particular, we can now map memory using boot_map_region</span></span><br><span class="line">   <span class="comment">// or page_insert</span></span><br><span class="line">   page_init();</span><br><span class="line"></span><br><span class="line">   check_page_free_list(<span class="number">1</span>);</span><br><span class="line">   check_page_alloc();</span><br><span class="line">   check_page();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line">   <span class="comment">// Permissions:</span></span><br><span class="line">   <span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line">   <span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">   <span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line">   <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Map the &#x27;envs&#x27; array read-only by the user at linear address UENVS</span></span><br><span class="line">   <span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line">   <span class="comment">// Permissions:</span></span><br><span class="line">   <span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line">   <span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line">   <span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line">   <span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">   <span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line">   <span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line">   <span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line">   <span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line">   <span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line">   <span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">   <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line">   <span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line">   <span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line">   <span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line">   <span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line">   <span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line">   <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check that the initial page directory has been set up correctly.</span></span><br><span class="line">   check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Switch from the minimal entry page directory to the full kern_pgdir</span></span><br><span class="line">   <span class="comment">// page table we just created. Our instruction pointer should be</span></span><br><span class="line">   <span class="comment">// somewhere between KERNBASE and KERNBASE+4MB right now, which is</span></span><br><span class="line">   <span class="comment">// mapped the same way by both page tables.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// If the machine reboots at this point, you&#x27;ve probably set up your</span></span><br><span class="line">   <span class="comment">// kern_pgdir wrong.</span></span><br><span class="line">   lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">   check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// entry.S set the really important flags in cr0 (including enabling</span></span><br><span class="line">   <span class="comment">// paging).  Here we configure the rest of the flags that we care about.</span></span><br><span class="line">   cr0 = rcr0();</span><br><span class="line">   cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;</span><br><span class="line">   cr0 &amp;= ~(CR0_TS|CR0_EM);</span><br><span class="line">   lcr0(cr0);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Some more checks, only possible after kern_pgdir is installed.</span></span><br><span class="line">   check_page_installed_pgdir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span></span><br><span class="line">    i386_detect_memory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove this line when you&#x27;re ready to test this function.</span></span><br><span class="line">    <span class="comment">// panic(&quot;mem_init: This function is not finished\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// create initial page directory.</span></span><br><span class="line">    kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">    <span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Recursively insert PD in itself as a page table, to form</span></span><br><span class="line">    <span class="comment">// a virtual page table at virtual address UVPT.</span></span><br><span class="line">    <span class="comment">// (For now, you don&#x27;t have understand the greater purpose of the</span></span><br><span class="line">    <span class="comment">// following line.)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span></span><br><span class="line">    <span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line">    <span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line">    <span class="comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span></span><br><span class="line">    <span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// 创建一个struct PageInfo 的数组</span></span><br><span class="line">    <span class="comment">// kernel 使用这个数组来耿总每个物理页</span></span><br><span class="line">    <span class="comment">// 对于每一个物理页，都会有一个对应的 struct PageInfo 在数组中</span></span><br><span class="line">    pages = (struct PageInfo *) boot_alloc(npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line">    <span class="comment">// npages 是内存中物理页的数量</span></span><br><span class="line">    <span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Now that we&#x27;ve allocated the initial kernel data structures, we set</span></span><br><span class="line">    <span class="comment">// up the list of free physical pages. Once we&#x27;ve done so, all further</span></span><br><span class="line">    <span class="comment">// memory management will go through the page_* functions. In</span></span><br><span class="line">    <span class="comment">// particular, we can now map memory using boot_map_region</span></span><br><span class="line">    <span class="comment">// or page_insert</span></span><br><span class="line">    page_init();</span><br><span class="line"></span><br><span class="line">    check_page_free_list(<span class="number">1</span>);</span><br><span class="line">    check_page_alloc();</span><br><span class="line">    check_page();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line">    <span class="comment">// Permissions:</span></span><br><span class="line">    <span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line">    <span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">    <span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// UPAGES是JOS记录物理页面使用情况的数据结构，只有kernel能够访问</span></span><br><span class="line">    <span class="comment">// 为了使用户空间能访问这块数据结构，会将PAGES映射到UPAGES的位置</span></span><br><span class="line">    <span class="comment">// 但是现在需要让用户空间能够读取这段线性地址，因此需要建立映射，将用户空间的一块内存映射到存储该数据结构的物理地址上</span></span><br><span class="line">    <span class="comment">// boot_map_region() 建立映射关系</span></span><br><span class="line">    boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)UPAGES, npages*<span class="keyword">sizeof</span>(struct PageInfo), PADDR(pages), PTE_U | PTE_P);</span><br><span class="line">    <span class="comment">// 目前建立了一个页目录，kernel_pgdir</span></span><br><span class="line">    <span class="comment">// pgdir为页目录指针， UPAGES为虚拟地址，npages*sizeof(struct* PageInfo)为映射的内存块大小</span></span><br><span class="line">    <span class="comment">// PADDR(pages) 为物理地址， PTE_U | PTE为权限 (PTE_U 表示用户可读)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line">    <span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line">    <span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">    <span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line">    <span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line">    <span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line">    <span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line">    <span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line">    <span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// kernel  内核栈</span></span><br><span class="line">    <span class="comment">// kernel stack 从虚拟地址 KSTACKTOP 开始，向低地址增长，所以KSTACKTOP实际上是栈顶</span></span><br><span class="line">    <span class="comment">// KSTACKTOP = 0xf0000000，</span></span><br><span class="line">    <span class="comment">// KSTKSIZE = (8*PGSIZE) = 8*4096(bytes) = 32KB</span></span><br><span class="line">    <span class="comment">// 只需要映射 [KSTACKTOP, KSTACKTOP - KSTKSIZE) 范围的虚拟地址</span></span><br><span class="line">    boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)(KSTACKTOP - KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);</span><br><span class="line">    <span class="comment">// PTE_W 开启了写权限，但是并未打开 PTE_U， 因此用户没有权限，只有内核有权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line">    <span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line">    <span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line">    <span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line">    <span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line">    <span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// 内核部分</span></span><br><span class="line">    <span class="comment">// KERNBASE    = 0xF0000000， VA大小为 2^32 - KERNBASE</span></span><br><span class="line">    <span class="comment">// ROUNDUP(a,n) 将a四舍五入到最接近n的倍数</span></span><br><span class="line">    boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)KERNBASE, ROUNDUP(<span class="number">0xffffffff</span> - KERNBASE + <span class="number">1</span>, PGSIZE), <span class="number">0</span>, PTE_W | PTE_P);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the initial page directory has been set up correctly.</span></span><br><span class="line">    check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch from the minimal entry page directory to the full kern_pgdir</span></span><br><span class="line">    <span class="comment">// page table we just created. Our instruction pointer should be</span></span><br><span class="line">    <span class="comment">// somewhere between KERNBASE and KERNBASE+4MB right now, which is</span></span><br><span class="line">    <span class="comment">// mapped the same way by both page tables.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the machine reboots at this point, you&#x27;ve probably set up your</span></span><br><span class="line">    <span class="comment">// kern_pgdir wrong.</span></span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">    check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// entry.S set the really important flags in cr0 (including enabling</span></span><br><span class="line">    <span class="comment">// paging).  Here we configure the rest of the flags that we care about.</span></span><br><span class="line">    cr0 = rcr0();</span><br><span class="line">    cr0 |= CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_MP;</span><br><span class="line">    cr0 &amp;= ~(CR0_TS | CR0_EM);</span><br><span class="line">    lcr0(cr0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some more checks, only possible after kern_pgdir is installed.</span></span><br><span class="line">    check_page_installed_pgdir();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="Exercise-2-Creating-and-Running-Environments"><a href="#Exercise-2-Creating-and-Running-Environments" class="headerlink" title="Exercise 2: Creating and Running Environments"></a>Exercise 2: Creating and Running Environments</h2><p>You will now write the code in <code>kern/env.c</code> necessary to run a user environment. Because we do not yet have a filesystem, we will set up the kernel to load a static binary image that is <em>embedded within the kernel itself</em>. <strong>JOS embeds this binary in the kernel as a ELF executable image.</strong></p>
<p>In <code>i386_init()</code> in <code>kern/init.c</code> you’ll see code to run one of these binary images in an environment. However, the critical functions to set up user environments are not complete; you will need to fill them in.</p>
<p><strong>在kern/env.c中，补充完成以下函数</strong></p>
<p><strong>env_init()</strong></p>
<p>​    初始化 envs 数组中所有的结构体 Env，并把它们添加到env_free_list。</p>
<p>​    调用 env_init_percpu，它为 privilege level 0(kernel)  和  privilege level 3(user) 配置特定的段。</p>
<p><strong>env_steup_vm()</strong></p>
<p>​    为新环境分配一个页目录，并且初始化新环境地址空间的内核部分。</p>
<p><strong>region_alloc()</strong></p>
<p>​    为环境分配和映射物理内存。</p>
<p><strong>load_icode()</strong></p>
<p>​    您需要解析ELF二进制映像，就像引导加载程序已经做的那样，并将其内容加载到新环境的用户地址空间中。</p>
<p><strong>env_create()</strong></p>
<p>​    使用env_alloc分配一个环境，并调用load_icode将ELF二进制文件加载到其中。</p>
<p><strong>env_run()</strong></p>
<p>​    启动以用户模式运行的给定环境。</p>
<p>As you write these functions, you might find the new cprintf verb <code>%e</code> useful – it prints a description corresponding to an error code. For example,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = -E_NO_MEM;</span><br><span class="line">panic(&quot;env_alloc: %e&quot;, r);</span><br></pre></td></tr></table></figure>

<p>will panic with the message “env_alloc: out of memory”.</p>
<p>Below is a call graph of the code up to the point where the user code is invoked. Make sure you understand the purpose of each step.</p>
<ul>
<li>start (kern/entry.S)</li>
<li>i386_init (kern/init.c)<ul>
<li>cons_init</li>
<li>mem_initenv_init</li>
<li>trap_init (still incomplete at this point)</li>
<li>env_create</li>
<li>env_run<ul>
<li>env_pop_tf</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>boot.S中通过ljmp跳转指令使cs的索引值指向代码段描述符，并将选择子ds、es、fs、gs和ss的索引值均设置为指向数据段描述符，至此这些段选择子均不曾被更改过。现在我们要创建进程，而原先的GDT中并没有特权级为3的数据段和代码段描述符，所以我们必须加载一个新的GDT。env_init_percpu重新加载了GDT，并设置了各个段选择子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">truct Segdesc gdt[] =</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 0x0 - unused (always faults -- for trapping NULL far pointers)</span></span><br><span class="line">   SEG_NULL,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x8 - kernel code segment</span></span><br><span class="line">   [GD_KT &gt;&gt; <span class="number">3</span>] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x10 - kernel data segment</span></span><br><span class="line">   [GD_KD &gt;&gt; <span class="number">3</span>] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x18 - user code segment</span></span><br><span class="line">   [GD_UT &gt;&gt; <span class="number">3</span>] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>, <span class="number">3</span>),</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x20 - user data segment</span></span><br><span class="line">   [GD_UD &gt;&gt; <span class="number">3</span>] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>, <span class="number">3</span>),</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x28 - tss, initialized in trap_init_percpu()</span></span><br><span class="line">   [GD_TSS0 &gt;&gt; <span class="number">3</span>] = SEG_NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pseudodesc</span> <span class="title">gdt_pd</span> =</span> &#123;</span><br><span class="line">   <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) gdt</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220701172502082.png" alt="image-20220701172502082"></p>
<p><strong>env_init()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up envs array</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// 初始化 envs 数组中所有的结构体 Env，添加到env_free_list</span></span><br><span class="line">    <span class="keyword">int</span> i = NENV;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        i--;</span><br><span class="line">        envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">        envs[i].env_link = env_free_list;</span><br><span class="line">        env_free_list = &amp;envs[i];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();  <span class="comment">// 重新加载</span></span><br></pre></td></tr></table></figure>

<p><strong>env_steup_vm()</strong></p>
<p>为新环境分配一个页目录，并且初始化新环境地址空间的内核部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">env_setup_vm</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))  <span class="comment">// 给p分配个 页目录</span></span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//    - The VA space of all envs is identical above UTOP</span></span><br><span class="line">	<span class="comment">//	(except at UVPT, which we&#x27;ve set below).</span></span><br><span class="line">	<span class="comment">//	See inc/memlayout.h for permissions and layout.</span></span><br><span class="line">	<span class="comment">//	Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line">	<span class="comment">//	(Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line">	<span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line">	<span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line">	<span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line">	<span class="comment">//	physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line">	<span class="comment">//	is an exception -- you need to increment env_pgdir&#x27;s</span></span><br><span class="line">	<span class="comment">//	pp_ref for env_free to work correctly.</span></span><br><span class="line">	<span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// env_setup_vm负责创建进程自己的页目录，并初始化内核地址空间。</span></span><br><span class="line">    <span class="comment">// 它不需要为内核地址空间另外创建页表，只要先将内核页目录kern_pgdir的所有目录项复制过来即可，以后再设置用户地址空间。</span></span><br><span class="line">    <span class="comment">// // pde_t *env_pgdir;		// Kernel virtual address of page dir</span></span><br><span class="line">    e-&gt;env_pgdir = page2kva(p);</span><br><span class="line">    <span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line">    p-&gt;pp_ref++;  <span class="comment">// p此时指向了页目录</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// UVPT maps the env&#x27;s own page table read-only.</span></span><br><span class="line">	<span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line">    <span class="comment">// PDX()   page directory index   NPDENTRIES	1024</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>region_alloc()</strong></p>
<p>为环境env分配 len 字节的物理内存，并将其映射到环境地址空间中的虚拟地址va。不以任何方式将映射页归零或初始化。页面应该是用户和内核可写的。Panic if any allocation attempt fails.</p>
<p>region_alloc为一个进程分配指定长度的内存空间，并按指定的起始线性地址映射到分配的物理内存上。该函数只在加载用户程序到内存中时（目前通过load_icode）才被用到，分配用户栈的工作将交给load_icode完成。我们会用到lab2中实现的page_alloc和page_insert分别完成物理页的分配与映射。我们不需要对被分配的物理页进行初始化，物理页的权限将被设置为内核和用户都可读写，va和va+len需要设置为页对齐（corner-case应该是当分配的地址超过UTOP时，这里直接panic）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">region_alloc</span><span class="params">(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line">    <span class="comment">//   &#x27;va&#x27; and &#x27;len&#x27; values that are not page-aligned.</span></span><br><span class="line">    <span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line">    <span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> va_start = ROUNDDOWN((<span class="keyword">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">    <span class="keyword">uintptr_t</span> va_end = ROUNDUP((<span class="keyword">uintptr_t</span>)va + len, PGSIZE);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pginfo</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cur_va = va_start;cur_va&lt;va_end;cur_va+=PGSIZE)&#123;</span><br><span class="line">        pginfo = page_alloc(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!pginfo)&#123;</span><br><span class="line">            panic(<span class="string">&quot;region_alloc: pageinfo failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;insert page at %08x\n.&quot;</span>, cur_va);</span><br><span class="line">        page_insert(e-&gt;env_pgdir, pginfo, (<span class="keyword">void</span>*)cur_va, PTE_U | PTE_W | PTE_P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>load_icode()</strong></p>
<p>由于我们还没有实现文件系统，甚至连磁盘都没有，所以当然不可能从磁盘上加载一个用户程序到内存中。因此，我们暂时将ELF可执行文件嵌入内核，并从内存中加载这样的ELF文件，以此模拟从磁盘加载用户程序的过程。lab3 GNUmakefile负责设置将这样的ELF可执行文件直接嵌入内核</p>
<p><u>Hint:</u></p>
<p>在ELF段头指定的地址处把每个程序段加载到虚拟内存中。</p>
<p>你应该只加载 <code>ph-&gt;p_type == ELF_PROG_LOAD</code> 的段。</p>
<p>每个段的虚拟地址可以使用 <code>ph-&gt;p_va</code> 得到，同时它在内存中的大小可通过<code>ph-&gt;memsz</code>得到。</p>
<p>The <code>ph-&gt;p_filesz</code> bytes from the ELF binary, starting at <code>binary + ph-&gt;p_offset</code>, should be copied to virtual address  <code>ph-&gt;p_va</code>. </p>
<p>ELF头应该有 <code>ph-&gt;p_filesz &lt;= ph-&gt;p_memsz</code>.</p>
<p>所有的页面是用户可读/写的。</p>
<p>ELF段不一定是页面对齐的，但是你可以假设这个函数中没有两个段会接触同一个虚拟页面。</p>
<p>您还必须对程序的入口点做一些操作，以确保环境从那里开始执行。</p>
<p>怎么切换页目录？<br>lcr3([页目录物理地址]) 将地址加载到 cr3 寄存器。</p>
<p>怎么更改函数入口？<br>将 <code>env-&gt;env_tf.tf_eip</code> 设置为 <code>elf-&gt;e_entry</code>，等待之后的 <code>env_pop_tf()</code> 调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">load_icode</span><span class="params">(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//  Load each program segment into virtual memory</span></span><br><span class="line">	<span class="comment">//  at the address specified in the ELF segment header.</span></span><br><span class="line">	<span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></span><br><span class="line">	<span class="comment">//  Each segment&#x27;s virtual address can be found in ph-&gt;p_va</span></span><br><span class="line">	<span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></span><br><span class="line">	<span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></span><br><span class="line">	<span class="comment">//  &#x27;binary + ph-&gt;p_offset&#x27;, should be copied to virtual address</span></span><br><span class="line">	<span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span></span><br><span class="line">	<span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></span><br><span class="line">	<span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  All page protection bits should be user read/write for now.</span></span><br><span class="line">	<span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></span><br><span class="line">	<span class="comment">//  assume for this function that no two segments will touch</span></span><br><span class="line">	<span class="comment">//  the same virtual page.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You may find a function like region_alloc useful.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  Loading the segments is much simpler if you can move data</span></span><br><span class="line">	<span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></span><br><span class="line">	<span class="comment">//  So which page directory should be in force during</span></span><br><span class="line">	<span class="comment">//  this function?</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You must also do something with the program&#x27;s entry point,</span></span><br><span class="line">	<span class="comment">//  to make sure that the environment starts executing there.</span></span><br><span class="line">	<span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf_hdr</span> =</span> (struct Elf *)binary;   <span class="comment">// ELF头// 准备对二进制ELF文件进行操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span>   <span class="comment">// 程序头</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(elf_hdr-&gt;e_magic != ELF_MAGIC)&#123;</span><br><span class="line">        panic(<span class="string">&quot;load_icode: invalid ELF binary.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ph = (struct Proghdr*)(binary + elf_hdr-&gt;e_phoff);  <span class="comment">// 加上偏移量</span></span><br><span class="line">    eph = ph+elf_hdr-&gt;e_phnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换页目录</span></span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));  <span class="comment">// lcr3() to switch to its address space.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;ph&lt;eph;ph++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;  <span class="comment">// 满足ELF的条件</span></span><br><span class="line">            <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">                panic(<span class="string">&quot;load_icode: file size is greater than memory size&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            region_alloc(e, (<span class="keyword">void</span>*)ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)ph-&gt;p_va, binary+ph-&gt;p_offset, ph-&gt;p_filesz);    <span class="comment">// 拷贝文件内容</span></span><br><span class="line">            <span class="built_in">memset</span>((<span class="keyword">void</span>*)ph-&gt;p_va + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;env_tf.tf_eip = elf_hdr-&gt;e_entry; <span class="comment">// 切换入口</span></span><br><span class="line">	<span class="comment">// Now map one page for the program&#x27;s initial stack</span></span><br><span class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line">    <span class="comment">// 现在映射一个页面为程序的初始堆栈在虚拟地址USTACKTOP - PGSIZE.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    region_alloc(e,(<span class="keyword">void</span>*)USTACKTOP - PGSIZE, PGSIZE);</span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>env_create()</strong><br>作用是新建一个进程。调用已经写好的 env_alloc() 函数即可，之后更改类型并且利用 load_icode() 读取 ELF。</p>
<p>这里的进程即环境.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用是新建一个进程。</span></span><br><span class="line"><span class="comment">// 调用已经写好的 env_alloc() 函数即可，之后更改类型并且利用 load_icode() 读取 ELF。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">env_create</span><span class="params">(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span>   <span class="comment">// 新建一个进程</span></span><br><span class="line">    <span class="keyword">int</span> r = env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;env_create: env alloc error.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配成功</span></span><br><span class="line">    e-&gt;env_type = ENV_TYPE_USER;</span><br><span class="line">    load_icode(e, binary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>env_run()</strong></p>
<p>​    启动以用户模式运行的给定环境。</p>
<p>//步骤1:如果这是一个上下文切换(一个新的环境正在运行):</p>
<p>/ / 1。设置当前环境(如果有的话)回ENV_RUNNABLE如果它是ENV_RUNNING(想想它可以处于什么其他状态)，</p>
<p>/ / 2。将’curenv’设置为新环境，</p>
<p>/ / 3。设置它的状态为ENV_RUNNING，更新env_status</p>
<p>/ / 4。更新它的’env_runs’计数器，</p>
<p>/ / 5。使用lcr3()切换到它的地址空间。</p>
<p>//步骤2:使用env_pop_tf()恢复环境的寄存器，并在环境中进入用户模式。</p>
<p>//Hint: 这个函数从<code>e-&gt;env_tf</code>加载新环境的状态。返回前面编写的代码，确保将e-&gt;env_tf的相关部分设置为合理的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">env_run</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Hint: This function loads the new environment&#x27;s state from</span></span><br><span class="line">   <span class="comment">// e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line">   <span class="comment">// and make sure you have set the relevant parts of</span></span><br><span class="line">   <span class="comment">// e-&gt;env_tf to sensible values.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// struct Env *curenv 记录着当前正在运行的进程</span></span><br><span class="line">    <span class="keyword">if</span>(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    curenv = e;</span><br><span class="line">    e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">    e-&gt;env_runs++;</span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// panic(&quot;env_run not yet implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Exercise-3-Handling-Interrupts-and-Exceptions"><a href="#Exercise-3-Handling-Interrupts-and-Exceptions" class="headerlink" title="Exercise 3: Handling Interrupts and Exceptions"></a>Exercise 3: Handling Interrupts and Exceptions</h2><p>用户空间中的第一个<code>int $0x30</code>系统调用指令是一个死胡同:一旦处理器进入用户模式，就没有办法返回。现在需要实现基本的异常和系统调用处理，以便内核能够从用户模式代码中恢复对处理器的控制。您应该做的第一件事是彻底熟悉x86中断和异常机制。</p>
<p>Read <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/c09.htm">Chapter 9, Exceptions and Interrupts</a> in the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm">80386 Programmer’s Manual</a> (or Chapter 5 of the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf">IA-32 Developer’s Manual</a>), if you haven’t already.</p>
<p>根据xv6讲义，一共有三种必须<strong>将控制由用户程序转移到内核</strong>的情形：系统调用、异常和中断。</p>
<p><strong>系统调用</strong>发生在用户程序请求一项操作系统的服务时。</p>
<p><strong>异常</strong>发生在用户程序想要执行某种非法的操作时，如除以零或者访问不存在的页表项。</p>
<p><strong>中断</strong>发生在某个外部设备需要操作系统的留意时，比如时钟芯片会定时产生一个中断提醒操作系统可以将硬件资源切换给下一个进程使用一会儿了。</p>
<p>在大多数处理器上，这三种情形都是由同一种硬件机制来处理的。对于x86，系统调用和异常本质上也是生成一个中断，因此操作系统只需要提供一套针对中断的处理策略就可以了。</p>
<p>操作系统处理中断时要用到<strong>中断描述符表IDT</strong>和<strong>程序状态段TSS</strong></p>
<ol>
<li><strong>中断描述符表IDT (interrupt descriptor table)</strong></li>
</ol>
<p>​        x86最多支持256个不同中断和异常的条目，每个包含一个中断向量，是一个0～255之间的数字，代表中断来源：不同的设备及类型错误。</p>
<p>​        IDT使得系统调用、异常和中断都只能经由被内核定义的入口进入正确的中断处理程序。每一个中断处理程序都对应一个中断向量或中断号，处理器接收中断号后，会以它作为索引值从IDT中找到对应的中断描述符。接着，处理器从描述符中取出定位中断处理程序要用到的 <strong>eip(指令指针寄存器)</strong> 和 <strong>cs(代码段寄存器)</strong> 的值。</p>
<p>EIP中的值指向内核中处理这类异常的代码。 Extend Instruction Pointer</p>
<p>CS中的最低两位表示优先级，因此寻址空间少两位 . </p>
<p>在JOS中，所有异常都在内核模式处理，优先级为0(用户模式为3)</p>
<ol start="2">
<li><strong>任务状态段 (Task State Segment, TSS)</strong></li>
</ol>
<p>​    处理器需要保存中断和异常出现时的自身状态，例如EIP和CS，以便处理完后能返回原函数继续执行。但是存储区域必须禁止用户访问，避免恶意代码或bug的破坏。</p>
<p>​    因此，当x86处理器处理从用户态到内核态的模式转换时，也会切换到内核栈。而<strong>TSS</strong>指明段选择器和栈地址，处理器将SS, ESP, EFLAGS, CS, EIP压入新栈，然后从IDT读取EIP和CS，根据新栈设置ESP和SS。</p>
<p><strong>SS是堆栈段寄存器。它指向将用于堆栈的内存的一般区域。</strong> </p>
<p><strong>ESP是堆栈指针寄存器。它指向在存储器的“堆栈段”区域内的堆栈“顶部”的任何给定点处的精确位置。</strong></p>
<p><strong>EFLAGS标志寄存器。</strong></p>
<p>JOS仅利用TSS来定义需要切换的内核栈。由于内核模式在JOS优先级是0，因此处理器用TSS的ESP0和SS0来定义内核栈，无需TSS结构体中的其他内容。其中，SS0中存储的是GD_KD</p>
<p>  <code>#define GD_KD     0x10     // kernel data</code> </p>
<p>ESP0中存储的是KSTACKTOP </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define KSTACKTOP   KERNBASE</span><br><span class="line">#define KERNBASE   0xF0000000</span><br></pre></td></tr></table></figure>



<p>在x86体系中，中断向量范围为0-255（vector number），最多表示256个异常或者中断，用一个8位的无符号整数表示，前32个vector为处理器保留用作异常处理。</p>
<p>32-255被指定为用户定义的中断，并且不由处理器保留。这些vector通常分配给外部I/O设备，以便这些设备能够向处理器发送中断。</p>
<p><strong>一个例子</strong></p>
<p>通过一个例子来理解上面的知识。假设处理器正在执行用户环境的代码，遇到了”除0”异常。</p>
<ol>
<li><p>处理器切换到内核栈，利用了上文 TSS 中的 ESP0 和 SS0。</p>
</li>
<li><p>处理器将异常参数 push 到了内核栈。一般情况下，按顺序 push <code>SS, ESP, EFLAGS, CS, EIP</code><br>+——————–+ KSTACKTOP<br>| 0x00000 | old SS | “ - 4<br>| old ESP | “ - 8<br>| old EFLAGS | “ - 12<br>| 0x00000 | old CS | “ - 16<br>| old EIP | “ - 20 &lt;—- ESP<br>+——————–+<br>存储这些寄存器状态的意义是：SS(堆栈选择器) 的低 16 位与 ESP 共同确定当前栈状态；EFLAGS(标志寄存器)存储当前FLAG；CS(代码段寄存器) 和 EIP(指令指针寄存器) 确定了当前即将执行的代码地址，E 代表”扩展”至32位。根据这些信息，就能保证处理中断结束后能够恢复到中断前的状态。</p>
</li>
<li><p>因为我们将处理一个”除0”异常，其对应中断向量是0，因此，处理器读取 IDT 的条目0，设置 <code>CS:EIP</code> 指向该条目对应的处理函数。</p>
</li>
<li><p>处理函数获得程序控制权并且处理该异常。例如，终止进程的运行。</p>
</li>
</ol>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220703163747621.png" alt="image-20220703163747621"></p>
<p>ref：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f67034d0c3f2">https://www.jianshu.com/p/f67034d0c3f2</a></p>
<p><strong>嵌套的异常和中断</strong></p>
<p>内核和用户进程都会引起异常和中断。然而，仅在从用户环境进入内核时才会切换栈。如果中断发生时已经在内核态了(此时， <code>CS</code> 寄存器的低 2bit 为 <code>00</code>) ，那么 CPU 就直接将状态压入内核栈，不再需要切换栈。这样，内核就能处理内核自身引起的”嵌套异常”，这是实现保护的重要工具。<br>如果处理器已经处于内核态，然后发生了嵌套异常，由于它并不进行栈切换，所以无须存储 <code>SS</code> 和 <code>ESP</code> 寄存器状态。对于不包含 error code 的异常，在进入处理函数前内核栈状态如下所示：</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220703163920093.png" alt="image-20220703163920093"></p>
<p>对于包含了 error code 的异常，则将 error code 继续 push 到 <code>EIP</code>之后。<br>警告：如果 CPU 处理嵌套异常的时候，无法将状态 push 到内核栈（由于栈空间不足等原因），则 CPU 无法恢复当前状态，只能重启。当然，这是内核设计中必须避免的。</p>
<p>头文件 <code>inc/trap.h</code> 和 <code>kern/trap.h</code> 包含了与中断和异常相关的定义，需要仔细阅读。其中 <code>kern/trap.h</code> 包含内核私有定义，而 <code>inc/trap.h</code> 包含对内核以及用户进程和库都有用的定义。<br>每个异常和中断都应该在 <code>trapentry.S</code> 和 <code>trap_init()</code> 有自己的处理函数，并在 IDT 中将这些处理函数的地址初始化。每个处理函数都需要在栈上新建一个 <code>struct Trapframe</code>（见 <code>inc/trap.h</code>)，以其地址为参数调用 <code>trap()</code> 函数，然后进行异常处理。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220703165253213.png" alt="image-20220703165253213"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0xf0103734 &lt;env_pop_tf+15&gt;:  iret   </span><br><span class="line">0xf0103734      486             asm volatile(</span><br><span class="line">(gdb) info registers</span><br><span class="line">eax            0x0      0</span><br><span class="line">ecx            0x0      0</span><br><span class="line">edx            0x0      0</span><br><span class="line">ebx            0x0      0</span><br><span class="line">esp            0xf0224030       0xf0224030</span><br><span class="line">ebp            0x0      0x0</span><br><span class="line">esi            0x0      0</span><br><span class="line">edi            0x0      0</span><br><span class="line">eip            0xf0103734       0xf0103734 &lt;env_pop_tf+15&gt;</span><br><span class="line">eflags         0x96     [ PF AF SF ]</span><br><span class="line">cs             0x8      8</span><br><span class="line">ss             0x10     16</span><br><span class="line">ds             0x23     35</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">es             0x23     35</span><br><span class="line">fs             0x23     35</span><br><span class="line">gs             0x23     35</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x800020:    cmp    $0xeebfe000,%esp</span><br><span class="line">0x00800020 in ?? ()</span><br><span class="line">(gdb) info registers</span><br><span class="line">eax            0x0      0</span><br><span class="line">ecx            0x0      0</span><br><span class="line">edx            0x0      0</span><br><span class="line">ebx            0x0      0</span><br><span class="line">esp            0xeebfe000       0xeebfe000</span><br><span class="line">ebp            0x0      0x0</span><br><span class="line">esi            0x0      0</span><br><span class="line">edi            0x0      0</span><br><span class="line">eip            0x800020 0x800020</span><br><span class="line">eflags         0x2      [ ]</span><br><span class="line">cs             0x1b     27</span><br><span class="line">ss             0x23     35</span><br><span class="line">ds             0x23     35</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">es             0x23     35</span><br><span class="line">fs             0x23     35</span><br><span class="line">gs             0x23     35</span><br></pre></td></tr></table></figure>

<p>可以看到<code>=&gt; 0x800020:    cmp    $0xeebfe000,%esp</code>时，进入了用户态，因为cs的值变为了<code>GD_UT | 0X3 = 0x1b</code>，esp的值为USTACKTOP的值<code>0xeebfe000</code></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704103409165.png" alt="image-20220704103409165"></p>
<h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a>Exercise 4.</h2><p><strong>Exercise 4.</strong> Edit <code>trapentry.S</code> and <code>trap.c</code> and implement the features described above. The macros <code>TRAPHANDLER</code> and <code>TRAPHANDLER_NOEC</code> in <code>trapentry.S</code> should help you, as well as the T_* defines in <code>inc/trap.h</code>. You will need to add an entry point in <code>trapentry.S</code> (using those macros) for each trap defined in <code>inc/trap.h</code>, and you’ll have to provide <code>_alltraps</code> which the <code>TRAPHANDLER</code> macros refer to. You will also need to modify <code>trap_init()</code> to initialize the <code>idt</code> to point to each of these entry points defined in <code>trapentry.S</code>; the <code>SETGATE</code> macro will be helpful here.</p>
<p>Your <code>_alltraps</code> should:</p>
<ol>
<li>push values to make the stack look like a struct Trapframe</li>
<li>load <code>GD_KD</code> into <code>%ds</code> and <code>%es</code></li>
<li><code>pushl %esp</code> to pass a pointer to the Trapframe as an argument to trap()</li>
<li><code>call trap</code> (can <code>trap</code> ever return?)</li>
</ol>
<p>Consider using the <code>pushal</code> instruction; it fits nicely with the layout of the <code>struct Trapframe</code>.</p>
<p>Test your trap handling code using some of the test programs in the <code>user</code> directory that cause exceptions before making any system calls, such as <code>user/divzero</code>. You should be able to get make grade to succeed on the <code>divzero</code>, <code>softint</code>, and <code>badsegment</code> tests at this point.</p>
<p>查看<code>trapentry.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="line"> * It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="line"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="line"> *</span><br><span class="line"> * You shouldn&#x27;t call a TRAPHANDLER function from C, but you may</span><br><span class="line"> * need to _declare_ one in C (for instance, to get a function pointer</span><br><span class="line"> * during IDT setup).  You can declare the function with</span><br><span class="line"> *   void NAME();</span><br><span class="line"> * where NAME is the argument passed to TRAPHANDLER.</span><br><span class="line"> */</span><br><span class="line">#define TRAPHANDLER(name, num)                \</span><br><span class="line">   .globl name;      /* define global symbol for &#x27;name&#x27; */  \</span><br><span class="line">   .type name, @function; /* symbol type is function */     \</span><br><span class="line">   .align 2;     /* align function definition */       \</span><br><span class="line">   name:        /* function starts here */    \</span><br><span class="line">   pushl $(num);                    \</span><br><span class="line">   jmp _alltraps</span><br></pre></td></tr></table></figure>

<p>.global  定义了全局符号。</p>
<p>​       汇编函数如果需要在其他文件内调用，需要把函数声明为全局，此时就会使用.global这个伪操作。</p>
<p>.type  用来制定一个符号类型是函数类型或者是对象类型，对象类型一般是数据</p>
<p>​        <code>.type symbol, @object</code></p>
<p>​        <code>.type symbol, @function</code></p>
<p>.align  用来指定内存对齐方式</p>
<p>​        <code>.align size</code></p>
<p>​        表示按size字节对齐内存</p>
<p>这一步做了什么？光看这里很难理解，提示说是构造一个 <code>Trapframe</code> 结构体来保存现场，但是这里怎么直接就 push 中断向量了？实际上，在上文已经指出， cpu 自身会先 push 一部分寄存器（见例子所述），而其他则由用户和操作系统决定。由于中断向量是操作系统定义的，所以从这部分开始就已经不属于 cpu 的工作范畴了。</p>
<p>在 <code>trapentry.S</code> 中：</p>
<p>根据inc/trap.h 绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="line">// It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="line"></span><br><span class="line">// Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="line">// Use TRAPHANDLER_NOEC for traps where the CPU doesn&#x27;t push an error code.</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="line"> */</span><br><span class="line">// 绑定异常到自定义处理器</span><br><span class="line">TRAPHANDLER_NOEC(handler0, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(handler1, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(handler2, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(handler3, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(handler4, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(handler5, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(handler6, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(handler7, T_DEVICE)</span><br><span class="line">TRAPHANDLER(handler8, T_DBLFLT)</span><br><span class="line">// 9 deprecated since 386</span><br><span class="line">TRAPHANDLER(handler10, T_TSS)</span><br><span class="line">TRAPHANDLER(handler11, T_SEGNP)</span><br><span class="line">TRAPHANDLER(handler12, T_STACK)</span><br><span class="line">TRAPHANDLER(handler13, T_GPFLT)</span><br><span class="line">TRAPHANDLER(handler14, T_PGFLT)</span><br><span class="line">// 15 reserved by intel</span><br><span class="line">TRAPHANDLER_NOEC(handler16, T_FPERR)</span><br><span class="line">TRAPHANDLER(handler17, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(handler18, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(handler19, T_SIMDERR)</span><br><span class="line">// system call (interrupt)</span><br><span class="line">TRAPHANDLER_NOEC(handler48, T_SYSCALL)</span><br><span class="line"></span><br><span class="line">// 该函数是全局的，但是在 C 文件中使用的时候需要使用 void name(); 再声明一下。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 你不应该从C调用TRAPHANDLER函数，但你可能需要在C中_declare_(例如，在IDT设置期间获得一个函数指针)。您可以使用声明函数</span><br><span class="line">    void NAME();</span><br><span class="line">    其中NAME是传递给TRAPHANDLER的参数。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for _alltraps</span><br><span class="line"> */</span><br><span class="line">_alltraps:</span><br><span class="line">pushl %es</span><br><span class="line">pushl %ds</span><br><span class="line">pushal</span><br><span class="line"></span><br><span class="line">movw $GD_KD, %ax</span><br><span class="line">movw %ax, %ds</span><br><span class="line">movw %ax, %es</span><br><span class="line"></span><br><span class="line">pushl %esp</span><br><span class="line">call trap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 不能用立即数直接给段寄存器赋值。因此不能直接写movw $GD_KD, %ds。</span><br></pre></td></tr></table></figure>



<p><strong>SETGATE MACRO</strong></p>
<p>Set up a normal interrupt/trap gate descriptor.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up a normal interrupt/trap gate descriptor.</span></span><br><span class="line"><span class="comment">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class="line">    <span class="comment">//   see section 9.6.1.3 of the i386 reference: &quot;The difference between</span></span><br><span class="line">    <span class="comment">//   an interrupt gate and a trap gate is in the effect on IF (the</span></span><br><span class="line">    <span class="comment">//   interrupt-enable flag). An interrupt that vectors through an</span></span><br><span class="line">    <span class="comment">//   interrupt gate resets IF, thereby preventing other interrupts from</span></span><br><span class="line">    <span class="comment">//   interfering with the current interrupt handler. A subsequent IRET</span></span><br><span class="line">    <span class="comment">//   instruction restores IF to the value in the EFLAGS image on the</span></span><br><span class="line">    <span class="comment">//   stack. An interrupt through a trap gate does not change IF.&quot;</span></span><br><span class="line"><span class="comment">// - sel: 代码段选择器 for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - off: 代码段的偏移量 for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - dpl: Descriptor Privilege Level -</span></span><br><span class="line"><span class="comment">//   the privilege level required for software to invoke</span></span><br><span class="line"><span class="comment">//   this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gate</span></span><br><span class="line"><span class="comment">这是一个 struct Gatedesc。</span></span><br><span class="line"><span class="comment">istrap</span></span><br><span class="line"><span class="comment">该中断是 trap(exception) 则为1，是 interrupt 则为0。</span></span><br><span class="line"><span class="comment">sel</span></span><br><span class="line"><span class="comment">代码段选择器。进入内核的话是 GD_KT。</span></span><br><span class="line"><span class="comment">off</span></span><br><span class="line"><span class="comment">相对于段的偏移，简单来说就是函数地址。</span></span><br><span class="line"><span class="comment">dpl(Descriptor Privileged Level)</span></span><br><span class="line"><span class="comment">权限描述符。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)         \</span></span><br><span class="line"><span class="meta">&#123;                       \</span></span><br><span class="line"><span class="meta">   (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff;       \</span></span><br><span class="line"><span class="meta">   (gate).gd_sel = (sel);             \</span></span><br><span class="line"><span class="meta">   (gate).gd_args = 0;                \</span></span><br><span class="line"><span class="meta">   (gate).gd_rsv1 = 0;                \</span></span><br><span class="line"><span class="meta">   (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;   \</span></span><br><span class="line"><span class="meta">   (gate).gd_s = 0;               \</span></span><br><span class="line"><span class="meta">   (gate).gd_dpl = (dpl);             \</span></span><br><span class="line"><span class="meta">   (gate).gd_p = 1;               \</span></span><br><span class="line"><span class="meta">   (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16;     \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>Challenge!</em> You probably have a lot of very similar code right now, between the lists of <code>TRAPHANDLER</code> in <code>trapentry.S</code> and their installations in <code>trap.c</code>. Clean this up. Change the macros in <code>trapentry.S</code> to <strong>automatically generate a table</strong> for <code>trap.c</code> to use. Note that you can switch between laying down code and data in the assembler by using the directives <code>.text</code> and <code>.data</code>.</p>
<p><strong>Questions</strong></p>
<p>Answer the following questions in your <code>answers-lab3.txt</code>:</p>
<ol>
<li><p>What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)</p>
<p>为每个异常/中断提供单独的处理函数的目的是什么?(也就是说，如果所有异常/中断都被交付给同一个处理程序，当前实现中存在的哪些特性不能提供?)</p>
<p>答：因为每个异常和中断的处理方式不同，例如除0异常不会继续返回程序执行，而I/O操作中断后会继续返回程序处理。一个handler难以处理多种情况。</p>
</li>
<li><p>Did you have to do anything to make the <code>user/softint</code> program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but <code>softint</code>‘s code says <code>int $14</code>. <em>Why</em> should this produce interrupt vector 13? What happens if the kernel actually allows <code>softint</code>‘s <code>int $14</code>instruction to invoke the kernel’s page fault handler (which is interrupt vector 14)?</p>
</li>
</ol>
<h1 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h1><h2 id="Exercise5-Handling-Page-Faults"><a href="#Exercise5-Handling-Page-Faults" class="headerlink" title="Exercise5: Handling Page Faults"></a>Exercise5: Handling Page Faults</h2><p>缺页错误异常，中断向量 14 (<code>T_PGFLT</code>)，是一个非常重要的异常类型，lab3 以及 lab4 都强烈依赖于这个异常处理。当程序遇到缺页异常时，它将引起异常的虚拟地址存入 <code>CR2</code> 控制寄存器( control register)。在 <code>trap.c</code> 中，我们已经提供了<code>page_fault_handler()</code> 函数用来处理缺页异常。</p>
<p>修改trap_dispatch()，将页面故障异常分派到page_fault_handler()。现在，您应该能够在faultread、faultreadkernel、faultwrite和faultwritekernel测试中获得成功。如果其中任何一个不工作，找出原因并解决它们。记住，您可以使用make run-x或make run-x-nox将JOS引导到特定的用户程序中。例如，make run-hello-nox运行hello用户程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Handle processor exceptions.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">switch</span>(tf-&gt;tf_trapno)&#123;</span><br><span class="line">        <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">            page_fault_handler();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">                panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                env_destroy(curenv);  <span class="comment">// 销毁</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Exercise-6-The-Breakpoint-Exception"><a href="#Exercise-6-The-Breakpoint-Exception" class="headerlink" title="Exercise 6: The Breakpoint Exception"></a>Exercise 6: The Breakpoint Exception</h2><p>断点异常，中断向量 3 (<code>T_BRKPT</code>) 允许调试器给程序加上断点。原理是暂时把程序中的某个指令替换为一个 1 字节大小的 <code>int3</code>软件中断指令。在 JOS 中，我们将它实现为一个伪系统调用。这样，任何程序（不限于调试器）都能使用断点功能。</p>
<p>Modify <code>trap_dispatch()</code> to make breakpoint exceptions invoke the kernel monitor. You should now be able to get make grade to succeed on the <code>breakpoint</code> test.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct Trapframe *tf)</span>    <span class="comment">// dispatch 调度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Handle processor exceptions.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">switch</span>(tf-&gt;tf_trapno)&#123;</span><br><span class="line">        <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">            page_fault_handler(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_BRKPT:</span><br><span class="line">            monitor(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">                panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                env_destroy(curenv);  <span class="comment">// 销毁</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em>Challenge!</em> Modify the JOS kernel monitor so that you can ‘continue’ execution from the current location (e.g., after the <code>int3</code>, if the kernel monitor was invoked via the breakpoint exception), and so that you can single-step one instruction at a time. You will need to understand certain bits of the <code>EFLAGS</code> register in order to implement single-stepping.</p>
<p><em>Optional:</em> If you’re feeling really adventurous, find some x86 disassembler source code - e.g., by ripping it out of QEMU, or out of GNU binutils, or just write it yourself - and extend the JOS kernel monitor to be able to disassemble and display instructions as you are stepping through them. Combined with the symbol table loading from lab 1, this is the stuff of which real kernel debuggers are made.</p>
<p><strong>Questions</strong></p>
<ol>
<li><p>The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to <code>SETGATE</code> from <code>trap_init</code>). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?</p>
<p>断点测试用例将生成断点异常或一般保护故障，这取决于您在IDT中初始化断点条目的方式(即，从trap_init调用SETGATE)。为什么?您需要如何设置它才能使断点异常像上面指定的那样工作?哪些不正确的设置会导致它触发一般的保护故障?</p>
<p><strong>答：</strong>权限问题。特权级别是个很重要的点。每个IDT的entries内的中断描述符都为中断处理程序设定了一个DPL(Descriptor Privilege Level)。用户程序的特权级别是3，内核的特权级别是0(可知<strong>0级别更高</strong>)。如果用户产生的中断/异常需要级别0，那么用户就无权请内核调用这个处理程序，就会产生一个general protection fault，如果是内核发生中断/异常的话，特权级别总是够的</p>
<p><code>SETGATE(idt[T_BRKPT], 1, GD_KT, brkpt_handler, 3);</code>中如果最后一个参数dpl设为3就会产生一个breakpoint exception，如果设为0就会产生一个general protection fault。这也是由于特权级别影响的。breakpoint test程序的特权级别是3，如果断点异常处理程序特权设为3那就可以是断点异常，如果设为0就产生保护错误。</p>
</li>
<li><p>What do you think is the point of these mechanisms, particularly in light of what the <code>user/softint</code> test program does?</p>
<p>里面是这条代码<code>asm volatile(&quot;int $14&quot;);</code>本来想中断调用页面错误处理，结果因为特权级别不够而产生一个保护异常，所以重点应该是要分清特权级别吧。要区分<code>$14</code> 与 <code>$0x30</code>。</p>
<p>优先级别低的代码无法访问优先级高的代码，优先级高低由gd_dpl判断。数字越小越高。</p>
</li>
</ol>
<h2 id="Exercise-7-System-calls"><a href="#Exercise-7-System-calls" class="headerlink" title="Exercise 7: System calls"></a>Exercise 7: System calls</h2><p>用户进程通过调用系统调用请求内核为它们做一些事情。当用户进程调用一个系统调用时，处理器进入内核模式，处理器和内核合作保存用户进程的状态，内核执行相应的代码来执行系统调用，然后恢复用户进程。用户进程如何获得内核的注意，以及用户进程如何指定要执行的调用，这些具体细节在不同的系统中有所不同。</p>
<p>在JOS内核中，我们将使用int指令，它会导致处理器中断。特别地，我们将使用int $0x30作为系统调用中断。我们已经为您定义了常量T_SYSCALL到48 (0x30)。您必须设置中断描述符，以允许用户进程引起中断。注意，中断0x30不能由硬件生成，所以不会因为允许用户代码生成它而产生歧义。</p>
<p>应用程序将在寄存器中传递系统调用号和系统调用参数。这样，内核就不需要在用户环境的堆栈或指令流中到处寻找了。系统调用号将进入%eax，参数(最多5个)将分别进入%edx、%ecx、%ebx、%edi和%esi。内核将返回值返回到%eax中。调用系统调用的汇编代码已经为您编写，在lib/syscall.c中的syscall()中。你应该通读一遍，确保你明白发生了什么.</p>
<p>exercise: 在内核中为中断向量T_SYSCALL添加一个处理程序。你必须编辑kern/trapentry。S和kern/trap.c的trap_init()。您还需要更改trap_dispatch()来处理系统调用中断，方法是使用适当的参数调用sycall(在kern/syscall.c中定义)，然后将返回值传递回%eax中的用户进程。最后，你需要在kern/syscall.c中实现syscall()。确保如果系统调用号无效，syscall()返回-E_INVAL。您应该阅读并理解lib/syscall.c(特别是内联汇编例程)，以确认您对系统调用接口的理解。通过为每个调用调用相应的内核函数来处理inc/syscall.h中列出的所有系统调用。</p>
<p>Run the user/hello program under your kernel (make run-hello). It should print “hello, world” on the console and then cause a page fault in user mode. If this does not happen, it probably means your system call handler isn’t quite right. You should also now be able to get make grade to succeed on the testbss test.</p>
<p><strong>inc/syscall.h</strong></p>
<p>定义了系统调用号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JOS_INC_SYSCALL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JOS_INC_SYSCALL_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* system call numbers */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   SYS_cputs = <span class="number">0</span>,</span><br><span class="line">   SYS_cgetc,</span><br><span class="line">   SYS_getenvid,</span><br><span class="line">   SYS_env_destroy,</span><br><span class="line">   NSYSCALLS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !JOS_INC_SYSCALL_H */</span></span></span><br></pre></td></tr></table></figure>



<p>lib/syscall.c</p>
<p>这是系统调用的通用模板，不同的系统调用都会以不同参数调用syscall函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call stubs.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int32_t</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> check, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int32_t</span> ret;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Generic system call: 在AX中传递系统呼叫号，在DX、CX、BX、DI、SI中最多传递5个参数。</span></span><br><span class="line">   <span class="comment">// 使用t_sycall中断内核。</span></span><br><span class="line">	 <span class="comment">// “volatile”告诉汇编器不要因为没有使用返回值而对该指令进行优化。</span></span><br><span class="line">	 <span class="comment">// 最后一个子句告诉汇编器，这可能会改变条件代码和任意内存位置。</span></span><br><span class="line">   <span class="comment">// 可以看到，该段汇编的output为 ret</span></span><br><span class="line">   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;int %1\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">           : <span class="string">&quot;=a&quot;</span> (ret)</span></span></span><br><span class="line"><span class="params"><span class="function">           : <span class="string">&quot;i&quot;</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;a&quot;</span> (num),    </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;d&quot;</span> (a1),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;c&quot;</span> (a2),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;b&quot;</span> (a3),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;D&quot;</span> (a4),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;S&quot;</span> (a5)</span></span></span><br><span class="line"><span class="params"><span class="function">           : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(check &amp;&amp; ret &gt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;syscall %d returned %d (&gt; 0)&quot;</span>, num, ret);</span><br><span class="line">		<span class="comment">// 函数的返回为ret</span></span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sys_cputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   syscall(SYS_cputs, <span class="number">0</span>, (<span class="keyword">uint32_t</span>)s, len, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_cgetc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> syscall(SYS_cgetc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_env_destroy</span><span class="params">(<span class="keyword">envid_t</span> envid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> syscall(SYS_env_destroy, <span class="number">1</span>, envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">envid_t</span></span></span><br><span class="line"><span class="function"><span class="title">sys_getenvid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_getenvid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>补充知识：GCC内联汇编</strong><br>其语法固定为：<br><code>asm volatile (“asm code”：output：input：changed);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;int %1\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">         : <span class="string">&quot;=a&quot;</span> (ret)</span></span></span><br><span class="line"><span class="params"><span class="function">         : <span class="string">&quot;i&quot;</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;a&quot;</span> (num),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;d&quot;</span> (a1),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;c&quot;</span> (a2),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;b&quot;</span> (a3),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;D&quot;</span> (a4),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;S&quot;</span> (a5)</span></span></span><br><span class="line"><span class="params"><span class="function">         : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">限定符</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“m”、”v”、”o”</td>
<td align="center">内存单元</td>
</tr>
<tr>
<td align="center">“r”</td>
<td align="center">任何寄存器</td>
</tr>
<tr>
<td align="center">“q”</td>
<td align="center">寄存器eax、ebx、ecx、edx之一</td>
</tr>
<tr>
<td align="center">“i”、”h”</td>
<td align="center">直接操作数</td>
</tr>
<tr>
<td align="center">“E”、”F”</td>
<td align="center">浮点数</td>
</tr>
<tr>
<td align="center">“g”</td>
<td align="center">任意</td>
</tr>
<tr>
<td align="center">“a”、”b”、”c”、”d”</td>
<td align="center">分别表示寄存器eax、ebx、ecx和edx</td>
</tr>
<tr>
<td align="center">“S”、”D”</td>
<td align="center">寄存器esi、edi</td>
</tr>
<tr>
<td align="center">“I”</td>
<td align="center">常数 (0至31)</td>
</tr>
</tbody></table>
<p>除了这些约束之外, 输出值还包含一个约束修饰符:</p>
<table>
<thead>
<tr>
<th align="center">输出修饰符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">可以读取和写入操作数</td>
</tr>
<tr>
<td align="center">=</td>
<td align="center">只能写入操作数</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">如果有必要操作数可以和下一个操作数切换</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">在内联函数完成之前, 可以删除和重新使用操作数</td>
</tr>
</tbody></table>
<p>根据表格内容，可以看出该内联汇编作用就是引发一个<code>int</code>中断，中断向量为立即数 <code>T_SYSCALL</code>，同时，对寄存器进行操作。看懂这，就清楚了，这一部分应该不需要我们改动，因为我们处理的是中断已经产生后的部分。<strong>当然，还有另一种更简单的思路，</strong><code>inc/</code> <strong>目录下的，其实都是操作系统留给用户的接口</strong>，所以才会在里面看到 <code>stdio.h</code>，<code>assert.h</code> 等文件。那么，要进行系统调用肯定也是先调用 <code>inc/</code> 中的那个，具体处理应该是在 <code>kern/</code> 中实现。</p>
<p>ref：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f67034d0c3f2">https://www.jianshu.com/p/f67034d0c3f2</a></p>
<p><strong>kern/trap.c</strong></p>
<p>trap_init()添加</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704144047847.png" alt="image-20220704144047847" style="zoom: 50%;" />

<p>权限更改为3，以便用户进程可以触发该中断</p>
<p>修改<strong>trap_dispatch()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">    tf-tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_edx,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_edi,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_esi);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p><strong>kern/syscall.c</strong></p>
<p>我们在 <code>kern/trap.c</code> 中调用的实际上就是这里的 syscall 函数，而不是 <code>lib/syscall.c</code> 中的那个。想明白这一点，设置参数也就很简单了，注意返回值的处理。</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704154830887.png" alt="image-20220704154830887" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line">   <span class="comment">// Return any appropriate return value.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//panic(&quot;syscall not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">        <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">            sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, a2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">            retVal = sys_cgetc();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">            retVal = sys_getenvid()&gt;=<span class="number">0</span>;  <span class="comment">// // Returns the current environment&#x27;s envid.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">            retVal = sys_env_destroy(a1);  <span class="comment">// env_id</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>make grade</code> 可以通过 testbss，运行 <code>make run-hello</code> 可以打印出 <code>hello world</code>，紧接着提示了页错误。</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704163653390.png" alt="image-20220704163653390" style="zoom:50%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704163812230.png" alt="image-20220704163812230" style="zoom:50%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704163804732.png" alt="image-20220704163804732" style="zoom:50%;" />

<p>通过 exercise 7，可以看出 JOS系 统调用的步骤为：</p>
<ol>
<li>用户进程使用 <code>inc/</code> 目录下暴露的接口</li>
<li><code>lib/syscall.c</code> 中的函数将系统调用号及必要参数传给寄存器，并引起一次 <code>int $0x30</code> 中断</li>
<li><code>kern/trap.c</code> 捕捉到这个中断，并将 TrapFrame 记录的寄存器状态作为参数，调用处理中断的函数</li>
<li><code>kern/syscall.c</code> 处理中断</li>
</ol>
<h2 id="Exercise-8-User-mode-startup"><a href="#Exercise-8-User-mode-startup" class="headerlink" title="Exercise 8: User-mode startup"></a>Exercise 8: User-mode startup</h2><p>一个用户程序开始运行在<code>lib/entry.S</code>的顶部。在一些设置之后，这段代码调用<code>lib/libmain.c中</code>的<code>libmain()</code>。你应该修改<code>libmain()</code>来初始化全局指针<code>thisenv</code>，使其指向envs[]数组中的环境结构体Env。(Note that <code>lib/entry.S</code> has already defined <code>envs</code> to point at the <code>UENVS</code> mapping you set up in Part A.) </p>
<p>Hint: look in <code>inc/env.h</code> and use <code>sys_getenvid</code>.</p>
<p><code>libmain()</code> then calls umain, which, in the case of the hello program, is in <code>user/hello.c</code>. Note that after printing “hello, world”, it tries to access <code>thisenv-&gt;env_id.</code> This is why it faulted earlier.</p>
<p>Now that you’ve initialized <code>thisenv</code> properly, it should not fault. If it still faults, you probably haven’t mapped the <code>UENVS</code> area user-readable (back in Part A in <code>pmap.c</code>; this is the first time we’ve actually used the <code>UENVS</code> area).</p>
<p>Add the required code to the user library, then boot your kernel. You should see <code>user/hello</code> print “<code>hello, world</code>“ and then print “<code>i am environment 00001000</code>“. <code>user/hello</code> then attempts to “exit” by calling <code>sys_env_destroy()</code> (see <code>lib/libmain.c</code> and <code>lib/exit.c</code>). Since the kernel currently only supports one user environment, it should report that it has destroyed the only environment and then drop into the kernel monitor. You should be able to get make grade to succeed on the <code>hello</code> test.</p>
<p><strong>umain.c</strong></p>
<p>user/hello.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">umain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cprintf(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">   cprintf(<span class="string">&quot;i am environment %08x\n&quot;</span>, thisenv-&gt;env_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">libmain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// set thisenv to point at our Env structure in envs[].</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">   thisenv = &amp;envs[ENVX(sys_getenvid())];  <span class="comment">// &amp;envs[ENVX(envid)]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// save the name of the program so that panic() can use it</span></span><br><span class="line">   <span class="keyword">if</span> (argc &gt; <span class="number">0</span>)</span><br><span class="line">      binaryname = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// call user main routine</span></span><br><span class="line">   umain(argc, argv);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// exit gracefully</span></span><br><span class="line">   <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704172003993.png" alt="image-20220704172003993"></p>
<p>hello 完成</p>
<h2 id="Exercise-9-Page-faults-and-memory-protection"><a href="#Exercise-9-Page-faults-and-memory-protection" class="headerlink" title="Exercise 9: Page faults and memory protection"></a>Exercise 9: Page faults and memory protection</h2><p>内存保护是操作系统的关键功能，它确保了一个程序中的错误不会导致其他程序或是操作系统自身的崩溃。<br>操作系统通常依赖硬件的支持来实现内存保护。操作系统会告诉硬件哪些虚拟地址可用哪些不可用。当某个程序想访问不可用的内存地址或不具备权限时，处理器将在出错指令处停止程序，然后陷入内核。如果错误可以处理，内核就处理并恢复程序运行，否则无法恢复。<br>作为可以修复的错误，设想某个自动生长的栈。在许多系统中内核首先分配一个页面给栈，如果某个程序访问了页面外的空间，内核会自动分配更多页面以让程序继续。这样，内核只用分配程序需要的栈内存给它，然而程序感觉仿佛可以拥有任意大的栈内存。<br>系统调用也为内存保护带来了有趣的问题。许多系统调用接口允许用户传递指针给内核，这些指针指向待读写的用户缓冲区。内核处理系统调用的时候会对这些指针解引用。这样就带来了两个问题：</p>
<ol>
<li>内核的页错误通常比用户进程的页错误严重得多，如果内核在操作自己的数据结构时发生页错误，这就是一个内核bug，会引起系统崩溃。<strong>因此，内核需要记住这个错误是来自用户进程。</strong></li>
<li>内核比用户进程拥有更高的内存权限，<strong>用户进程给内核传递的指针可能指向一个只有内核能够读写的区域，内核必须谨慎避免解引用这类指针</strong>，因为这样可能导致内核的私有信息泄露或破坏内核完整性。</li>
</ol>
<p>我们将<strong>对用户进程传给内核的指针做一个检查来解决这两个问题</strong>。内核将检查指针指向的是内存中用户空间部分，页表也允许内存操作。</p>
<p>Change <code>kern/trap.c</code> to <strong>panic</strong> if a page fault happens <strong>in kernel mode</strong>.</p>
<p><strong>Hint:</strong> to determine whether a fault happened in user mode or in kernel mode, check the <strong>low bits</strong> of the <code>tf_cs</code>. (<strong>tf_cs是0x18还是0x1b， 0x18｜0x03 = 0x1b此时是用户模式，0x18是内核模式，检查&amp;3后的低2位</strong>)</p>
<p>Read <code>user_mem_assert</code> in <code>kern/pmap.c</code> and implement <code>user_mem_check</code> in that same file.</p>
<p>Change <code>kern/syscall.c</code> to sanity check arguments to system calls.</p>
<p>Boot your kernel, running <code>user/buggyhello</code>. The environment should be destroyed, and the kernel should <em>not</em> panic. You should see:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[00001000] user_mem_check assertion failure for va 00000001</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Destroyed the only environment - nothing more to do!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Finally, change <code>debuginfo_eip</code> in <code>kern/kdebug.c</code> to call <code>user_mem_check</code> on <code>usd</code>, <code>stabs</code>, and <code>stabstr</code>. If you now run <code>user/breakpoint</code>, you should be able to run <code>backtrace</code> from the kernel monitor and see the backtrace traverse into <code>lib/libmain.c</code> before the kernel panics with a page fault. What causes this page fault? You don’t need to fix it, but you should understand why it happens.</p>
<p><strong>kern/trap.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_fault_handler</span><span class="params">(struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">   fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span>(!(tf-&gt;tf_cs &amp; <span class="number">3</span>))&#123;</span><br><span class="line">        panic(<span class="string">&quot;page fault in kernel mode.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">   <span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">   cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">      curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">   print_trapframe(tf);</span><br><span class="line">   env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>kern/pmap.c</strong></p>
<p>user_mem_check</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查一个环境是否允许访问权限为&#x27;perm | PTE_P&#x27;的内存范围[va, va+len]。</span></span><br><span class="line"><span class="comment">// 通常&#x27;perm&#x27;至少包含PTE_U，但这不是必需的。&#x27;va&#x27;和&#x27;len&#x27;不需要按页面对齐;必须测试包含任何该范围的每个页面。</span></span><br><span class="line"><span class="comment">// 你可以测试&#x27;len/PGSIZE&#x27;， &#x27;len/PGSIZE + 1&#x27;，或者&#x27;len/PGSIZE + 2&#x27;页面。</span></span><br><span class="line"><span class="comment">// 用户程序可以访问一个虚拟地址，如果</span></span><br><span class="line"><span class="comment">// (1)该地址在ULIM之下</span></span><br><span class="line"><span class="comment">// (2)页表给了它权限。这些正是您应该在这里实现的测试。</span></span><br><span class="line"><span class="comment">// 这些正是您应该在这里实现的测试。</span></span><br><span class="line"><span class="comment">// 如果有错误，设置&#x27;user_mem_check_addr&#x27;变量为第一个错误的虚拟地址。</span></span><br><span class="line"><span class="comment">// 如果用户程序可以访问这个地址范围，返回0，否则返回-E_FAULT。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">user_mem_check</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// 内存范围[va, va+len]</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> start_va = ROUNDDOWN((<span class="keyword">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = ROUNDUP((<span class="keyword">uintptr_t</span>)va + len, PGSIZE);</span><br><span class="line">    <span class="comment">// 访问内存，通过页表，那么直接看page table entry</span></span><br><span class="line">    <span class="comment">// 遍历查看是否有权限</span></span><br><span class="line">    <span class="comment">// pgdir_walk returns a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line">    <span class="comment">// pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)</span></span><br><span class="line">    <span class="keyword">for</span>((<span class="keyword">uintptr_t</span>)cur_va = start_va;cur_va&lt;end_va;cur_va+=PGSIZE)&#123;</span><br><span class="line">        <span class="comment">// env-&gt;env_pgdir 取进程对应的页表</span></span><br><span class="line">        <span class="keyword">pte_t</span>* cur_pte = pgdir_walk(env-&gt;env_pgdir, (<span class="keyword">void</span>*)cur_va, <span class="number">0</span>);  <span class="comment">// 只查询不建立</span></span><br><span class="line">        <span class="keyword">if</span>(cur_pte == <span class="literal">NULL</span> || (*cur_pte &amp; (perm | PTE_P))!=(perm | PTE_P) || cur_va&gt;=ULIM)&#123;  <span class="comment">// 不满足要求</span></span><br><span class="line">            <span class="keyword">if</span>(cur_va == start_va)&#123;  <span class="comment">// 因为va做了近似，所以第一个页面地址要做处理</span></span><br><span class="line">                user_mem_check_addr = va;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                user_mem_check_addr = cur_va;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 程序不能访问这个地址，返回-E_FAULT</span></span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以访问</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704223729337.png" alt="image-20220704223729337" style="zoom:50%;" />

<p>不能写为cur_va&lt;=end_va。会内存越界</p>
<p>user_mem_assert</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Checks that environment &#x27;env&#x27; is allowed to access the range</span></span><br><span class="line"><span class="comment">// of memory [va, va+len) with permissions &#x27;perm | PTE_U | PTE_P&#x27;.</span></span><br><span class="line"><span class="comment">// If it can, then the function simply returns.</span></span><br><span class="line"><span class="comment">// If it cannot, &#x27;env&#x27; is destroyed and, if env is the current</span></span><br><span class="line"><span class="comment">// environment, this function will not return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">user_mem_assert</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (user_mem_check(env, va, len, perm | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      cprintf(<span class="string">&quot;[%08x] user_mem_check assertion failure for &quot;</span></span><br><span class="line">         <span class="string">&quot;va %08x\n&quot;</span>, env-&gt;env_id, user_mem_check_addr);</span><br><span class="line">      env_destroy(env);  <span class="comment">// may not return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了user_mem_check()，不满足则摧毁页面</p>
<p>运行 <code>make run-buggyhello-nox</code></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704213103991.png" alt="image-20220704213103991"></p>
<pre><code>[00001000] user_mem_check assertion failure for va 00000001
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!
</code></pre>
<p>最后，change <code>debuginfo_eip</code> in <code>kern/kdebug.c</code> to call <code>user_mem_check</code> on <code>usd</code>, <code>stabs</code>, and <code>stabstr</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">      <span class="comment">// 就是查看能否访问 UserStabData</span></span><br><span class="line">      <span class="comment">// int user_mem_check(struct Env *env, const void *va, size_t len, int perm)</span></span><br><span class="line">      <span class="keyword">if</span>(user_mem_check(curenv, (<span class="keyword">void</span>*) usd, <span class="keyword">sizeof</span>(struct UserStabData), PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">stabs = usd-&gt;stabs;</span><br><span class="line">stab_end = usd-&gt;stab_end;</span><br><span class="line">stabstr = usd-&gt;stabstr;</span><br><span class="line">stabstr_end = usd-&gt;stabstr_end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure the STABS and string table memory is valid.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">      <span class="keyword">if</span>(user_mem_check(curenv, (<span class="keyword">void</span>*) stabs, stab_end - stabs, PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(user_mem_check(curenv, (<span class="keyword">void</span>*) stabstr, stabstr_end - stabstr, PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><code>make run-breakpoint-nox</code> 然后 使用 <code>backtrace</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">K&gt; backtrace</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp efffff10  eip f0100a39  args <span class="number">00000001</span> efffff28 f0226000 <span class="number">00000000</span> f01e4a40</span><br><span class="line">    kern/monitor.c:<span class="number">222</span>: monitor+<span class="number">260</span></span><br><span class="line">  ebp efffff80  eip f0103f80  args f0226000 efffffbc <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">    kern/trap.c:<span class="number">200</span>: trap+<span class="number">187</span></span><br><span class="line">  ebp efffffb0  eip f010409d  args efffffbc <span class="number">00000000</span> <span class="number">00000000</span> eebfdfd0 efffffdc</span><br><span class="line">    kern/trapentry.S:<span class="number">93</span>: &lt;unknown&gt;+<span class="number">0</span></span><br><span class="line">  ebp eebfdfd0  eip <span class="number">0080007b</span>  args <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">    lib/libmain.c:<span class="number">26</span>: libmain+<span class="number">63</span></span><br><span class="line">Incoming TRAP frame at <span class="number">0xeffffe8c</span></span><br><span class="line">kernel panic at kern/trap.c:<span class="number">272</span>: page fault in kernel mode.</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> a <span class="built_in">list</span> of commands.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到遍历到了：<code>lib/libmain.c:26: libmain+63</code></p>
<p>ebp(基址指针寄存器)寄存器的内容，efffff10，efffff80，efffffb0都位于内核栈，eebfdfd0位于用户栈。</p>
<p>输入<code>make run-breakpoint-nox-gdb       make gdb</code></p>
<p>把断点打在 monitor()函数处(kern/monitor.c)</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704220321417.png" alt="image-20220704220321417"></p>
<p>查看ebp的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用者ebp   返回地址eip  参数1  参数2</span><br><span class="line">参数3       参数4        参数5  ...</span><br></pre></td></tr></table></figure>

<p>在查看0xeebfdfd0到用户栈栈顶0xeebfdff0的内容</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704221209942.png" alt="image-20220704221209942"></p>
<p>试图越界访问，可得到</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704221230450.png" alt="image-20220704221230450"></p>
<p>可以看到，最后就只剩了12个字符</p>
<p>这一次，backtrace的打印内容为</p>
<p><code>ebp eebfdfd0  eip 0080007b  args 00000000 00000000 00000000 00000000 00000000</code></p>
<p>那么下一次为</p>
<p><code>ebp eebfdff0  eip 00800031  args 00000000 00000000 之后的三个参数全部超过内存访问界限了</code></p>
<p>现在修改backtrace的函数，输出两个args，backtrace位于kern/monitor.c</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704221854670.png" alt="image-20220704221854670" style="zoom:50%;" />

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704223813288.png" alt="image-20220704223813288"></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C6-828/" rel="tag"># 操作系统，6.828</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/03/6-828Lab2/" rel="prev" title="6.828Lab2">
                  <i class="fa fa-chevron-left"></i> 6.828Lab2
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/04/6-828Lab4/" rel="next" title="6-828Lab4">
                  6-828Lab4 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
