<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="我的一些记录">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="我的一些记录">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>我的一些记录</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我的一些记录</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/25/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%AD%90%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/25/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%AD%90%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">前缀和与子数组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-25 10:48:09" itemprop="dateCreated datePublished" datetime="2022-05-25T10:48:09+08:00">2022-05-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-26 17:20:40" itemprop="dateModified" datetime="2022-05-26T17:20:40+08:00">2022-05-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>相似题目</strong></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/">467. 环绕字符串中唯一的子字符串</a>(中等)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/">795.区间子数组个数</a>(中等)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮</a>(中等)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组</a>（困难）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a>（中等）</p>
</li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-immutable/description/">303. 区域和检索 - 数组不可变</a></li>
<li><a href="https://leetcode.cn/link/?target=https://lucifer.ren/blog/2019/12/11/leetcode-1186/">1186.删除一次得到子数组最大和</a></li>
<li><a href="https://leetcode.cn/link/?target=https://lucifer.ren/blog/2020/01/09/1310.xor-queries-of-a-subarray/">1310. 子数组异或查询</a></li>
<li><a href="https://leetcode.cn/link/?target=https://github.com/azl397985856/leetcode/blob/master/problems/1371.find-the-longest-substring-containing-vowels-in-even-counts.md">1371. 每个元音包含偶数次的最长子字符串</a></li>
</ul>
<p>ref : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-substrings-in-wraparound-string/solution/xi-fa-dai-ni-xue-suan-fa-yi-ci-gao-ding-qian-zhui-/">https://leetcode.cn/problems/unique-substrings-in-wraparound-string/solution/xi-fa-dai-ni-xue-suan-fa-yi-ci-gao-ding-qian-zhui-/</a></p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="例题1-presum"><a href="#例题1-presum" class="headerlink" title="例题1 (presum)"></a>例题1 (presum)</h2><p>有 N 个的正整数放到数组 A 里，现在要求一个新的数组 B，新数组的第 i 个数 B[i]是原数组 A 第 0 到第 i 个数的和。</p>
<p>求解：正常前缀和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; sum;</span><br><span class="line"><span class="keyword">int</span> n = sum.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">psum</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">psum1</span><span class="params">(n)</span></span>;</span><br><span class="line">psum[i] = psum[i<span class="number">-1</span>]+sum[i];   <span class="comment">// [l,r] -&gt;  psum[r] - psum[l-1]</span></span><br><span class="line">psum1[i] = psum[i<span class="number">-1</span>]+sum[i<span class="number">-1</span>]; <span class="comment">// [l, r] -&gt; psum[r+1] - psum[l];</span></span><br></pre></td></tr></table></figure>

<h2 id="例题2-countArray"><a href="#例题2-countArray" class="headerlink" title="例题2 (countArray)"></a>例题2 (countArray)</h2><p>求一个数组的连续子数组总个数。比如 [1,3,4]，其连续子数组有：<code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，需要返回 6。</p>
<p>总的连续子数组个数等于：<strong>以索引为 0 结尾的子数组个数 + 以索引为 1 结尾的子数组个数 + … + 以索引为 n - 1 结尾的子数组个数</strong>。</p>
<p><strong>利用 例题1 的前缀和思路， 边遍历边求和。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a: nums)&#123;</span><br><span class="line">        temp+=<span class="number">1</span>;</span><br><span class="line">        ans+=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：<em>O</em>(N)，其中 N 为数组长度。</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="例题3-countArrayGapK"><a href="#例题3-countArrayGapK" class="headerlink" title="例题3 (countArrayGapK)"></a>例题3 (countArrayGapK)</h2><p>求一个数组相邻差为 1 连续子数组的总个数，就是<strong>索引差 1 的同时，值也差 1。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArrayGap1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] = nums[i<span class="number">-1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">            temp+=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="例题4-countArrayLessEqualK"><a href="#例题4-countArrayLessEqualK" class="headerlink" title="例题4 (countArrayLessEqualK)"></a>例题4 (countArrayLessEqualK)</h2><p>求出不大于 k 的子数组的个数。不大于 k 指的是子数组的全部元素都不大于 k。 比如 [1,3,4] 子数组有 [1], [3], [4], [1,3], [3,4] , [1,3,4]，不大于 3 的子数组有 [1], [3], [1,3] ，那么 [1,3,4] 不大于 3 的子数组个数就是 3。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArrayLessK</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt;= k)&#123;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="例题5-countArraMostEqualK"><a href="#例题5-countArraMostEqualK" class="headerlink" title="例题5(countArraMostEqualK)"></a>例题5(countArraMostEqualK)</h2><p>求出子数组最大值刚好是 k 的子数组的个数。 比如 [1,3,4] 子数组有 [1], [3], [4], [1,3], [3,4] , [1,3,4]，子数组最大值刚好是 3 的子数组有 [3], [1,3] ，那么 [1,3,4] 子数组最大值刚好是 3 的子数组个数就是 2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArraMostEqualK</span><span class="params">(<span class="keyword">int</span> k1, <span class="keyword">int</span> k2, vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子数组最大值刚好是k的子数组</strong>的个数 countArraMostEqualK可以使用<strong>求不大于k的子数组</strong>的方法countArrayLessEqualK 来求解，即 </p>
<p><code>countArraMostEqualK(k) = countArrayLessK (k) - countArrayLessK (k-1)</code></p>
<h2 id="例题6-countArraBetween"><a href="#例题6-countArraBetween" class="headerlink" title="例题6 (countArraBetween)"></a>例题6 (countArraBetween)</h2><p>求出子数组最大值刚好是 介于 k1 和 k2 的子数组的个数。</p>
<p><code>countArraBetween(k1, k2, nums)</code> 等价于 </p>
<p><code>countArrayLessK(k2, nums) - countArrayLessK(k1 - 1, nums), k2&gt;k1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArraBetween</span><span class="params">(<span class="keyword">int</span> k1, <span class="keyword">int</span> k2, vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小于等于 k2 的区域</strong> 减去  <strong>小于 k1 的区域</strong> 就是 <strong>大于等于 k1 且小于等于 k2 的区域</strong>。</p>
<h1 id="467-环绕字符串中唯一的子字符串"><a href="#467-环绕字符串中唯一的子字符串" class="headerlink" title="467. 环绕字符串中唯一的子字符串"></a>467. 环绕字符串中唯一的子字符串</h1><p>把字符串 s 看作是 “abcdefghijklmnopqrstuvwxyz” 的无限环绕字符串，所以 s 看起来是这样的：</p>
<p>“…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….” .<br>现在给定另一个字符串 p 。返回 s 中 唯一 的 p 的 非空子串 的数量 。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: p = &quot;a&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 字符串 s 中只有一个&quot;a&quot;子字符。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: p = &quot;cac&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 字符串 s 中的字符串“cac”只有两个子串“a”、“c”。.</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: p = &quot;zab&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在字符串 s 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">1 &lt;= p.length &lt;= 10^5</span><br><span class="line">p 由小写英文字母构成</span><br></pre></td></tr></table></figure>

<p>套模板3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case467</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((p[i] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; p[i<span class="number">-1</span>] ==<span class="string">&#x27;z&#x27;</span>) || (p[i]-<span class="string">&#x27;a&#x27;</span>) == (p[i<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">26</span> + <span class="number">1</span>)%<span class="number">26</span>)&#123;</span><br><span class="line">            <span class="comment">// 连续</span></span><br><span class="line">            temp++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不连续</span></span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接套模板是错误的，因为对于<strong>cac</strong>这种情况，返回值是3， 但实际上是2，因为c被计算了两次，这就意味着需要去重，如果对于输入<code>abcd</code>使用set去重可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">ab (a, b)</span><br><span class="line">cd  (c, d)</span><br><span class="line">abc (a,b,c,ab,bc,abc)</span><br><span class="line">bcd (b,c,d,bc,cd,bcd)</span><br><span class="line">abcd (....)</span><br></pre></td></tr></table></figure>

<p>发现set中的元素是连续的，那么只用记录以某个字母为结束点的最大长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case467</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((p[i] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; p[i<span class="number">-1</span>] ==<span class="string">&#x27;z&#x27;</span>) || (p[i]-<span class="string">&#x27;a&#x27;</span>) == (p[i<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">26</span> + <span class="number">1</span>)%<span class="number">26</span>)&#123;</span><br><span class="line">            <span class="comment">// 连续</span></span><br><span class="line">            temp++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不连续</span></span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[p[i]-<span class="string">&#x27;a&#x27;</span>] = <span class="built_in">max</span>(dp[p[i]-<span class="string">&#x27;a&#x27;</span>], temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="795-区间子数组个数"><a href="#795-区间子数组个数" class="headerlink" title="795. 区间子数组个数"></a>795. 区间子数组个数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。</span><br><span class="line"></span><br><span class="line">生成的测试用例保证结果符合 32-bit 整数范围。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,1,4,3], left = 2, right = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：满足条件的三个子数组：[2], [2, 1], [3]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,9,2,5,6], left = 2, right = 8</span><br><span class="line">输出：7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= nums.length &lt;= 10^5</span><br><span class="line">0 &lt;= nums[i] &lt;= 10^9</span><br><span class="line">0 &lt;= left &lt;= right &lt;= 10^9</span><br></pre></td></tr></table></figure>

<p>可以看到满足例题6， countArrayBetween， 可以使用 <code>mostK(right) - mostK(left - 1)</code>来解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(vector&lt;<span class="keyword">int</span>&gt;&amp;, <span class="keyword">int</span>)&gt; atMostK = [&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= k)&#123;</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans+=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atMostK</span>(nums, right) - <span class="built_in">atMostK</span>(nums, left - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a>904. 水果成篮</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</span><br><span class="line"></span><br><span class="line">你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</span><br><span class="line"></span><br><span class="line">你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</span><br><span class="line">你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</span><br><span class="line">一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</span><br><span class="line">给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：fruits = [1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= fruits.length &lt;= 10^5</span><br><span class="line">0 &lt;= fruits[i] &lt; fruits.length</span><br></pre></td></tr></table></figure>

<p>就是给你一个数组， 让你<strong>选定一个子数组， 这个子数组最多只有两种数字</strong>，这个选定的子数组最大可以是多少。</p>
<p>和例题四一个样，只不过lessEqual判断为辨别可使用篮子的个数。采摘要连续</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = fruits.<span class="built_in">size</span>();</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 记录需要删除水果的起始下标</span></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mp[fruits[i]] == <span class="number">0</span>) &#123; <span class="comment">// 没使用过</span></span><br><span class="line">			--k;</span><br><span class="line">		&#125;</span><br><span class="line">		mp[fruits[i]]++;</span><br><span class="line">		<span class="keyword">while</span> (k &lt; <span class="number">0</span>) &#123;  <span class="comment">// 有新水果进来，篮子已超出了两个</span></span><br><span class="line">			<span class="comment">// 直至删除空了一种水果，画图好理解</span></span><br><span class="line">			mp[fruits[j]]--;</span><br><span class="line">			<span class="keyword">if</span> (mp[fruits[j]] == <span class="number">0</span>) &#123;</span><br><span class="line">				++k;</span><br><span class="line">			&#125;</span><br><span class="line">			j++; </span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, i - j + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="992-K-个不同整数的子数组"><a href="#992-K-个不同整数的子数组" class="headerlink" title="992. K 个不同整数的子数组"></a>992. K 个不同整数的子数组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数数组 nums和一个整数 k ，返回 num 中 「好子数组」 的数目。</span><br><span class="line"></span><br><span class="line">如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。</span><br><span class="line"></span><br><span class="line">例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。</span><br><span class="line">子数组 是数组的 连续 部分。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,1,2,3], k = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,2,1,3,4], k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= nums.length &lt;= 2 * 10^4</span><br><span class="line">1 &lt;= nums[i], k &lt;= nums.length</span><br></pre></td></tr></table></figure>

<p>条件为不同数字的个数。用个set，不断剔除掉最早出现的数字。</p>
<p>由例题 6，知：<code>equalK = MostEqualK(k) - MostEqualK(k - 1)</code>， 因此答案便呼之欲出了。其他部分和上面的题目 <strong>904. 水果成篮</strong> 一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> mostEqualK = [&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 保存最早出现的数字</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[nums[i]] == <span class="number">0</span>)&#123;  <span class="comment">// 没出现过，加进去</span></span><br><span class="line">                --k; <span class="comment">// 剩余的不同数目减一</span></span><br><span class="line">            &#125;</span><br><span class="line">            mp[nums[i]]++;</span><br><span class="line">            <span class="comment">// 没出现过的数字加进去后发现超出了不同数字的要求值</span></span><br><span class="line">            <span class="keyword">while</span>(k&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                mp[nums[j]]--;</span><br><span class="line">                <span class="keyword">if</span>(mp[nums[j]] == <span class="number">0</span>)&#123;  <span class="comment">// 直至清空前面任何一个数字</span></span><br><span class="line">                    <span class="comment">// 因为删除空的数字之前的那部分也是不能使用的，因为不连续</span></span><br><span class="line">                    ++k; <span class="comment">// k从-1归0， 此时正好用完</span></span><br><span class="line">                &#125;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (i - j + <span class="number">1</span>);  <span class="comment">// 按照之前求countArray的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mostEqualK</span>(nums, k) - <span class="built_in">mostEqualK</span>(nums, k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a>1109. 航班预订统计</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">这里有 n 个航班，它们分别从 1 到 n 进行编号。</span><br><span class="line"></span><br><span class="line">有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</span><br><span class="line">请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2   3   4   5</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       20  20</span><br><span class="line">预订记录 3 ：       25  25  25  25</span><br><span class="line">总座位数：      10  55  45  25  25</span><br><span class="line">因此，answer = [10,55,45,25,25]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：bookings = [[1,2,10],[2,2,15]], n = 2</span><br><span class="line">输出：[10,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       15</span><br><span class="line">总座位数：      10  25</span><br><span class="line">因此，answer = [10,25]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= n &lt;= 2 * 10^4</span><br><span class="line">1 &lt;= bookings.length &lt;= 2 * 10^4</span><br><span class="line">bookings[i].length == 3</span><br><span class="line">1 &lt;= firsti &lt;= lasti &lt;= n</span><br><span class="line">1 &lt;= seatsi &lt;= 10^4</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 差分数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;bookings.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            nums[bookings[i][<span class="number">0</span>]<span class="number">-1</span>] += bookings[i][<span class="number">2</span>];</span><br><span class="line">            nums[bookings[i][<span class="number">1</span>]] -= bookings[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            nums[i]+=nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/6-828Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/17/6-828Lab1/" class="post-title-link" itemprop="url">6.828Lab1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-17 12:00:23" itemprop="dateCreated datePublished" datetime="2022-05-17T12:00:23+08:00">2022-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-03 17:00:17" itemprop="dateModified" datetime="2022-06-03T17:00:17+08:00">2022-06-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="PC-Bootstrap"><a href="#PC-Bootstrap" class="headerlink" title="PC Bootstrap"></a>PC Bootstrap</h1><h2 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h2><img src="https://s2.loli.net/2022/05/23/apzkU1cGI5YCqgR.png" alt="image-20220517122025755" style="zoom: 67%;" />

<ul>
<li>早期PC，16位，只有可用物理地址只有1M(0x00000000~0x000FFFFF)</li>
<li>最重要的部分是**Basic Input/Output System (BIOS)**，它占据从0x000F0000到0x000FFFFF的64KB区域。在早期的pc机中，BIOS保存在read-only memory (ROM)中，现在pc机将BIOS存储在updateable flash memory(可更新的闪存)中。</li>
<li>BIOS负责执行基本的系统初始化，如激活显卡和检查已安装的内存数量。在执行此初始化之后，BIOS从某些适当的位置(如 floppy disk(软盘), hard disk, CD-ROM, or the network)加载操作系统，并将机器的控制权传递给操作系统。</li>
<li>虽然现在可以处理器支持4GB的物理地址空间了，但还是保留那1MB的物理地址的设定来向后兼容</li>
</ul>
<h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><p>学习boot.s,main.c,boot.asm，了解在GDB中执行the boot loader时发生了什么？</p>
<p>在地址 0x7c00 处设置断点，它是加载后的引导扇区的位置。继续运行，直到那个断点。在 <code>boot/boot.S</code> 中跟踪代码，使用源代码和反汇编文件 <code>obj/boot/boot.asm</code> 去保持跟踪。</p>
<p>在 <code>boot/main.c</code> 文件中跟踪进入 <code>bootmain()</code> ，然后进入 <code>readsect()</code>。识别 <code>readsect()</code> 中相关的每一个语句的准确汇编指令。跟踪 <code>readsect()</code> 中剩余的指令，然后返回到 <code>bootmain()</code> 中，识别 <code>for</code> 循环的开始和结束位置，这个循环从磁盘上读取内核的剩余扇区。找出循环结束后运行了什么代码，在这里设置一个断点，然后继续。接下来再走完引导加载器的剩余工作。</p>
<p>完成之后，就能够回答下列的问题了：</p>
<ul>
<li><strong>处理器开始运行 32 代码时指向到什么地方？从 16 位模式切换到 32 位模式的真实原因是什么？</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Jump to next instruction, but in 32-bit code segment.</span><br><span class="line"># Switches processor into 32-bit mode.</span><br><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line">  7c2d:    ea 32 7c 08 00 66 b8   ljmp   $0xb866,$0x87c32</span><br></pre></td></tr></table></figure>

<p>在boot.asm 这里切换到32位代码。应该是经过64与60端口的控制，加载完<strong>GDT</strong>表后，<strong>CRO的bit0位为1</strong>，此时机器已处于保护模式，故处理器从16位模式转为32位模式。</p>
<p>全局描述表(GDT Global Descriptor Table):在保护模式下一个重要的数据结构。用来存储内存的分段信息。</p>
<p>GDT可以被放在内存的任何位置，那么当程序员通过段寄存器来引用一个段描述符时，CPU必须知道GDT的入口，也就是基地址放在哪里，所以Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。</p>
<ul>
<li><strong>引导加载器执行的最后一个指令是什么，内核加载之后的第一个指令是什么？</strong></li>
</ul>
<p>引导加载程序的最后一条指令是boot/main.c中bootmain函数最后的<code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code> 这个第一条指令位于/kern/entry.S文件中，第一句 movw $0x1234, 0x472</p>
<img src="https://s2.loli.net/2022/05/17/PDW1a34oZVg8Ytd.png" alt="image-20220517140436330" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/17/5mKUDGAswoZbuIt.png" alt="image-20220517140447848" style="zoom:67%;" />



<ul>
<li><strong>内核的第一个指令在哪里？</strong></li>
</ul>
<p>位于<code>/kern/entry.S</code>文件中</p>
<ul>
<li><strong>为从硬盘上获取完整的内核，引导加载器如何决定有多少扇区必须被读入？在哪里能找到这些信息？</strong></li>
</ul>
<p>通过<code>ELF program headers</code>决定，他在操作系统内核映像文件的ELF头部信息里找到。</p>
<p>Examine the full list of the names, sizes, and link addresses of all the sections in the kernel executable by typing:</p>
<p><img src="https://s2.loli.net/2022/05/17/ZRyWbj38usFvmN9.png" alt="image-20220517155248619"></p>
<ul>
<li><code>.text</code>：程序的可运行指令。</li>
<li><code>.rodata</code>：只读数据，比如，由 C 编译器生成的 ASCII 字符串常量。（然而我们并不需要操心设置硬件去禁止写入它）</li>
<li><code>.data</code>：保持在程序的初始化数据中的数据节，比如，初始化声明所需要的全局变量，比如，像 <code>int x = 5;</code>。</li>
</ul>
<p>look at the <code>.text</code> section of the boot loader:</p>
<p><img src="https://s2.loli.net/2022/05/17/3fRjomwzLVUyE6h.png" alt="image-20220517155417627"></p>
<h3 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h3><p>下载 <a target="_blank" rel="noopener" href="https://sipb.mit.edu/iap/6.828/files/pointers.c">pointers.c</a> 的源代码，运行它，然后确保你理解了输出值的来源的所有内容。尤其是，确保你理解了第 1 行和第 6 行的指针地址的来源、第 2 行到第 4 行的值是如何得到的、以及为什么第 5 行指向的值表面上看像是错误的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">16</span>);  <span class="comment">//一个int四个字节，共16个字节</span></span><br><span class="line">    <span class="keyword">int</span> *c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	a[i] = <span class="number">100</span> + i;</span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">200</span>;  <span class="comment">// c指向a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c[<span class="number">1</span>] = <span class="number">300</span>;</span><br><span class="line">    *(c + <span class="number">2</span>) = <span class="number">301</span>;</span><br><span class="line">    <span class="number">3</span>[c] = <span class="number">302</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = c + <span class="number">1</span>;  <span class="comment">// c指向a[1]。由于a中存int，一个int占四个字节，所以c的地址会+4，而不是+1</span></span><br><span class="line">    *c = <span class="number">400</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = (<span class="keyword">int</span> *) ((<span class="keyword">char</span> *) c + <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">//如果先将c转化为字符串，再直接对字符串+1，这样导致c实际地址就是+1</span></span><br><span class="line">    *c = <span class="number">500</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    b = (<span class="keyword">int</span> *) a + <span class="number">1</span>;</span><br><span class="line">    c = (<span class="keyword">int</span> *) ((<span class="keyword">char</span> *) a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;6: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> ac, <span class="keyword">char</span> **av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/05/17/t9ayFTDzYM75lJw.png" alt="img" style="zoom:67%;" />

<p><strong>如果先将c转化为字符串，再直接对字符串+1，这样导致c实际地址就是+1，从<code>0x7fffd33e72c4</code>到<code>0x7fffd33e72c5</code></strong></p>
<h5 id="c-int-char-c-1-与c-c-1的区别"><a href="#c-int-char-c-1-与c-c-1的区别" class="headerlink" title="c = (int *) ((char *) c + 1) 与c=c+1的区别"></a>c = (int *) ((char *) c + 1) 与c=c+1的区别</h5><p><img src="https://s2.loli.net/2022/05/17/8CJDEayGtXoR3wp.png" alt="image-20220517161940295"></p>
<img src="https://s2.loli.net/2022/05/17/lh1UiAVvbOWjLay.png" alt="image-20220517162003852" style="zoom:67%;" />

<p>转换为char后，c只向前移动了1位，即八个bit。</p>
<p>*c=500，将灰色框内的值变为500.</p>
<img src="https://s2.loli.net/2022/05/17/4WlqerkMhyTUCsc.png" alt="image-20220517162103314" style="zoom:67%;" />

<p><strong>其他</strong><br>如果int *p=(int*)100,则(int)p+1和(int)(p+1)不同，前者是101，但后者是104。当指针加整数时，向第二个例子，整数隐式乘以指针所指向的对象的大小。<br>p[i]定义为和*(p+i)相同，代表p指向的内存的第i个对象，当对象大于1字节时，这条规则起作用<br>&amp;p[i]和(p+i)相同，代表p指向的内存的第i个对象的地址<br>在对内存地址进行加法时，要确定他是<strong>integer addition or pointer addition</strong></p>
<p>ref: <a target="_blank" rel="noopener" href="https://blog.csdn.net/han_hhh/article/details/121701438">https://blog.csdn.net/han_hhh/article/details/121701438</a></p>
<h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p>内核的文件头:</p>
<img src="https://s2.loli.net/2022/05/18/FfUZ5AkPBcNlCJV.png" alt="image-20220518152817746" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/18/myS4R9jDwvfcAJp.png" alt="image-20220518152831699" style="zoom:67%;" />

<p>得到了<code>Program Header</code>文件头，上面省略了余下的一些输出内容。每个<code>LOAD</code>都是一个<code>ELF</code>对象，里面包含了相对本文件的索引<code>off</code>、虚拟内址<code>vaddr</code>、物理地址<code>paddr</code>、对齐<code>align</code>、对象在文件和内存中的大小<code>filesz, memsz</code>。</p>
<p>这个<code>header</code>在<code>bootmain</code>函数中通过<code>readseg</code>函数加载到了内存中，位置在<code>0x10000</code>，并通过一个宏<code>ELFHDR</code>索引。<code>header</code>中存放的数据采用的是默认的对齐方式，所以可以直接通过一个<code>struct Elf</code>指针访问各个属性。</p>
<img src="https://s2.loli.net/2022/05/23/UxAbKhYMcvPr9Wl.png" alt="image-20220518153305171" style="zoom: 50%;" />

<p>在文件头<code>struct Elf</code>中，我们拿到了关于结构体<code>struct Proghdr</code>数组的信息<code>e_phoff</code>。从这个数组的成员中，我们拿到了关于每个<code>segment</code>的信息，也就可以把它们正式从硬盘中拷贝到内存中的指定位置。</p>
<img src="https://s2.loli.net/2022/05/23/3eNXsKyhPwFnWx9.png" alt="image-20220518153337802" style="zoom:50%;" />

<p>第一个<code>segment</code>对象的地址存放在<code>ELFHDR-&gt;e_phoff</code>中，是从硬盘中读入的原始数据。转化为指针如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br></pre></td></tr></table></figure>

<p>也就是加上了一个偏置。同样利用<code>elf</code>文件的数据，查出这个“对象数组”的长度，也就可以遍历这个<code>Proghdr</code>数组了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure>

<p><code>ph</code>是个<code>struct Proghdr</code>类型的指针，直接<code>++</code>让地址的值前进相应地址长度，非常方便。</p>
<p>至此，内核完全加载完毕。</p>
<p><img src="https://s2.loli.net/2022/05/18/WKgHeMSYBt3UV8O.png" alt="image-20220518154931248"></p>
<img src="https://s2.loli.net/2022/05/23/bziYmGwcqngRQoB.png" alt="image-20220518170934792" style="zoom: 67%;" />

<img src="https://s2.loli.net/2022/05/18/rNBvldLZ7WUufDe.png" alt="image-20220518170900480" style="zoom: 67%;" />

<p>获取kernel ELF文件的相关信息：</p>
<img src="https://s2.loli.net/2022/05/23/j4RoMerFKCsSQVd.png" alt="image-20220518173511422" style="zoom:67%;" />

<p>可看到程序入口的虚拟地址是0x10000c，程序头表偏移为52B，程序头表条目是2.</p>
<p><strong>如果你得到一个错误的引导加载器链接地址，通过再次跟踪引导加载器的前几个指令，你将会发现第一个指令会 “中断” 或者出错。然后在 <code>boot/Makefrag</code> 修改链接地址来修复错误，运行 <code>make clean</code>，使用 <code>make</code> 重新编译，然后再次跟踪引导加载器去查看会发生什么事情。不要忘了改回正确的链接地址，然后再次 <code>make clean</code>！</strong></p>
<p><img src="https://s2.loli.net/2022/05/18/vPznfE9bwAKSF4N.png" alt="image-20220518181251389"></p>
<p>修改0x7C00为0x7d00，使得bootloader无法正确加载。</p>
<p><img src="https://s2.loli.net/2022/05/18/roiDh2v3TskuRAx.png" alt="image-20220518181451276"></p>
<p><strong>可能</strong>就是GDT表加载错误才导致后面加载失败，因为加载信息都错掉了。</p>
<h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><p>在BIOS进入 the boot loader时检查内存0x00100000处的8个字，然后在 the boot loader进入内核时再检查一次。</p>
<p><img src="https://s2.loli.net/2022/05/18/D2cVRnXdpaiI5eP.png" alt="image-20220518185538199"></p>
<p><img src="https://s2.loli.net/2022/05/18/CXgSuAbDTMUPWNm.png" alt="image-20220518185555496"></p>
<p>0x00100000往后8个字前后不一样应该是由于bootmain将内核的某个section存入了该地址处。由于要在进入内核时再看一次，故第二个断点应该设置在call entry处，<br>即 *<em>b <em>0x7d69</em></em></p>
<p><img src="https://s2.loli.net/2022/05/18/ylz7Vrp5APt4Roh.png" alt="image-20220518185643002"></p>
<p><strong>内核的入口地址是0x0010000c，也在此范围中，可能是.text段的内容，因为内核最先加载的就是.text</strong></p>
<p>➜  lab git:(lab1) objdump -x obj/kern/kernel </p>
<p>obj/kern/kernel:     file format elf32-i386<br>obj/kern/kernel<br>architecture: i386, flags 0x00000112:<br>EXEC_P, HAS_SYMS, D_PAGED<br>start address 0x0010000c</p>
<p>Program Header:<br>    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 212<br>         filesz 0x0000ee68 memsz 0x0000ee68 flags r-x<br>    LOAD off    0x00010000 vaddr 0xf010f000 paddr 0x0010f000 align 212<br>         filesz 0x0000a948 memsz 0x0000a948 flags rw-</p>
<p>Sections:<br>Idx Name          Size      VMA       LMA       File off  Algn<br>  0 .text         0000178e  f0100000  00100000  00001000  22<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br>  1 .rodata       00000704  f01017a0  001017a0  000027a0  25<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  2 .stab         000044d1  f0101ea4  00101ea4  00002ea4  22<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  3 .stabstr      00008af3  f0106375  00106375  00007375  20<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  4 .data         0000a300  f010f000  0010f000  00010000  212<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  5 .bss          00000648  f0119300  00119300  0001a300  25<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  6 .comment      00000011  00000000  00000000  0001a948  20<br>                  CONTENTS, READONLY</p>
<h1 id="The-kernel"><a href="#The-kernel" class="headerlink" title="The kernel"></a>The kernel</h1><h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><p>在0x0010000c处打上断点，si单步执行，直到 movl %eax, %cr0 前一步</p>
<img src="https://s2.loli.net/2022/05/22/JjV2Gl3Uy1RQ8Np.png" alt="image-20220522172810387" style="zoom:67%;" />

<p>查看0x00100000 和 0xf0100000 的内容</p>
<img src="https://s2.loli.net/2022/05/23/PBqscTj9QwiO4ed.png" alt="image-20220522172955485" style="zoom:67%;" />

<p>执行movl %eax, %cr0 ， 再次查看内容</p>
<p><img src="https://s2.loli.net/2022/05/22/B3xzQXu8ldivrNK.png" alt="image-20220522173104250"></p>
<p>发现VMA和LMA有相同的内容，这是因为分页后，0x00100000 被映射到了 0xf0100000 处，完成了分页操作。</p>
<p>make clean 后，注释掉movl %eax, %cr0  （kern/entry.S）</p>
<p>重新运行</p>
<img src="https://s2.loli.net/2022/05/22/46IQNuzcP17HJ8C.png" alt="image-20220522194929977" style="zoom:67%;" />

<p>qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log  -S<br><strong>qemu: fatal: Trying to execute code outside RAM or ROM at 0xf010002c</strong></p>
<p>EAX=f010002c EBX=00010074 ECX=00000000 EDX=000000d5<br>ESI=00010074 EDI=00000000 EBP=00007bf8 ESP=00007bec<br>EIP=f010002c EFL=00000086 [–S–P-] CPL=0 II=0 A20=1 SMM=0 HLT=0<br>ES =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>CS =0008 00000000 ffffffff 00cf9a00 DPL=0 CS32 [-R-]<br>SS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>DS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>FS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>GS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>LDT=0000 00000000 0000ffff 00008200 DPL=0 LDT<br>TR =0000 00000000 0000ffff 00008b00 DPL=0 TSS32-busy<br>GDT=     00007c4c 00000017<br>IDT=     00000000 000003ff<br>CR0=00000011 CR2=00000000 CR3=00117000 CR4=00000000<br>DR0=00000000 DR1=00000000 DR2=00000000 DR3=00000000<br>DR6=ffff0ff0 DR7=00000400<br>CCS=00000084 CCD=80010011 CCO=EFLAGS<br>EFER=0000000000000000<br>FCW=037f FSW=0000 [ST=0] FTW=00 MXCSR=00001f80<br>FPR0=0000000000000000 0000 FPR1=0000000000000000 0000<br>FPR2=0000000000000000 0000 FPR3=0000000000000000 0000<br>FPR4=0000000000000000 0000 FPR5=0000000000000000 0000<br>FPR6=0000000000000000 0000 FPR7=0000000000000000 0000<br>XMM00=00000000000000000000000000000000 XMM01=00000000000000000000000000000000<br>XMM02=00000000000000000000000000000000 XMM03=00000000000000000000000000000000<br>XMM04=00000000000000000000000000000000 XMM05=00000000000000000000000000000000<br>XMM06=00000000000000000000000000000000 XMM07=00000000000000000000000000000000<br>make: *** [qemu-nox-gdb] Aborted (core dumped)</p>
<p><strong>由于未开启分页机制，虚拟地址还未映射到物理地址。</strong></p>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><p>补全”%o”</p>
<img src="https://s2.loli.net/2022/05/23/bMnKRuqGXZOvY2l.png" alt="image-20220522213815891" style="zoom:67%;" />

<h4 id="problem-1"><a href="#problem-1" class="headerlink" title="problem 1"></a>problem 1</h4><p>解释<code>printf.c</code>和 <code>console.c</code>之间的接口。<code>具体来说， console.c</code>导出什么函数 ？<code>printf.c</code>如何使用这个函数 ？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// printf.c</span></span><br><span class="line"><span class="comment">// Simple implementation of cprintf console output for the kernel,</span></span><br><span class="line"><span class="comment">// based on printfmt() and the kernel console&#x27;s cputchar().</span></span><br><span class="line"><span class="comment">//为内核简单实现cprintf控制台输出，</span></span><br><span class="line"><span class="comment">//基于printfmt（）和内核控制台的cputchar（）。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">putch</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> *cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cputchar(ch);</span><br><span class="line">   *cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vcprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   vprintfmt((<span class="keyword">void</span>*)putch, &amp;cnt, fmt, ap);</span><br><span class="line">   <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">cprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   va_list ap;</span><br><span class="line">   <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">   va_start(ap, fmt);</span><br><span class="line">   cnt = vcprintf(fmt, ap);</span><br><span class="line">   va_end(ap);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/05/23/sLTgyRwqYd8EJcI.png" alt="image-20220522214112303" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/dJMHKFrN9vZ5t4a.png" alt="image-20220522214134785" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 03FD    r  line status register</span></span><br><span class="line"><span class="comment">       bit 7 = 0  reserved</span></span><br><span class="line"><span class="comment">       bit 6 = 1  transmitter shift and holding registers empty</span></span><br><span class="line"><span class="comment">       bit 5 = 1  transmitter holding register empty. Controller is</span></span><br><span class="line"><span class="comment">             ready to accept a new character to send.</span></span><br><span class="line"><span class="comment">       bit 4 = 1  break interrupt. the received data input is held in</span></span><br><span class="line"><span class="comment">             in the zero bit state longer than the time of start</span></span><br><span class="line"><span class="comment">             bit + data bits + parity bit + stop bits.</span></span><br><span class="line"><span class="comment">       bit 3 = 1  framing error. the stop bit that follows the last</span></span><br><span class="line"><span class="comment">             parity or data bit is a zero bit.</span></span><br><span class="line"><span class="comment">       bit 2 = 1  parity error. Character has wrong parity</span></span><br><span class="line"><span class="comment">       bit 1 = 1  overrun error. a character was sent to the receiver</span></span><br><span class="line"><span class="comment">             buffer before the previous character in the buffer</span></span><br><span class="line"><span class="comment">             could be read. This destroys the previous</span></span><br><span class="line"><span class="comment">             character.</span></span><br><span class="line"><span class="comment">       bit 0 = 1  data ready. a complete incoming character has been</span></span><br><span class="line"><span class="comment">             received and sent to the receiver buffer register.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">serial_putc</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// COM1 = 0x3F8, COM_LSR(Line Status Register) = 5, COM_LSR_TXRDY(传输缓冲区) = 0x20,</span></span><br><span class="line">    <span class="comment">// 0x03F8 + 5  =&gt; 0x03FD   0x03FD &amp; 0x20(0010 0000) =&gt; 取 bit 5</span></span><br><span class="line">    <span class="comment">// bti 5 = 1 :</span></span><br><span class="line">    <span class="comment">// transmitter holding register empty. Controller is ready to accept a new character to send.</span></span><br><span class="line">    <span class="comment">// 如果bit 5 = 1，那么传输方寄存器已空，controller可以接受一个新的字符了</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>;</span><br><span class="line">        !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="number">12800</span>;  <span class="comment">// bit 5 != 1  &amp;&amp; 没超时</span></span><br><span class="line">        i++)</span><br><span class="line">      delay();</span><br><span class="line">    <span class="comment">//COM_TX = 0    Out: Transmit buffer</span></span><br><span class="line">    <span class="comment">//serial_putc()函数的功能首先就是在bit 5 =1 的时候，跳出循环，否则只要 i &lt;12800就会一直循环等待。</span></span><br><span class="line">   outb(COM1 + COM_TX, c);   <span class="comment">// 将c写入I/O端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** Parallel port output code *****/</span></span><br><span class="line"><span class="comment">// For information on PC parallel port programming, see the class References</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">// 并行端口输入</span></span><br><span class="line"><span class="comment">/* 0x378~0x37A parallel printer port</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0378    w    data port</span></span><br><span class="line"><span class="comment">0379    r/w    status port</span></span><br><span class="line"><span class="comment">         bit 7 = 0 busy * 0x80</span></span><br><span class="line"><span class="comment">         bit 6 = 0 acknowledge</span></span><br><span class="line"><span class="comment">         bit 5 = 1 out of paper</span></span><br><span class="line"><span class="comment">         bit 4 = 1 printer is selected</span></span><br><span class="line"><span class="comment">         bit 3 = 0 error</span></span><br><span class="line"><span class="comment">         bit 2 = 0 IRQ has occurred</span></span><br><span class="line"><span class="comment">         bit 1-0 reserved</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">037A    r/w    control port</span></span><br><span class="line"><span class="comment">         bit 7-5 reserved</span></span><br><span class="line"><span class="comment">         bit 4 = 1 enable IRQ</span></span><br><span class="line"><span class="comment">         bit 3 = 1 select printer    * 0x08</span></span><br><span class="line"><span class="comment">         bit 2 = 0 initialize printer *0x04</span></span><br><span class="line"><span class="comment">         bit 1 = 1 automatic line feed</span></span><br><span class="line"><span class="comment">         bit 0 = 1 strobe        * 0x01</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">lpt_putc</span><span class="params">(<span class="keyword">int</span> c)</span>   <span class="comment">// 并行端口输入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 0x379 &amp; 0x80   读取0x379的内容，和0x80相与，取bits 7，判断是否繁忙</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; !(inb(<span class="number">0x378</span>+<span class="number">1</span>) &amp; <span class="number">0x80</span>) &amp;&amp; i &lt; <span class="number">12800</span>; i++)   <span class="comment">// io端口不繁忙且未超时，一直等待，直到使用了端口或等待时间到</span></span><br><span class="line">      delay();</span><br><span class="line">   outb(<span class="number">0x378</span>+<span class="number">0</span>, c);  <span class="comment">// write char c</span></span><br><span class="line">   outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>|<span class="number">0x04</span>|<span class="number">0x01</span>);   <span class="comment">//初始化 printer</span></span><br><span class="line">   outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>);  <span class="comment">// 选择 printer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">cga_putc</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// if no attribute given, then use black on white</span></span><br><span class="line">    <span class="comment">// 如果没有给定属性，则使用黑白相间的颜色</span></span><br><span class="line">   <span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>))    <span class="comment">// c 低16位为字符值，高16位为显示属性</span></span><br><span class="line">      c |= <span class="number">0x0700</span>;</span><br><span class="line">    <span class="comment">// crt_pos:当前输出位置指针，指向内存区中对应输出映射地址。</span></span><br><span class="line">   <span class="keyword">switch</span> (c &amp; <span class="number">0xff</span>) &#123;    <span class="comment">// 取低16位</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>:   <span class="comment">// backspace</span></span><br><span class="line">      <span class="keyword">if</span> (crt_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         crt_pos--;</span><br><span class="line">         crt_buf[crt_pos] = (c &amp; ~<span class="number">0xff</span>) | <span class="string">&#x27; &#x27;</span>;  <span class="comment">// 删除处使用&#x27; &#x27;填充</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:    <span class="comment">// //new line：换行, 自动添加回车</span></span><br><span class="line">      crt_pos += CRT_COLS;   <span class="comment">// CRT_COLS默认输出格式下整个屏幕的列数，为80。</span></span><br><span class="line">        <span class="comment">// CRT_ROWS:默认输出格式下整个屏幕的行数，为25。</span></span><br><span class="line">      <span class="comment">/* fallthru */</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">      crt_pos -= (crt_pos % CRT_COLS);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:  <span class="comment">// tab  转换为五个 &#x27; &#x27;</span></span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      crt_buf[crt_pos++] = c;       <span class="comment">/* write the character */</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// What is the purpose of this?</span></span><br><span class="line">    <span class="comment">// CRT_SIZE:是CRT_COLS和CRT_ROWS的乘积，即2000=80*25，是不翻页时一页屏幕最大能容纳的字数。</span></span><br><span class="line">    <span class="comment">// 当前屏幕写满了，</span></span><br><span class="line">   <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 函数：memmove(): memmove(void *dst, const void *src, size_t n).</span></span><br><span class="line"><span class="comment">         * 意为将从src指向位置起的n字节数据送到dst指向位置，可以在两个区域重叠时复制。</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">// 所有数据向前挪动一行，最上面一行数据丢失</span></span><br><span class="line">      memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">      <span class="comment">// 清空最后一行，用空格填充</span></span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">         crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      crt_pos -= CRT_COLS;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 写光标位置</span></span><br><span class="line">   <span class="comment">/* move that little blinky thing */</span></span><br><span class="line">   outb(addr_6845, <span class="number">14</span>);</span><br><span class="line">   outb(addr_6845 + <span class="number">1</span>, crt_pos &gt;&gt; <span class="number">8</span>);</span><br><span class="line">   outb(addr_6845, <span class="number">15</span>);</span><br><span class="line">   outb(addr_6845 + <span class="number">1</span>, crt_pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="problem-2"><a href="#problem-2" class="headerlink" title="problem 2"></a>problem 2</h4><ol>
<li><p>从console.c</p>
<p>解释以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1      if (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">2              int i;</span><br><span class="line">3              memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));</span><br><span class="line">4              for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">5                      crt_buf[i] = 0x0700 | &#x27; &#x27;;</span><br><span class="line">6              crt_pos -= CRT_COLS;</span><br><span class="line">7      &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>见上</p>
<h4 id="problem-3"><a href="#problem-3" class="headerlink" title="problem 3"></a>problem 3</h4><ol>
<li><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</p>
<p>Trace the execution of the following code step-by-step:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = 1, y = 3, z = 4;</span><br><span class="line">cprintf(&quot;x %d, y %x, z %d\n&quot;, x, y, z);</span><br></pre></td></tr></table></figure>

<ul>
<li>In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</li>
<li>List (in order of execution) each call to <code>cons_putc</code>, <code>va_arg</code>, and <code>vcprintf</code>. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what <code>ap</code> points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</li>
</ul>
</li>
</ol>
<p>对于以下问题，您可能希望查阅第 2 讲的注释。这些注释涵盖了 GCC 在 x86 上的调用约定。</p>
<p>逐步跟踪以下代码的执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = 1, y = 3, z = 4;</span><br><span class="line">cprintf(&quot;x %d, y %x, z %d\n&quot;, x, y, z);</span><br></pre></td></tr></table></figure>

<h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><ul>
<li>在调用 to<code>cprintf()</code>时，<code>fmt</code>指向什么？<code>ap</code>指向什么？</li>
<li>列出（按执行顺序）对<code>cons_putc</code>、<code>va_arg</code>和 <code>vcprintf</code>的每个调用。对于<code>cons_putc</code>，也列出它的argument。对于 <code>va_arg</code>，列出<code>ap</code>调用前后所指向的内容。列出它的两个参数的<code>vcprintf</code>值。</li>
</ul>
<p>将代码复制到该位置</p>
<img src="https://s2.loli.net/2022/05/23/gJmLk95Ce7Z2jb8.png" alt="image-20220522214913927" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/M9Fv2azChmu6XpU.png" alt="image-20220522215011773" style="zoom:67%;" />

<p>在gdb给该行打断点</p>
<p><img src="https://s2.loli.net/2022/05/22/CJT36u1powsZPjS.png" alt="image-20220522215850429"></p>
<p>disassemble 反汇编当前代码段的部分指令</p>
<p><img src="https://s2.loli.net/2022/05/22/Z6QbjgWxeX21oCU.png" alt="image-20220522215943610"></p>
<p>在kernel.asm中查找该地址</p>
<p>（vim命令模式下，/+查找字符是向下查找，?是向上查找。 如果你要继续查找此关键字，敲字符n就可以继续查找了）</p>
<img src="https://s2.loli.net/2022/05/22/T4gfBOJXFW8Rjid.png" alt="image-20220522220412446" style="zoom: 67%;" />

<p>call 0xf0100906 &lt;cprintf&gt;</p>
<img src="https://s2.loli.net/2022/05/23/jCSTbcLE8UJzdRV.png" alt="image-20220522221005338" style="zoom:67%;" />

<p>va_start，函数名称，读取可变参数的过程其实就是在栈区中，使用指针,遍历栈区中的参数列表,从低地址到高地址一个一个地把参数内容读出来的过程·</p>
<p>可以看到 fmt 是 cprintf 函数的第一个参数，即指向字符串<code>&quot;x %d, y %x, z %d\n&quot;</code>的指针。</p>
<p>ap 指向第二个参数的地址。<strong>注意 ap 中存放的是第二个参数的地址，而非第二个参数。</strong></p>
<img src="https://s2.loli.net/2022/05/22/HJTjCcetVzk7buf.png" alt="image-20220522221407297" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/22/MQk6y5TJuNXf3Yz.png" alt="image-20220522221535010" style="zoom:67%;" />

<h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><p>调用关系为 cprintf -&gt; vcprintf -&gt; vprintfmt -&gt; putch -&gt; cputchar -&gt; cons_putc</p>
<p>接上图，可以看到vpprintf后是vprintfmt</p>
<p><img src="https://s2.loli.net/2022/05/22/RsxIbcmhAouZWJ1.png" alt="image-20220522222019680"></p>
<p><img src="https://s2.loli.net/2022/05/22/BlO5HewtJvWUdRG.png" alt="image-20220522222138140"></p>
<p>之后，vprintfmt依次调用putch和cputchar</p>
<p><img src="https://s2.loli.net/2022/05/22/84lAVsnb9TUjMvf.png" alt="image-20220522222344930"></p>
<p>cputchar调用 cons_putc</p>
<p><img src="https://s2.loli.net/2022/05/22/gNm5rjRT9S6iIWl.png" alt="image-20220522222504049"></p>
<img src="https://s2.loli.net/2022/05/22/IoJriQZ5zH7v9k4.png" alt="image-20220522222602885" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/NVXpFGzkdOghPEJ.png" alt="image-20220522222620191" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/6yoTIQYmvVL3USq.png" alt="image-20220522222706554" style="zoom:67%;" />

<p>0xf010022b之后，    准备输出</p>
<img src="https://s2.loli.net/2022/05/22/CREO15lqh9NfXDg.png" alt="image-20220522223041430" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/05/23/sNVe8uUR5aiJzMx.png" alt="image-20220522223632755" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/05/22/TSWJcyAMg6GzNZ1.png" alt="image-20220522223329251" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/8BRwLbQqtJD2O93.png" alt="image-20220522223357850" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/Sy7DiNdcsqnoR9Q.png" alt="image-20220522223512459" style="zoom:67%;" />

<p>120，32,  49， 44， 32， 121， 32， 51， 44， 32， 122， 32， 52， 10</p>
<p>ascii 码转换为char</p>
<img src="https://s2.loli.net/2022/05/22/m1pUGnx78lB5VjP.png" alt="image-20220522223726095" style="zoom: 67%;" />

<p><img src="https://s2.loli.net/2022/05/22/BUn6TOxev9pg3ul.png" alt="image-20220522223755233"></p>
<h4 id="problem-4"><a href="#problem-4" class="headerlink" title="problem 4"></a>problem 4</h4><p>Run the following code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise.</p>
<p>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<p><img src="https://s2.loli.net/2022/05/23/3SezlGXtE7gMcTD.png" alt="image-20220523130430575"></p>
<img src="https://s2.loli.net/2022/05/23/8fuNUjOd9vnQEkH.png" alt="image-20220523131152245" style="zoom:80%;" />

<img src="https://s2.loli.net/2022/05/23/LZHfOB14oKDQedl.png" alt="image-20220523131208149" style="zoom:80%;" />

<img src="https://s2.loli.net/2022/06/03/Az8IQt2FhgD73d1.png" alt="image-20220523131709311" style="zoom:67%;" />

<p>71, 101, 49, 49, 48, 32, 87, 111, 114, 108, 100</p>
<p>He110 World</p>
<img src="https://s2.loli.net/2022/05/23/nrQyBk9HSv85XWC.png" alt="image-20220523131908104" style="zoom:67%;" />

<p>%x 指无符号十六进制数</p>
<img src="https://s2.loli.net/2022/06/03/EPGICj2LrVmTzqt.png" alt="image-20220523133643397" style="zoom:67%;" />

<p>57616转换为16进制，正好是e110</p>
<p>%s指字符串，0x00646c72在小端模式下对应的ASCII码为 0x72, 0x6c, 0x64, 0x00, 可得’rld’</p>
<p>如果是在大端 (big endian) 模式下要得到同样的输出，应该改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x726c6400</span>;</span><br><span class="line"><span class="built_in">cprintf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<h4 id="problem-5"><a href="#problem-5" class="headerlink" title="problem 5"></a>problem 5</h4><p>In the following code, what is going to be printed after ‘ y= ‘ ? (note: the answer is not a specific value.) Why does this happen?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/05/23/ioOsFIc4qzEX5gC.png" alt="image-20220523141401716" style="zoom:67%;" />

<p><img src="https://s2.loli.net/2022/05/23/2GnipTQcFz5Rul4.png" alt="image-20220523144320399"></p>
<p>y的值没有给定，所以输出一个不确定的值</p>
<h4 id="problem-6"><a href="#problem-6" class="headerlink" title="problem 6"></a>problem 6</h4><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p>
<h1 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h1><h3 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h3><p>确定内核初始化堆栈的位置，以及堆栈在内存中的确切位置。内核如何为其堆栈保留空间？堆栈指针初始化为指向该保留区域的哪一端？</p>
<img src="https://s2.loli.net/2022/05/23/2WT6iQGvJsgpR3a.png" alt="image-20220523172823907" style="zoom: 50%;" />

<p>bootstacktop是栈顶，地址为0xf0117000</p>
<p>mmu.h中</p>
<img src="https://s2.loli.net/2022/05/23/ZEQK9WBALjIfe3k.png" alt="image-20220523174049954" style="zoom:80%;" />

<p>memlayout.h</p>
<img src="https://s2.loli.net/2022/05/23/XgPc52kHWMnfwiD.png" alt="image-20220523174104956" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/zl42JmAv5B7cjV1.png" alt="image-20220523174140644" style="zoom:67%;" />

<p>栈大小是32KB，栈顶指针存在esp，为 0xf0117000</p>
<img src="https://s2.loli.net/2022/05/23/zahDgVRnyj6U9Od.png" alt="image-20220523174417402" style="zoom:67%;" />

<h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><p>要熟悉x86上的C调用约定，请在<strong>obj/kern/kernel.asm</strong>中找到<strong>test_backtrace</strong>函数的地址，在那里设置一个断点，并检查内核启动后每次调用它时会发生什么。test_backtrace的每个递归嵌套级别在堆栈上推送多少32位字，这些字是什么？</p>
<p><img src="https://s2.loli.net/2022/05/28/nZ2YagVsuP9FXSW.png" alt="image-20220528164332775"></p>
<p>给back_trace的test_backtrace(x-1); mon_backtrace(0, 0, 0);和 打上断点，    查看<code>esp</code>的初始值。</p>
<p><img src="https://s2.loli.net/2022/05/28/MjnGhxmEktR2NWP.png" alt="image-20220528165206593"></p>
<p>初始x传入值为5，向后执行直至x=0</p>
<p><img src="https://s2.loli.net/2022/05/28/Dsg8NQlOAvY2otG.png" alt="image-20220528171319674"></p>
<p>中途查看esp内容，发现第二列保存的是x的值。每次递归会保存两行。每一列的意思是</p>
<p><img src="https://s2.loli.net/2022/05/28/WKwp2NxBIPHaAX8.png" alt="image-20220528210745786"></p>
<p><img src="https://s2.loli.net/2022/05/28/hxk1DYoTrZwpB2P.png" alt="image-20220528211308210"></p>
<p><strong>x86堆栈要倒着长，如果以为push以后esp会增加可就大错特错了。。ebp虽然叫栈底，但是永远大于等于栈顶</strong></p>
<p>0xf0100069应该是test_backtrace的下一条的返回地址。</p>
<p><img src="https://s2.loli.net/2022/06/03/e9OsqWFKYv81B76.png" alt="image-20220528180523233"></p>
<p>test_backtrace(5)的栈帧范围是：esp: 0xf0116fc0      ebp: 0xf0116fc8</p>
<p>test_backtrace(4):   esp: 0xf0116fa0      ebp: 0xf0116fa8</p>
<p>test_backtrace(3):   esp: 0xf0116f80      ebp: 0xf0116f88</p>
<p>test_backtrace(2):   esp: 0xf0116f60      ebp: 0xf0116f68</p>
<p>test_backtrace(1):   esp: 0xf0116f40      ebp: 0xf0116f48</p>
<p>next x           |       this x     |    don’t know  | don’t know  | </p>
<p>don’t know  |        last  x   |     last ebp       |  return addr|</p>
<h3 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h3><p>implement a stack backtrace function</p>
<p>The backtrace function should display a listing of function call frames in the following format:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span><br><span class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>Each line contains an <code>ebp</code>, <code>eip</code>, and <code>args</code>.</p>
<p>运行 <code>make grade</code> 这个评级脚本去查看它的输出是否是我们的脚本所期望的结果/。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C函数调用时，首先将参数push入栈，然后push返回地址，接着将原来的EBP push入栈，然后将ESP的值赋给EBP，令ESP指向新的栈顶。而函数返回时，会将EBP的值赋予ESP，然后pop出原来的EBP的值赋予EBP指针。</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/05/28/SIWUp2ahfZOP4t8.png" alt="image-20220528223530430"></p>
<img src="https://s2.loli.net/2022/05/28/bVInmrfcN6YsqjB.png" alt="image-20220528223513219" style="zoom:67%;" />

<h3 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h3><p>修改堆栈回溯函数以显示每个<code>eip</code>对应的函数名、源文件名和行<code>号</code>。</p>
<p>在<code>debuginfo_eip</code>中，<code>__STAB_*</code>来自哪里？这个问题有一个很长的答案；为了帮助您找到答案，以下是您可能想做的一些事情：</p>
<ul>
<li>look in the file <code>kern/kernel.ld</code> for <code>__STAB_*</code></li>
<li>run objdump -h obj/kern/kernel</li>
<li>run objdump -G obj/kern/kernel</li>
<li>run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s.</li>
<li>see if the bootloader loads the symbol table in memory as part of loading the kernel binary</li>
</ul>
<p>向内核监视器添加一个<code>backtrace </code>命令，并扩展您的实现<code>mon_backtrace</code>以调用<code>debuginfo_eip</code>并打印表单的每个堆栈帧的一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">K&gt; backtrace</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000</span><br><span class="line">         kern/monitor.c:143: monitor+106</span><br><span class="line">  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000</span><br><span class="line">         kern/init.c:49: i386_init+59</span><br><span class="line">  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff</span><br><span class="line">         kern/entry.S:70: &lt;unknown&gt;+0</span><br><span class="line">K&gt; </span><br></pre></td></tr></table></figure>

<p>Each line gives the file name and line within that file of the stack frame’s <code>eip</code>, followed by the name of the function and the offset of the <code>eip</code> from the first instruction of the function (e.g., <code>monitor+106</code> means the return <code>eip</code> is 106 bytes past the beginning of <code>monitor</code>).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Include debugging information in kernel memory */</span></span><br><span class="line">.stab : &#123;</span><br><span class="line">	PROVIDE(__STAB_BEGIN__ = .);</span><br><span class="line">	*(.stab);</span><br><span class="line">	PROVIDE(__STAB_END__ = .);</span><br><span class="line">	BYTE(<span class="number">0</span>)		<span class="comment">/* Force the linker to allocate space</span></span><br><span class="line"><span class="comment">			   for this section */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.stabstr : &#123;</span><br><span class="line">	PROVIDE(__STABSTR_BEGIN__ = .);</span><br><span class="line">	*(.stabstr);</span><br><span class="line">	PROVIDE(__STABSTR_END__ = .);</span><br><span class="line">	BYTE(<span class="number">0</span>)		<span class="comment">/* Force the linker to allocate space</span></span><br><span class="line"><span class="comment">			   for this section */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/05/28/WMQfEjbsJgDlU4S.png" alt="image-20220528230025894"></p>
<p>可以得到stab和 stabstr的起始地址和结束地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__STAB_BEGIN__ = 0xf0101f2c</span><br><span class="line">__STAB_END__ = 0xf0101f2c + 00004549 - 1</span><br><span class="line">__STABSTR_BEGIN__ = 0xf0106475</span><br><span class="line">__STABSTR_END__ = 0xf0106475 + 00008b11 - 1</span><br></pre></td></tr></table></figure>

<p>objdump -G obj/kern/kernel 列出所有stab的信息</p>
<p><img src="https://s2.loli.net/2022/06/03/wJ6T2spyFvP7DxI.png" alt="image-20220528230955470"></p>
<p>进入内核后打个断点，查看stabstr内的内容</p>
<p><img src="https://s2.loli.net/2022/05/28/FszN2t4h6bVH3nG.png" alt="image-20220528232511341"></p>
<p>使用<code>objdump -G obj/kern/kernel &gt; output.md</code>将内核的符号表信息输出到output.md文件</p>
<p><img src="https://s2.loli.net/2022/06/03/oLO9PpUryhDSVeE.png" alt="image-20220603142339089"></p>
<p>观察kernel.asm</p>
<p><img src="https://s2.loli.net/2022/06/03/9I7hWzcHuRLlPUs.png" alt="image-20220603142401904"></p>
<p>观察entry.S</p>
<p><img src="https://s2.loli.net/2022/06/03/Cv6OTo4a31SArkx.png" alt="image-20220603142437259"></p>
<p>可以看到，output.md 中的各个字段，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symnum   下标，整个符号表看作一个数组，Symnum是当前符号在数组中的下标</span><br><span class="line">n_type   符号类型，FUN指函数名，SLINE指在text段中的行号</span><br><span class="line">n_othr   不清楚</span><br><span class="line">n_desc   在文件中的行号</span><br><span class="line">n_value  表示地址</span><br><span class="line">n_strx   </span><br><span class="line">String   保存信息（函数、语句啥的）</span><br></pre></td></tr></table></figure>

<p>在查看<code>kdebug.c</code>时候发现函数的参数为<code>int</code>类型，但是传入是<code>N_FUN</code>，于是翻了一下<code>stab.h</code></p>
<p><img src="https://s2.loli.net/2022/06/03/U61vX4bqchRWj37.png" alt="image-20220603145602882"></p>
<p>修改monitor.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> ebp;</span><br><span class="line">    <span class="keyword">uint32_t</span>* eip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    ebp = read_ebp();</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="comment">// ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span></span><br><span class="line">    <span class="comment">// eip = *(uint32_t *(ebp + 4))</span></span><br><span class="line">    <span class="keyword">while</span>(ebp != <span class="number">0</span>)&#123;</span><br><span class="line">        eip = (<span class="keyword">uint32_t</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 08x   八位宽无符号16进制</span></span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>,</span><br><span class="line">                ebp, eip[<span class="number">0</span>], eip[<span class="number">1</span>], eip[<span class="number">2</span>], eip[<span class="number">3</span>], eip[<span class="number">4</span>], eip[<span class="number">5</span>]);</span><br><span class="line">        <span class="comment">// 打印行号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(debuginfo_eip(eip[<span class="number">0</span>], &amp;info)==<span class="number">0</span>)&#123;</span><br><span class="line">            cprintf(<span class="string">&quot;    %s:%d: %s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_name, eip[<span class="number">0</span>] - info.eip_fn_addr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取 ebp的 内容  返回</span></span><br><span class="line">        ebp = *((<span class="keyword">uint32_t</span> *) ebp);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/06/03/Ol4sxCRFyk765Z3.png" alt="image-20220603161956295"></p>
<p>可以看到后续多了<code>:F(0,15)</code></p>
<p>那么需要输出指定长度，以便把后面多余的字符删除。test_backtrace 和 i386_init 为函数名</p>
<p><img src="https://s2.loli.net/2022/06/03/ZtsXhU9qlTwdf5D.png" alt="image-20220603162303721"></p>
<p>使用<code>eip_fn_namelen</code>进行指定长度的输出</p>
<p>修改为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;    %s:%d: %.*s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, eip[<span class="number">0</span>] - info.eip_fn_addr);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/06/03/b5VjniJfOaTDpmW.png" alt="image-20220603162648588"></p>
<p>正常输出</p>
<p><code>make grade</code></p>
<p><img src="https://s2.loli.net/2022/06/03/YsG4kSha2vADzR7.png" alt="image-20220603162723295"></p>
<h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><ol>
<li>启动顺序   bios-&gt;bootloader-&gt;kernel</li>
</ol>
<p>bios: </p>
<p>0x000FFFFF~0x0010 0000</p>
<p>bootloader:</p>
<p>sectorsize(扇区大小)是512</p>
<p><img src="https://s2.loli.net/2022/06/03/SQLMoxtWkUBPyHg.png" alt="image-20220603165727917"></p>
<p>0x7c00~0x7dff</p>
<p>BIOS找到一个可引导的软盘或硬盘，它将512字节的引导扇区加载到物理地址0x7c00到0x7dff的内存中，然后使用jmp指令将CS:IP设置为0000:7c00，将控制权传递给<strong>the boot loader</strong>。</p>
<p>kern  入口LMA为 00100000 被映射到虚拟地址（LMA）0xf0100000<br>kernel最先加载的就是 .text<br>所作操作：开启内存分页机制，启用虚拟内存，I/O的实现，栈的初始化。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/centos%E6%98%BE%E7%A4%BA%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/centos%E6%98%BE%E7%A4%BA%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/" class="post-title-link" itemprop="url">centos扩展root</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-16 10:37:17 / 修改时间：10:40:28" itemprop="dateCreated datePublished" datetime="2022-05-16T10:37:17+08:00">2022-05-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p><strong>仅作记录</strong></p>
<p>ref: <a target="_blank" rel="noopener" href="https://blog.csdn.net/twilight1999/article/details/123840372">https://blog.csdn.net/twilight1999/article/details/123840372</a></p>
<p><img src="https://s2.loli.net/2022/05/16/WQNqYGo94wDTb6u.png" alt="image-20220516103804877"></p>
<p><img src="https://s2.loli.net/2022/05/16/3YptBci6qogIjkK.png" alt="image-20220516103901544"></p>
<p><img src="https://s2.loli.net/2022/05/16/ZiD4djJs3ExIqQc.png" alt="image-20220516103912000"></p>
<p><img src="https://s2.loli.net/2022/05/16/D1CGQ3R4rNHlqEv.png" alt="image-20220516103928952"></p>
<p><img src="https://s2.loli.net/2022/05/16/OTRvL1cHmiQbU6C.png" alt="image-20220516103939013"></p>
<p><img src="https://s2.loli.net/2022/05/16/GjIwrRZcJvd79ha.png" alt="image-20220516103947750"></p>
<p><img src="https://s2.loli.net/2022/05/16/gkFC9wuDfep8rP5.png" alt="image-20220516104001619"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/14/MIT6.828%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/14/MIT6.828%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">MIT6.828</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-14 15:55:56" itemprop="dateCreated datePublished" datetime="2022-05-14T15:55:56+08:00">2022-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-17 11:59:55" itemprop="dateModified" datetime="2022-05-17T11:59:55+08:00">2022-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>环境配置是个大坑</p>
<p>直接按照课程教程</p>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/tools.html">https://pdos.csail.mit.edu/6.828/2017/tools.html</a></p>
<p>安装ubuntu（32位），我之前安装64，后来各种报错。<strong>ubuntu安装时，插上蓝牙键盘或鼠标设备有时也报错，显示cpu不兼容。</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kinvy/p/15074844.html">https://www.cnblogs.com/kinvy/p/15074844.html</a>     &lt;———-亲测有效</p>
<p><strong>复制过来仅作记录</strong></p>
<h3 id="1-测试编译工具"><a href="#1-测试编译工具" class="headerlink" title="1.测试编译工具"></a>1.测试编译工具</h3><p>shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -i</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727123132004.png"><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727123132004.png" alt="image-20210727123132004"></a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -m32 -print-libgcc-file-name 		<span class="comment">#测试gcc</span></span></span><br></pre></td></tr></table></figure>

<p>上面这条命令是测试gcc的，一般系统是没有gcc的，需要安装</p>
<p>安装gcc , gdb, git, vim</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt-get install -y build-essential gdb git vim</span></span><br></pre></td></tr></table></figure>

<p>安装32位的支持库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt-get install gcc-multilib</span></span><br></pre></td></tr></table></figure>

<h3 id="2-编译安装工具链"><a href="#2-编译安装工具链" class="headerlink" title="2. 编译安装工具链"></a>2. 编译安装工具链</h3><h4 id="2-1下载以下工具包"><a href="#2-1下载以下工具包" class="headerlink" title="2.1下载以下工具包"></a>2.1下载以下工具包</h4><ul>
<li><a href="ftp://ftp.gmplib.org/pub/gmp-5.0.2/gmp-5.0.2.tar.bz2">ftp://ftp.gmplib.org/pub/gmp-5.0.2/gmp-5.0.2.tar.bz2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2">https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</a></li>
<li><a target="_blank" rel="noopener" href="http://www.multiprecision.org/downloads/mpc-0.9.tar.gz">http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</a></li>
<li><a target="_blank" rel="noopener" href="http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2">http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</a></li>
<li><a target="_blank" rel="noopener" href="http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2">http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</a></li>
<li><a target="_blank" rel="noopener" href="http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2">http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</a></li>
</ul>
<p>第一个包可能下载不了，可以自己搜索，或是使用下面的链接</p>
<p><a target="_blank" rel="noopener" href="https://mirrors.sjtug.sjtu.edu.cn/gnu/gmp/gmp-5.0.2.tar.bz2">https://mirrors.sjtug.sjtu.edu.cn/gnu/gmp/gmp-5.0.2.tar.bz2</a></p>
<h4 id="2-2-编译安装"><a href="#2-2-编译安装" class="headerlink" title="2.2 编译安装"></a>2.2 编译安装</h4><p>为了方便，将以上6个压缩包放在一个文件夹下 ，<code>~/download/mit6.828</code></p>
<p>文件夹结构</p>
<p><a target="_blank" rel="noopener" href="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727131718755.png"><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727131718755.png" alt="image-20210727131718755"></a></p>
<blockquote>
<p>以下的操作都是在 <code>~/download/mit6.828</code> 目录下</p>
</blockquote>
<ol>
<li><p>安装gmp-5.0.2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf gmp-5.0.2.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> gmp-5.0.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span>   <span class="comment"># 可能的错误：No usable m4 in $PATH or /usr/5bin (see config.log for reasons).</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span>             </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure>

<p>逐条执行命令，每执行一条后，输出无 <code>error</code> 就可往下执行，后面几个安装包也是一样的</p>
<blockquote>
<p>可能的错误是第3个命令，如果报错，执行以下命令，然后再次执行第3行命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt install m4</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装mpfr-3.1.2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf mpfr-3.1.2.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> mpfr-3.1.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span>           </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装mpc-0.9</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xzf mpc-0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> mpc-0.9</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span>            </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装binutils-2.21.1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf binutils-2.21.1.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> binutils-2.21.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span> --target=i386-jos-elf --disable-werror</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install             <span class="comment"># This step may require privilege (sudo make install)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line"><span class="meta">$</span><span class="bash">i386-jos-elf-objdump -i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功安装会输出类似下面的信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> BFD header file version (GNU Binutils) 2.21.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> elf32-i386</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  (header little endian, data little endian)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   i386...</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装gcc-core-4.6.4</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf gcc-core-4.6.4.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> gcc-4.6.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir build</span>           </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash">../configure --prefix=/usr/<span class="built_in">local</span> \</span></span><br><span class="line"><span class="bash">    --target=i386-jos-elf --disable-werror \</span></span><br><span class="line"><span class="bash">    --disable-libssp --disable-libmudflap --with-newlib \</span></span><br><span class="line"><span class="bash">    --without-headers --enable-languages=c MAKEINFO=missing</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make all-gcc</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install-gcc</span>         </span><br><span class="line"><span class="meta">$</span><span class="bash">make all-target-libgcc		<span class="comment">#可能会报错 [configure-target-libgcc] Error 1</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install-target-libgcc</span>   </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ../..</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line"><span class="meta">$</span><span class="bash">i386-jos-elf-gcc -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功安装会输出类似下面的信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using built-in specs.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> COLLECT_GCC=i386-jos-elf-gcc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> COLLECT_LTO_WRAPPER=/usr/<span class="built_in">local</span>/libexec/gcc/i386-jos-elf/4.6.4/lto-wrapper</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Target: i386-jos-elf</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行11行命令可能会报错，如果报错，执行以下命令，然后再次执行第11行命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/lib</span> </span><br></pre></td></tr></table></figure></li>
<li><p>安装gdb-7.3.1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf gdb-7.3.1.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> gdb-7.3.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span> --target=i386-jos-elf --program-prefix=i386-jos-elf- \</span></span><br><span class="line"><span class="bash">    --disable-werror</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make all			<span class="comment">#可能的错误 no termcap library found</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span>         </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能报错的命令第5个，如果出现错误，执行以下命令，然后再执行该命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">wget http://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -zxv -f termcap-1.3.1.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> termcap-1.3.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure</span> </span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装-QEMU"><a href="#安装-QEMU" class="headerlink" title="安装 QEMU"></a>安装 QEMU</h2><h3 id="1-安装工具包"><a href="#1-安装工具包" class="headerlink" title="1. 安装工具包"></a>1. 安装工具包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt install libsdl1.2-dev libtool-bin libglib2.0-dev  libz-dev  libpixman-1-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo apt install python2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-下载qemu"><a href="#2-下载qemu" class="headerlink" title="2. 下载qemu"></a>2. 下载qemu</h3><p>qemu需要用6.828定制的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">git <span class="built_in">clone</span> https://github.com/mit-pdos/6.828-qemu.git qemu</span></span><br></pre></td></tr></table></figure>

<h3 id="3-编译安装"><a href="#3-编译安装" class="headerlink" title="3. 编译安装"></a>3. 编译安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./configure --disable-kvm --disable-werror --prefix=/usr/<span class="built_in">local</span>  --target-list=<span class="string">&quot;i386-softmmu x86_64-softmmu&quot;</span> --python=python2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span></span><br></pre></td></tr></table></figure>

<p>可能的错误：</p>
<ol>
<li><p>缺少一个头文件，错误如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qga/commands-posix.c: In function ‘dev_major_minor’:</span><br><span class="line">qga/commands-posix.c:633:13: error: In the GNU C Library, &quot;major&quot; is defined</span><br><span class="line"> by &lt;sys/sysmacros.h&gt;. For historical compatibility, it is</span><br><span class="line"> currently defined by &lt;sys/types.h&gt; as well, but we plan to</span><br><span class="line"> remove this soon. To use &quot;major&quot;, include &lt;sys/sysmacros.h&gt;</span><br><span class="line"> directly. If you did not intend to use a system-defined macro</span><br><span class="line"> &quot;major&quot;, you should undefine it after including &lt;sys/types.h&gt;. [-Werror]</span><br><span class="line">         *devmajor = major(st.st_rdev);</span><br><span class="line">             ^~~~~~~~~~~~~~~~~~~~~~~~~~   </span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决：在 qga/commands-posix.c文件中的 #include &lt;sys/types.h&gt; 下面增加#include &lt;sys/sysmacros.h&gt;即可</p>
</blockquote>
</li>
</ol>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载实验源码</span></span><br><span class="line"><span class="meta">$</span><span class="bash">git <span class="built_in">clone</span> https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> lab</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make qemu-nox</span></span><br></pre></td></tr></table></figure>

<p>测试成功</p>
<p><a target="_blank" rel="noopener" href="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727171159202.png"><img src="https://s2.loli.net/2022/05/16/GwcegZSjm3AsvRU.png" alt="image-20210727171159202"></a></p>
<h2 id="vscode连接ubuntu"><a href="#vscode连接ubuntu" class="headerlink" title="vscode连接ubuntu"></a>vscode连接ubuntu</h2><p>连接时一直显示失败，但是termius可以连接上</p>
<p>应该是vscode不支持此版本的ubuntu</p>
<p>换到clion后，可以使用</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/14/vsvode%E4%BD%BF%E7%94%A8ssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/14/vsvode%E4%BD%BF%E7%94%A8ssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/" class="post-title-link" itemprop="url">vsvode使用ssh远程连接linux</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-14 15:24:45 / 修改时间：15:25:31" itemprop="dateCreated datePublished" datetime="2022-05-14T15:24:45+08:00">2022-05-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1.找到自己电脑公钥C:<code>Users**用户名**.ssh</code>这个目录<br><code>id-rsa</code>和<code>id-rsa.pub</code>两个文件, 第一个是私钥文件,第二个是公钥文件</p>
<p>2.将公钥添加到远程linux系统中</p>
<p>sudo vim /root/.ssh/authorized_keys</p>
<p>:wq保存退出</p>
<p>3.启用秘钥方式登录</p>
<p>sudo vim /etc/ssh/sshd_config</p>
<p><code>PubkeyAuthentication</code> yes的注释去掉</p>
<p>:wq保存退出</p>
<p>4.检查ssh服务</p>
<p>sudo netstat -ntlp | grep ssh 如果有22端口说明已经启动，如果没有列出执行以下命令</p>
<p>/etc/init.d/ssh resart</p>
<p>5.配置vscode远程连接信息</p>
<p>  1.vscode安装Remote - SSH</p>
<p>  2.Remote Explorer里面选择SSH Targets</p>
<p>  3.选择+号添加连接信息， ssh <strong>user</strong>@<strong>ip</strong> -p 22, 其中user为远程电脑登录用户名，ip为远程电脑ip地址</p>
<p>  如果配置过程中出现 <strong>过程试图写入的管道不存在</strong>找到以下文件</p>
<p>  C:<code>Users**用户名**.sshconfig</code></p>
<p>``` 右键 属性-&gt;安全-&gt;高级-&gt;禁用继承/然后 添加-&gt;-&gt;高级-&gt;立即查找-&gt;选择你的用户名-&gt;添加上**修改**的权限`</p>
<p>`` 然后使用vscode再次连接，中间过程会弹出输入登录机器密码的对话框，输入即可</p>
<p>仅作记录</p>
<p>ref: <a target="_blank" rel="noopener" href="http://t.zoukankan.com/guanglin-p-14931464.html">http://t.zoukankan.com/guanglin-p-14931464.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/17/Cplusplus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/17/Cplusplus/" class="post-title-link" itemprop="url">Cplusplus</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-17 09:34:28" itemprop="dateCreated datePublished" datetime="2022-04-17T09:34:28+08:00">2022-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-25 13:45:57" itemprop="dateModified" datetime="2022-04-25T13:45:57+08:00">2022-04-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、计算机基础"><a href="#一、计算机基础" class="headerlink" title="一、计算机基础"></a>一、计算机基础</h1><ol>
<li>C/C++内存有哪几种类型？<br>C中，内存分为5个区：<strong>堆</strong>(malloc)、<strong>栈</strong>(如局部变量、函数参数)、<strong>程序代码区</strong>（存放二进制代码）、<strong>全局/静态存储区</strong>（全局变量、static变量）和<strong>常量存储区</strong>（常量）。此外，C++中有<strong>自由存储区</strong>（new）一说。<br>全局变量、static变量会初始化为缺省值，而堆和栈上的变量是随机的，不确定的。</li>
</ol>
<ol start="2">
<li><p>堆和栈的区别？<br> 1).堆存放动态分配的对象——即那些在程序运行时动态分配的对象，比如 new 出来的对象，其生存期由程序控制；<br> 2).栈用来保存定义在函数内的<strong>非static对象</strong>，如局部变量，仅在其定义的程序块运行时才存在；<br> 3).静态内存用来保存static对象，类static数据成员以及定义在任何函数外部的变量，static对象在使用之前分配，程序结束时销毁；<br> 4).栈和静态内存的对象由编译器自动创建和销毁。</p>
</li>
<li><p>堆和自由存储区的区别？<br>总的来说，堆是C语言和操作系统的术语，是操作系统维护的一块动态分配内存；自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。他们并不是完全一样。<br>从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。<strong>基本上，所有的C++编译器默认使用堆来实现自由存储</strong>，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/02/%E8%BF%90%E7%AD%B9%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/02/%E8%BF%90%E7%AD%B9%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">运筹优化知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-02 10:45:00" itemprop="dateCreated datePublished" datetime="2022-04-02T10:45:00+08:00">2022-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-25 13:46:12" itemprop="dateModified" datetime="2022-04-25T13:46:12+08:00">2022-04-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="optimization-problem"><a href="#optimization-problem" class="headerlink" title="optimization problem"></a>optimization problem</h1><ol>
<li>无约束的优化问题</li>
<li>带等式约束的优化问题</li>
<li>带不等式约束的优化问题</li>
</ol>
<h1 id="dual"><a href="#dual" class="headerlink" title="dual"></a>dual</h1><h2 id="KKT"><a href="#KKT" class="headerlink" title="KKT"></a>KKT</h2><p>经典注水问题：<br>$$<br>min -\sum^n_{i=1}log(\alpha + x_i) \<br>s.t.~~~~~~~~  x \geq, 1^Tx=1<br>$$<br>其中$\alpha_i &gt;0$ 。</p>
<p>令$x^*$ and $(\lambda^*,v*)$分别是原问题和对偶问题的某对最优解，对偶间隙为0，可以得到如下的KTT条件：<br>$$<br>x^* &gt; 0,~~~ 1^Tx^*=1,~~~\lambda^<em>\succeq0,~~~ \lambda_i^</em>x_i^*=0,i=1…n, \<br>\frac{-1}{\alpha_i + x_i^*}-\lambda_i^*+v^*=0, i=1…,n<br>$$<br>$\lambda^*$在最后一个方程里是一个松弛变量，可以消去。<br>$$<br>x^* &gt; 0,~~~ 1^Tx^*=1,~~~\lambda^<em>\succeq0,~~~ x_i^</em>(v^* - \frac{1}{\alpha_i + x_i^*})=0,i=1…n, \<br>v^* \geq \frac{1}{\alpha_i + x_i^*}, i=1…,n<br>$$<br>所以有下式：<br>$$<br>x_i^*=\left{ \begin{aligned} &amp;\frac{1}{v^*}-\alpha_i, &amp;v^* &lt; \frac{1}{\alpha^*} \<br>&amp;0 , &amp;v^<em>\geq \frac{1}{\alpha^</em>}<br>\end{aligned}<br>\right.<br>$$<br>更简洁地，$x^* = max{\frac{1}{v^*} - \alpha_i, 0}$, 将该值代入条件$1^Tx^*=1$，可以得到<br>$$<br>\sum^n_{i=1}max{ 0,\frac{1}{v^*}-\alpha_i }=1<br>$$</p>
<h1 id="单纯形法"><a href="#单纯形法" class="headerlink" title="单纯形法"></a>单纯形法</h1><p>单纯形算法适用的情况</p>
<p><strong>标准的线性规划格式</strong><br>$$<br>&amp; max~~~ c^Tx \<br>&amp; ~~~~~~~~~s.t. ~~~A*x \leq b \<br>&amp;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ x_i \geq 0, i = 1,2,3,…,n<br>$$<br><strong>松弛型</strong></p>
<img src="https://s2.loli.net/2022/04/11/OlA1U6KkL4q3DnC.png" alt="image-20220411162221373" style="zoom:50%;" />

<p>主问题是 $2x_1 + x_2$, 不是$x_3$</p>
<p>加入非负松弛变量</p>
<img src="https://s2.loli.net/2022/04/11/hCZbmrWAHNowYPa.png" alt="image-20220411162306991" style="zoom:50%;" />

<p><strong>单纯形</strong></p>
<img src="https://s2.loli.net/2022/04/11/NgPC9wDpdcuGBEy.png" alt="image-20220411162333695" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/04/11/mC6Bopq7vzXjfDW.png" alt="image-20220411162348367" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/04/12/ChxMY9U1AlRXao3.png" alt="image-20220411162407384" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/04/12/H4bA6pzI5sjwWLJ.png" alt="image-20220411162420712" style="zoom:50%;" />

<p>ref: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/388224103">https://zhuanlan.zhihu.com/p/388224103</a></p>
<h1 id="影子价格"><a href="#影子价格" class="headerlink" title="影子价格"></a>影子价格</h1><h1 id="Row-Generation（就是割平面法）"><a href="#Row-Generation（就是割平面法）" class="headerlink" title="Row Generation（就是割平面法）"></a>Row Generation（就是割平面法）</h1><p><strong>常用于整数规划</strong></p>
<p>割平面方法，从更宏观的角度，可以看作是一种行生成方法。这里的“行”（row），指的是线性不等式。每找到一个cut，就增加一个线性不等式。</p>
<p>线性规划的算法复杂度和连续变量呈多项式级关系，另外随着约束条件（不等式）个数的增加，求解时间也会随之增加。（不确定呈什么关系，求拍砖）</p>
<p>上面说到整数规划的算法复杂度和整数变量的个数n基本呈指数关系，那么它还和其他什么因素相关呢？答案是不等式的个数。（recall求解整数规划需要求解一个个的线性规划）</p>
<p>我们从线性规划角度，理解行生成方法的基本思想：形成极值（最优解）所需要的约束条件个数，往往远小于原问题的约束条件个数。因此为何不在需要的时候，才把这些“重要”的约束条件加上来呢？</p>
<p>下面举个简单例子：</p>
<p>如下图，原问题有5个不等式（一条红线代表一个不等式），但是最优解点D只需CD和DE 2个不等式即可表述。</p>
<img src="https://s2.loli.net/2022/04/12/2i4wUupVWlmx8Mr.png" alt="image-20220412174455417" style="zoom:50%;" />

<p>因此行生成方法的基本思路：先求解原问题的松弛问题，即初始问题（master problem）不加约束条件或只加其中几个约束，然后求解该松弛问题，如果得到的解是可行解，那么该解就是原问题的最优解（例如刚开始运气很好地加了CD和DE）。</p>
<p>如果得到的解对原问题是不可行的，例如解是（0，6）这个点（因为没有加BC这个约束），或者无界的，那么这时候加上BC这个不等式便可以把这个不可行解排除。</p>
<p>以此循环，直到松弛问题的解是可行的，那么该解也是原问题的最优解。</p>
<p>而通过行生成方法，上面问题本来需要5个约束条件，很可能只需要2-3个约束条件，上面的循环已经终止了。</p>
<p>在实际问题中，最优解所需要的约束条件往往远远小于原问题的约束条件个数。例如几万个约束条件，实际只有几百个是用来刻画最优解的。那么这个时候，割平面方法便可以大大提速线性规划的求解。</p>
<p>在上一节的TSP问题中，subtour elimination constraints的个数是指数级的（因此不可能把他们全部加进来），但是求解实际问题中，往往通过割平面方法只需找到其中几千或几百个，即可找到原问题的最优解。用到的，正是相似的思路。</p>
<p>其实TSP问题是有完整刻画的表达式的（Complete Formulation），这时的约束个数虽然不是指数级，但是数量也非常大，因此求解效率很低。割平面方法的引入，大大增加了TSP问题求解的高效性，这也是该方法一次完美的show off。</p>
<p>搜索Literature 行生成方法，最先映入眼帘的可能是Benders’ Decomposition。在那里，一般把整数和实数变量隔离做分解，然后有比较“严格”的如何选取初始约束以及如何一步步地增加约束（feasibility cut和optimality cut）。</p>
<p><strong>与行生成法对偶的方法，是列生成法</strong>（逐步增加变量个数）。其中的Dantzig-Wolfe分解法，是Benders’ Decomposition的dual problem。</p>
<p><strong>ref:</strong>    <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28387290?group_id=893712252413284352">https://zhuanlan.zhihu.com/p/28387290?group_id=893712252413284352</a></p>
<h1 id="column-generation"><a href="#column-generation" class="headerlink" title="column generation"></a>column generation</h1><p>列生成算法（Column Generation Algorithm）是一种用于求解<strong>大规模线性优化问题</strong>的高效算法，本质上来讲，列生成算法是单纯形法的一种形式，用来求解线性规划问题。</p>
<p>列生成算法已被应用于求解很多著名的NP-hard优化问题，如机组人员调度问题（Crew assignment problem）、切割问题（Cutting stock problem）、车辆路径问题（Vehicle routing problem）、单资源工厂选址问题（The single facility location problem）等</p>
<p><strong>基本思想</strong></p>
<p>列生成算法通过求解子问题（sub problem）来找到可以进基的非基变量，该非基变量在模型中并没有显性的写出来（可以看成是生成了一个变量，每个变量其实等价于一列，所以该方法被称为列生成算法）。如果找不到一个可以进基的非基变量，那么就意味着所有的非基变量的检验数（Reduced Cost，RC）都满足最优解的条件，也就是说，该线性规划的最优解已被找到。其思路如下：</p>
<p>1、先把原问题（Master Problem，MP）转换到一个规模更小（即变量数比原问题少）的问题上，这个只使用部分变量的模型被称为原问题的RMP 问题（Restricted Master Problem）。在RMP上用单纯形法求最优解，注意此时求得的最优解只是RMP上的，并不是MP的最优解。</p>
<p>2、然后需要通过一个子问题去检测在那些未被考虑的变量中是否有使得RC小于零的情况，如果有，那么就把这个变量的相关系数列加入到RMP的系数矩阵中，返回第1步。</p>
<p>经过反复迭代，直到子问题中的RC都大于等于零，此时就找到了MP的最优解。</p>
<p><strong>注意min和max问题的影子价格</strong></p>
<h1 id="拉格朗日松弛"><a href="#拉格朗日松弛" class="headerlink" title="拉格朗日松弛"></a>拉格朗日松弛</h1><p>拉格朗日对偶（问题）</p>
<h1 id="bender’s-decomposition"><a href="#bender’s-decomposition" class="headerlink" title="bender’s decomposition"></a>bender’s decomposition</h1><p>主要思想是行生成+割平面方法</p>
<h2 id="single-bender’s"><a href="#single-bender’s" class="headerlink" title="single bender’s"></a>single bender’s</h2><h2 id="multi-bender’s"><a href="#multi-bender’s" class="headerlink" title="multi bender’s"></a>multi bender’s</h2><h1 id="branch-and-bound（精确算法）"><a href="#branch-and-bound（精确算法）" class="headerlink" title="branch and bound（精确算法）"></a>branch and bound（精确算法）</h1><p><strong>分支定界</strong></p>
<p>分支定界算法始终围绕着一颗搜索树进行的，我们将原问题看作搜索树的根节点，从这里出发，分支的含义就是将大的问题分割成小的问题。大问题可以看成是搜索树的父节点，那么从大问题分割出来的小问题就是父节点的子节点了。分支的过程就是不断给树增加子节点的过程。而定界就是在分支的过程中检查子问题的上下界，如果子问题不能产生一比当前最优解还要优的解，那么砍掉这一支。直到所有子问题都不能产生一个更优的解时，算法结束。</p>
<img src="https://s2.loli.net/2022/04/12/tvXw4O9s8zVU3GB.png" alt="image-20220412155612418" style="zoom:33%;" />

<p><strong>例子</strong></p>
<p>对于一个整数规划模型：<br>$$<br>maximize~~~~~~&amp;4x_1+9x_2+6x_3 \<br>subject~ to~~~~&amp;5x_1+8x_2+6x_3 \leq 12 \<br>&amp;x_1,x_2,x_3 ~ are~ binary~ variable<br>$$<br>因为求解的是最大化问题，不妨先设当前的最优解为负无穷：-INF。</p>
<ol>
<li><strong>首先从主问题分出两支子问题：</strong></li>
</ol>
<img src="https://s2.loli.net/2022/04/12/ZdT1qGzwELYUjSC.png" alt="image-20220412160043235" style="zoom: 50%;" />

<p>通过线性松弛求得两个子问题的upper bound为Z_LP1 = 12.75，Z_LP2 = 12.2。由于Z_LP1 和Z_LP2都大于BestV=-INF，说明这两支均满足要求。继续往下。</p>
<ol start="2">
<li><strong>从节点 1 和节点 2 两个子问题再次分支，得到如下结果</strong></li>
</ol>
<img src="https://s2.loli.net/2022/04/12/aE4W5fBDbHTcvuG.png" alt="image-20220412161353856" style="zoom: 50%;" />

<p>子问题3已经不可行，无需再理。子问题4通过线性松弛得到最优解为10，刚好也符合原问题0的所有约束，在该支找到一个可行解，更新BestV = 10。</p>
<p>子问题5通过线性松弛得到upper bound为11.87&gt;当前的BestV = 10，因此子问题5还有戏，待下一次分支。而子问题6得到upper bound为9&lt;当前的BestV = 10，那么从该支下去找到的解也不会变得更好，所以剪掉！</p>
<ol start="3">
<li><strong>对结点5进行分支</strong></li>
</ol>
<img src="https://s2.loli.net/2022/04/12/uIATlUHx9jaoghs.png" alt="image-20220412161453040" style="zoom:50%;" />

<p>子问题7不可行，无需再理。子问题8得到一个满足原问题0所有约束的解，但是目标值为4&lt;当前的BestV=10，所以不更新BestV，同时该支下去也不能得到更好的解了。</p>
<ol start="4">
<li><strong>此时，所有的分支遍历都完成，我们最终找到了最优解。</strong></li>
</ol>
<p><strong>分支定界法（branch and bound）</strong>是一种<strong>求解整数规划问题</strong>的最常用算法。这种方法不但可以求解纯整数规划，<strong>还可以求解混合整数规划问题</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. Using a heuristic, find a solution xh to the optimization problem. Store its value, B = f(x_h). (If no heuristic is available, set B to infinity.) B will denote the best solution found so far, and will be used as an upper bound on candidate solutions.</span><br><span class="line"></span><br><span class="line">2. Initialize a queue to hold a partial solution with none of the variables of the problem assigned.</span><br><span class="line"></span><br><span class="line">3. Loop until the queue is empty:</span><br><span class="line"></span><br><span class="line">	3.1. Take a node N off the queue.</span><br><span class="line">	</span><br><span class="line">	3.2. If N represents a single candidate solution x and f(x) &lt; B, then x is the best solution so far. Record it and set B ← f(x).</span><br><span class="line">	</span><br><span class="line">	3.3. Else, branch on N to produce new nodes Ni. For each of these:</span><br><span class="line"></span><br><span class="line">		3.3.1. If bound(N_i) &gt; B, do nothing; since the lower bound on this node is greater than the upper bound of the problem, it will never lead to the optimal solution, and can be discarded.</span><br><span class="line">		</span><br><span class="line">		3.3.2. Else, store Ni on the queue.</span><br></pre></td></tr></table></figure>



<p><strong>ref:</strong>   <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dengfaheng/p/11225612.html">https://www.cnblogs.com/dengfaheng/p/11225612.html</a></p>
<h1 id="branch-and-cut"><a href="#branch-and-cut" class="headerlink" title="branch and cut"></a>branch and cut</h1><p>branch and cut其实还是和branch and bound脱离不了干系的。</p>
<p>在应用branch and bound求解整数规划问题的时候，如下图:</p>
<img src="https://s2.loli.net/2022/04/12/nvNTFE8UzOCZtWS.png" alt="image-20220412171138059" style="zoom:50%;" />

<p>假如，我们现在求一个整数规划最大化问题，在分支定界过程中，求解整数规划模型的LP松弛模型得到的非整数解作为上界，而此前找到的整数解作为下界。 如果出现某个节点upper bound低于现有的lower bound，则可以剪掉该节点。否则，如果不是整数解继续分支。</p>
<p>此外，在求解整数规划模型的LP松弛时，<strong>If cutting planes are used to tighten LP relaxations。</strong>那么这时候的branch and bound就变成了branch and cut。   <strong>割平面</strong></p>
<img src="https://s2.loli.net/2022/04/12/AMhmExzpJrowPLG.png" alt="image-20220412171238809" style="zoom:50%;" />

<p>红色部分是整数规划的可行解空间。<br>蓝色部分是整数规划的LP松弛可行解空间。<br>在求解LP松弛时，加入橙色的cut，缩小解空间，同时又不影响整数解的解空间，可使解收敛得更快。</p>
<p>这就是branch and cut的过程了。比branch and bound高明之处就在于多了一个cutting planes，可能使branch and bound的效率变得更高。</p>
<p><strong>例子</strong><br>$$<br>min~~~~~~~~~~~~~ &amp;z=-6x_1-5_2 \<br>subject~to~~~&amp;3x_1+x_2 \leq 11 \<br>&amp;-x_1+2x_2 \leq 5 \<br>&amp;x_1,x_2 \geq 0<br>$$<br><img src="https://s2.loli.net/2022/04/12/feg4ZSWLiKBYanc.png" alt="image-20220412171533780"></p>
<p><img src="https://s2.loli.net/2022/04/12/4rb9IVU3pRLSAY7.png" alt="image-20220412171629952"></p>
<p><strong>ref:</strong>     <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dengfaheng/p/11344488.html">https://www.cnblogs.com/dengfaheng/p/11344488.html</a></p>
<p><strong>更加详细的一个参考</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28387290?group_id=893712252413284352">https://zhuanlan.zhihu.com/p/28387290?group_id=893712252413284352</a></p>
<h1 id="内点法"><a href="#内点法" class="headerlink" title="内点法"></a>内点法</h1><h1 id="各类梯度下降法和牛顿法"><a href="#各类梯度下降法和牛顿法" class="headerlink" title="各类梯度下降法和牛顿法"></a>各类梯度下降法和牛顿法</h1><p><strong>批量梯度下降：</strong></p>
<ol>
<li><p>是最小化所有样本的损失函数，最终得到全局最优解。　　　　　　</p>
</li>
<li><p>由于每次更新参数需要重新训练一次全部的样本，代价比较大，适用于小规模样本训练的情况。</p>
</li>
</ol>
<p><strong>随机梯度下降：</strong></p>
<ol>
<li><p>是最优化每个样本的损失函数。每一次迭代得到的损失函数不是，每次每次向着全局最优的方向，但是大体是向着全局最优，最终的结果往往是在最优解的附近。　　　</p>
</li>
<li><p>当目标函数是凸函数的时候，结果一定是全局最优解。</p>
<p>　　　　　　　3. 适合大规模样本训练的情况。</p>
</li>
</ol>
<p><strong>小批量梯度下降法：</strong></p>
<p>　将上述两种方法作结合。每次利用一小部分数据更新迭代参数。即样本在1和m之间。</p>
<h3 id="牛顿法："><a href="#牛顿法：" class="headerlink" title="牛顿法："></a>牛顿法：</h3><p>是通过求解目标函数的一阶导数为0时的参数，进而求出目标函数最小值时的参数。</p>
<p>优点：收敛速度很快。海森矩阵的逆在迭代过程中不断减小，可以起到逐步减小步长的效果。</p>
<p>缺点：海森矩阵的逆计算复杂，代价比较大，因此有了拟牛顿法。</p>
<p>x多变量时，二阶导使用hessian 矩阵</p>
<h3 id="梯度下降法："><a href="#梯度下降法：" class="headerlink" title="梯度下降法："></a>梯度下降法：</h3><p>是通过梯度方向和步长，直接求解目标函数的最小值时的参数。</p>
<p>越接近最优值时，步长应该不断减小，否则会在最优值附近来回震荡。</p>
<img src="https://s2.loli.net/2022/04/05/7TF6qYWKdtrQwzy.png" alt="image-20220405211558700" style="zoom: 67%;" />

<img src="https://s2.loli.net/2022/04/05/y1hXAfk682Hc4DE.png" alt="image-20220405211627441" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/04/05/1aAoWc8OKds3PJU.png" alt="image-20220405211655906" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/04/05/StCsT3KaGL64cxE.png" alt="image-20220405211707643" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/04/12/xad3FKUT1eiwvWR.png" alt="image-20220405211722098" style="zoom:67%;" />

<p><strong>使用牛顿法/拟牛顿法收敛更快。但是每次迭代的时间比梯度下降法长。</strong></p>
<p>ref: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112416130">https://zhuanlan.zhihu.com/p/112416130</a></p>
<h1 id="CO"><a href="#CO" class="headerlink" title="CO"></a>CO</h1><h1 id="MIP"><a href="#MIP" class="headerlink" title="MIP"></a>MIP</h1><h2 id="MILP"><a href="#MILP" class="headerlink" title="MILP"></a>MILP</h2><p>非线性转为线性</p>
<p>基于CO，CO做了有功和无功的平衡</p>
<p>将约束条件转换为惩罚项。使得主问题变为线性问题，求解MILP</p>
<h1 id="RO"><a href="#RO" class="headerlink" title="RO"></a>RO</h1><p>苏文藻课程</p>
<h1 id="SO"><a href="#SO" class="headerlink" title="SO"></a>SO</h1><p>苏文藻课程</p>
<h1 id="distributionally-robust-optimization"><a href="#distributionally-robust-optimization" class="headerlink" title="distributionally robust optimization"></a>distributionally robust optimization</h1><p>苏文藻课程</p>
<h1 id="粒子群算法（PSO）和遗传算法"><a href="#粒子群算法（PSO）和遗传算法" class="headerlink" title="粒子群算法（PSO）和遗传算法"></a>粒子群算法（PSO）和遗传算法</h1><p>PSO: partivcle swarm optimizatioin</p>
<p>GA: genetic algorithm</p>
<p>PSO和GA的<strong>相同点：</strong></p>
<ol>
<li>都属于仿生算法。PSO主要模拟鸟类觅食、人类认知等社会行为而提出；GA主要借用生物进化论中”适者生存“的规律。</li>
<li>都属于全局优化方法。两种算法都是在解空间随机产生初始种群，因为算法在全局的解空间进行搜索，且将搜索重点集中在性能高的部分。</li>
<li>都属于随机搜索算法。都是通过随机优化方法更新种群和搜索最优点。PSO中认知项和社会项前都加有随机数。GA的遗传操作均属于随即操作。</li>
<li>都隐含并行性。搜索过程是从问题解的一个集合开始，而不是从单个个体开始，具有隐含并行搜索特性，从而减小了陷入局部极小的可能性。</li>
<li>根据个体的适配信息进行搜索，因此不受函数约束条件的限制，如连续性、可导性等。</li>
<li>对高维复杂问题，往往会遇到早熟收敛和收敛性能差的缺点，都无法保证收敛到最优点。</li>
</ol>
<p>PSO和GA的<strong>不同点：</strong></p>
<ol>
<li>PSO有记忆，好的解的所有粒子均保存，而GA没有记忆，以前的知识随着种群的改变而被破坏。</li>
<li>GA算法中，染色体之间相互共享信息，所以整个种群的移动是比较均匀的向最优区域移动。PSO中的例子仅仅通过当前搜索到的最优点进行共享信息，所以很大程度上这是一种单项信息共享机制，整个搜索更新过程是跟随当前最优解的过程。<strong>在大多数情况下，所有粒子可能比遗传算法中的进化个体以更快速度收敛于最优解。</strong> </li>
<li>PSO相对于GA，不需要编码，没有交叉和变异操作，粒子只是通过内部速度进行更新，因此原理更简单、参数更少、实现更容易。</li>
<li>PSO算法主要应用于连续问题，包括神经网络训练和函数优化等，而GA除了连续问题之外，还可应用于离散问题，比如TSP问题、货郎担问题、工作车间调度等。</li>
</ol>
<h1 id="禁忌搜索算法"><a href="#禁忌搜索算法" class="headerlink" title="禁忌搜索算法"></a>禁忌搜索算法</h1><p>禁忌搜索(Tabu Search, TS)也是属于模拟人类智能的一种优化算法。</p>
<img src="https://s2.loli.net/2022/04/15/Iz2RtKDcQdZrkEV.jpg" alt="img" style="zoom: 67%;" />

<p><strong>禁忌表（Tabu List，TL）</strong><br><strong>是用来存放（记忆）禁忌对象的表</strong>。它是禁忌搜索得以进行的基本前提。禁忌表本身是有容量限制的，它的大小对存放禁忌对象的个数有影响，会影响算法的性能。</p>
<p><strong>禁忌对象（Tabu Object，TO）</strong><br><strong>是指禁忌表中被禁的那些变化元素</strong>。禁忌对象的选择可以根据具体问题而制定。例如在旅行商问题（Traveling Salesman Problem，TSP）中可以将交换的城市对作为禁忌对象，也可以将总路径长度作为禁忌对象。</p>
<p><strong>禁忌期限（Tabu Tenure，TT）</strong><br>也叫禁忌长度，<strong>指的是禁忌对象不能被选取的周期</strong>。禁忌期限过短容易出现循环，跳不出局部最优，长度过长会造成计算时间过长。</p>
<p><strong>渴望准则（Aspiration Criteria，AC）</strong><br>也称为特赦规则。<strong>当所有的对象都被禁忌之后，可以让其中性能最好的被禁忌对象解禁</strong>，或者当某个对象解禁会带来目标值的很大改进时，也可以使用特赦规则。</p>
<p><strong>非对称的旅行商问题（ATSP）</strong></p>
<p><img src="https://s2.loli.net/2022/04/15/tRMBUr7ebDYcZIi.png" alt="image-20220415155952005"></p>
<p>分析：这是一个简单的问题,利用枚举的方法也可以找到最优的答案，但是，找到答案不是我们的目的，我们主要是想通过一一个简单的例子来理解禁忌搜索是如何进行工作的。从距离矩阵D可以看到，这是一个<strong>非对称</strong>的TSP问题，但是这并不影响算法的执行。由于题目假设了邻域构造的方式，而且规定了始点和终点都是城市a，因此，在以下的求解过程中，我们不使用城市a和其他城市进行交换，这样的操作并不会影响全局寻优的能力。</p>
<img src="https://pic3.zhimg.com/80/v2-d325fe1019c1c1b584a9f460eeca7df2_720w.jpg" alt="img" style="zoom: 67%;" />

<p><strong>注：</strong>在实际应用中，通过选择更高的禁忌对象，设置合理的禁忌期限，或者采用其他更好的的参数，都可以避免循环（反复出现同种情况的邻域值）的出现，提高算法的性能。</p>
<h1 id="常见的机器学习算法"><a href="#常见的机器学习算法" class="headerlink" title="常见的机器学习算法"></a>常见的机器学习算法</h1><h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><img src="https://s2.loli.net/2022/04/04/31WiDgLGTE8dM4l.jpg" alt="43E6AF2BAF69572D95CD2DBEAECD8CB2" style="zoom: 80%;" />

<img src="https://s2.loli.net/2022/04/04/V6lH1xLfmhgTZnw.jpg" alt="IMG_0397" style="zoom:33%;" />



<img src="https://s2.loli.net/2022/04/04/3zKRPoN5IMLc1QX.jpg" alt="IMG_0399" style="zoom:50%;" />

<p><img src="https://s2.loli.net/2022/04/05/aux2AeH3yhLnEG5.jpg" alt="IMG_0400"></p>
<p><img src="https://s2.loli.net/2022/04/05/enNSxgiFrtEhfKy.jpg" alt="QQ图片20220404232547"></p>
<p>机器学习给的KKT和凸优化给的不同。但是我认为二者是等价的，应该可以互推。</p>
<p>这个是凸优化上的条件。</p>
<p><img src="https://s2.loli.net/2022/04/05/mP3SAVBihEr1Rxy.png" alt="image-20220405110624726"></p>
<h2 id="贝叶斯"><a href="#贝叶斯" class="headerlink" title="贝叶斯"></a>贝叶斯</h2><p>后验概率的获得主要有两种策略</p>
<ol>
<li> 给定x，直接建模$P(c|x)$来预测c，这样叫做”判别式模型“</li>
<li>先对联合概率分布$P(x|c)$建模，然后再由此获得$P(c|x)$.</li>
</ol>
<p>$$<br>P(c|x)&amp;= \frac{P(cx)}{P(x)} =\frac{P(c)P(x|c)}{P(x)} \<br>&amp;=\frac{P(c)}{P(x)}\cdot\frac{P(x|c)}{P(x)}\<br>&amp;= \frac{P(c)}{P(x)}\cdot \prod_{i=1}^{d}P(x_i|c)<br>$$</p>
<p>$P(cx) = P(c)P(x|c) = P(x)P(x|c)$</p>
<p>朴素贝叶斯要求独立同分布。</p>
<p>半朴素贝叶斯分类器，对属性条件独立性假设进行了一定程度的放松。</p>
<p><img src="https://s2.loli.net/2022/04/05/qzYdSFNCRwMITJg.jpg" alt="IMG_0408"></p>
<p>贝叶斯网，借助有向无环图来刻画属性之间的依赖关系。用条件概率表来描述属性的联合概率分布。</p>
<h3 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h3><p>我们一直假设训练样本的所有属性都被观测到，即训练样本是完整的，但是现实中常遇到不完整的样本，这种未能观测到的特征称为”隐变量“。</p>
<p>令<strong>X</strong>表示已观测到的变量集，<strong>Z</strong>表示隐变量集，$\Theta$表示模型参数，若欲对$\Theta$做极大似然估计，则应该最大化对数似然。<br>$$<br>LL(\Theta|X,Z) = \ln P(X,Z|\Theta)<br>$$<br>由于<strong>Z</strong>是隐变量，该式无法求解，此时可以通过对<strong>Z</strong>计算期望，来最大化已观测数据的对数”边际似然“</p>
<img src="https://s2.loli.net/2022/04/05/znXsWkHx1uKr6wS.jpg" alt="IMG_0406" style="zoom:50%;" />



<img src="https://s2.loli.net/2022/04/05/Jz3ME2Uustfwd7W.png" alt="image-20220405163218219" style="zoom:50%;" />



<img src="https://s2.loli.net/2022/04/05/E7epgyfWKiRzuvh.png" alt="image-20220405163353314" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/04/05/OU6KCEBo3lHDLjc.png" alt="image-20220405163644044" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/04/05/rwm2iCGY7ZKX3Bp.jpg" alt="IMG_0407" style="zoom: 50%;" />

<img src="https://s2.loli.net/2022/04/05/oWbzHIuAx2NSdCk.png" alt="image-20220405164448434" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/04/12/k7JlOnXshWMopT1.png" alt="image-20220405170825391" style="zoom:50%;" />

<p>$\propto$正比于</p>
<img src="https://s2.loli.net/2022/04/12/GwrPcM8OuxULJYv.png" alt="image-20220405171059473" style="zoom:50%;" />



<h2 id="Linear-model"><a href="#Linear-model" class="headerlink" title="Linear model"></a>Linear model</h2><h2 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h2><p>隐马尔科夫模型是结构最简单的动态贝叶斯网，是一种著名的有向图模型，主要用于时序数据建模，在语音识别、自然语言处理等领域有广泛应用。</p>
<p>三个基本步骤</p>
<ol>
<li><p>给定参数，观测序列，计算条件概率</p>
</li>
<li><p>参数学习，给定序列，反推参数</p>
</li>
<li><p>解码。给定参数和观测序列，求最大可能性。</p>
</li>
</ol>
<h2 id="次梯度"><a href="#次梯度" class="headerlink" title="次梯度"></a>次梯度</h2><p>支撑超平面的斜率就是次梯度。</p>
<p>最起码是凸函数才能保证任意一点的次梯度存在。</p>
<p><strong>次梯度下降</strong></p>
<p><img src="https://s2.loli.net/2022/04/05/2QC5DFW8OPVRBeq.png" alt="image-20220405135334199"></p>
<h2 id="近端梯度"><a href="#近端梯度" class="headerlink" title="近端梯度"></a>近端梯度</h2><p><img src="https://s2.loli.net/2022/04/05/JMpbdenLoHl4WsK.png" alt="image-20220405150019553"></p>
<p><img src="https://s2.loli.net/2022/04/05/2lS9qtzTc4X1vw5.png" alt="image-20220405150032359"></p>
<p><img src="https://s2.loli.net/2022/04/05/2xA4BL5z1Eok7M9.png" alt="image-20220405150045008"></p>
<p><img src="https://s2.loli.net/2022/04/05/1gvUwrqYBSt9V5j.png" alt="image-20220405150056680"></p>
<p><img src="https://s2.loli.net/2022/04/05/ro8kEHKAIxg1hXQ.png" alt="image-20220405150213656"></p>
<p><img src="https://s2.loli.net/2022/04/05/QT9DgAbnELmwtd8.png" alt="image-20220405150221222"></p>
<p>ref：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38290475/article/details/81052206">https://blog.csdn.net/qq_38290475/article/details/81052206</a></p>
<h1 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h1><p><img src="https://s2.loli.net/2022/04/05/Ov49MyQBKW8jcpI.jpg" alt="img"></p>
<h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><img src="https://pica.zhimg.com/v2-e47296e78fff3d97eea11d0657ddcb81_1440w.jpg?source=172ae18b" alt="【机器学习】降维——PCA（非常详细）" style="zoom: 33%;" />



<p>风电数据</p>
<p>构建DRO时候，不同机组的历史数据不同，</p>
<p><img src="https://s2.loli.net/2022/04/05/q4QFwmU5SvfK1rH.png" alt="img"></p>
<h1 id="LDR变换"><a href="#LDR变换" class="headerlink" title="LDR变换"></a>LDR变换</h1><h1 id="pickup-and-delivery-problem-with-time-windows"><a href="#pickup-and-delivery-problem-with-time-windows" class="headerlink" title="pickup and delivery problem with time-windows"></a>pickup and delivery problem with time-windows</h1><p>求解PDPTW问题的算法包括：<strong>列生成算法</strong>（column generation）、<strong>分支切割</strong>（branch-and-cut）、<strong>分支切割定价</strong>（branch-and-cut-and-price）<em>等精确计算算法</em>，<strong>禁忌搜索</strong>（tabu search）、<strong>模拟退火</strong>（simulated annealing algorithm）、<strong>基于插入搜索的算法</strong>（insertion-based heuristic）、<strong>自适应大邻域搜索</strong>（adaptive large neighborhood search）、<strong>变深度搜索</strong>（variable-depth search algorithm）。由于在配送场景下，对算法时效性有极高的要求，上述算法均无法适用于配送场景的问题。在后文中，我们将介绍路径规划的问题模型，以及提出的启发式算法（Two-Stage Fast Heuristic），同时给出了一些仿真结果。</p>
<p>ref: <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000024516742">https://segmentfault.com/a/1190000024516742</a></p>
<h1 id="指派问题-Assignment-Problems-AP"><a href="#指派问题-Assignment-Problems-AP" class="headerlink" title="指派问题(Assignment Problems - AP)"></a>指派问题(Assignment Problems - AP)</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38361726/article/details/120738776">https://blog.csdn.net/qq_38361726/article/details/120738776</a></p>
<h1 id="车辆路径问题-VRP"><a href="#车辆路径问题-VRP" class="headerlink" title="车辆路径问题(VRP)"></a>车辆路径问题(VRP)</h1><p>VRP是指一定数量的客户，各自有不同数量的货物需求，配送中心向客户提供货物，由一个车队负责分送货物，组织适当的行车路线，目标是使得客户的需求得到满足，并能在一定的约束下，达到诸如路程最短、成本最小、耗费时间最少等目的。</p>
<p>TSP是VRP问题的特例。</p>
<h1 id="旅行商问题-TSP"><a href="#旅行商问题-TSP" class="headerlink" title="旅行商问题(TSP)"></a>旅行商问题(TSP)</h1><p><img src="https://pic4.zhimg.com/80/v2-e0921653dd164fded4bb4256283e66ff_720w.jpg" alt="img"></p>
<img src="https://pic3.zhimg.com/80/v2-9c5e778c1ce83c44f661abc525f34876_720w.jpg" alt="img" style="zoom: 67%;" />

<p>其中约束(3)尽管可被简化但仍使得该问题成为了NP问题，因此基于上述讨论，本文将简单介绍可用于解决TSP的启发式算法。</p>
<h2 id="非对称旅行商问题（ATSP）"><a href="#非对称旅行商问题（ATSP）" class="headerlink" title="非对称旅行商问题（ATSP）"></a>非对称旅行商问题（ATSP）</h2><h2 id="非对称旅行商问题（STSP）"><a href="#非对称旅行商问题（STSP）" class="headerlink" title="非对称旅行商问题（STSP）"></a>非对称旅行商问题（STSP）</h2><h1 id="凸包算法"><a href="#凸包算法" class="headerlink" title="凸包算法"></a>凸包算法</h1><h2 id="Graham-scan"><a href="#Graham-scan" class="headerlink" title="Graham scan"></a>Graham scan</h2><p><img src="https://s2.loli.net/2022/04/23/piQgGPzcaZCMI8A.png" alt="image-20220423094807908"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/20/%E5%89%91%E6%8C%87offer%E5%9B%9E%E5%BF%86%E5%BD%95%EF%BC%88%E9%80%9F%E5%88%B7%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/20/%E5%89%91%E6%8C%87offer%E5%9B%9E%E5%BF%86%E5%BD%95%EF%BC%88%E9%80%9F%E5%88%B7%EF%BC%89/" class="post-title-link" itemprop="url">剑指offer回忆录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-20 10:45:00" itemprop="dateCreated datePublished" datetime="2022-03-20T10:45:00+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-02 22:44:46" itemprop="dateModified" datetime="2022-06-02T22:44:46+08:00">2022-06-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><strong>从尾到头打印链表</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 栈</span><br><span class="line"><span class="number">2.</span> insert</span><br><span class="line"><span class="number">3.</span>递归</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec, ListNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next)&#123;</span><br><span class="line">            <span class="built_in">backtrace</span>(vec, p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="built_in">backtrace</span>(vec, head);</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在vector对象<strong>尾部之外的位置</strong>插入或删除元素可能很慢，那么结合链表与顺序表的特性可以认为vector对象的元素所使用的数据结构应该是顺序表。</p>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><strong>反转链表</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;  <span class="comment">//头插法反转</span></span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>); <span class="comment">//新的头节点</span></span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* nxt = pHead-&gt;next;  <span class="comment">//提前保存head的下一个结点，防止赋值后head更改</span></span><br><span class="line">            pHead-&gt;next = newHead-&gt;next;</span><br><span class="line">            newHead-&gt;next = pHead;</span><br><span class="line">            pHead = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a><strong>合并两个排序的链表</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pHead2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节省空间就不创建新的链表了，较小的当第一个节点</span></span><br><span class="line">        ListNode *nh = pHead1-&gt;val &lt;= pHead2-&gt;val?pHead1:pHead2;</span><br><span class="line">        ListNode *prev = nh; <span class="comment">// 尾结点</span></span><br><span class="line">        ListNode *nxt = <span class="literal">nullptr</span>; <span class="comment">// temp</span></span><br><span class="line">        <span class="keyword">while</span>(pHead1 &amp;&amp; pHead2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val &lt;= pHead2-&gt;val)&#123;</span><br><span class="line">                nxt = pHead1;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nxt = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev-&gt;next = nxt;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pHead1)&#123;</span><br><span class="line">            prev-&gt;next = pHead1;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            pHead1 = pHead1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pHead2)&#123;</span><br><span class="line">            prev-&gt;next = pHead2;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            pHead2 = pHead2-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> nh;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><strong>复杂链表的复制</strong></h2><p>每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点。对此链表进行深拷贝。</p>
<p><strong>浅拷贝：</strong>又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。</p>
<p><strong>深拷贝：</strong>拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，<strong>深拷贝情况下，不会出现重复释放同一块内存的错误。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    struct RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment">    RandomListNode(int x) :</span></span><br><span class="line"><span class="comment">            label(x), next(NULL), random(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先拷贝原链表</span></span><br><span class="line">        RandomListNode* pre = <span class="keyword">new</span> <span class="built_in">RandomListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        RandomListNode* last = pre, * p = pHead;</span><br><span class="line">        unordered_map&lt;RandomListNode*, RandomListNode*&gt; mp;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            RandomListNode* new_node = <span class="keyword">new</span> <span class="built_in">RandomListNode</span>(p-&gt;label);</span><br><span class="line">            mp[p] = new_node;  <span class="comment">// 旧结点对应的新结点</span></span><br><span class="line">            last-&gt;next = new_node;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            last = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [key, value]:mp)&#123;</span><br><span class="line">            <span class="comment">// key 旧结点    value为新结点</span></span><br><span class="line">            value-&gt;random = key-&gt;random == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span>:mp[key-&gt;random];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>















<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a><strong>树的子结构</strong></h2><p>判断一棵树是不是另一棵树的子结构.</p>
<p>没啥好解释的，我直接暴力穷举。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot1 || !pRoot2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(TreeNode*, TreeNode*)&gt; compareVal = [&amp;](TreeNode* p, TreeNode* q)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(q == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">nullptr</span> || p-&gt;val != q-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">compareVal</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">compareVal</span>(p-&gt;right,q-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">bool</span> tag = <span class="literal">false</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(pRoot1);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            tag = <span class="built_in">compareVal</span>(temp, pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(tag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><strong>二叉树的镜像</strong></h2><p>我第一反应想的是层次遍历倒序</p>
<p>发现前序，中序获得，倒序构建貌似也可以。没实验过</p>
<p>递归操作也可以用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Mirror</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;   <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot-&gt;left &amp;&amp; !pRoot-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot;  <span class="comment">// 单节点返回自身, &#123;1&#125; return 1;</span></span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* temp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = temp;</span><br><span class="line">        <span class="built_in">Mirror</span>(pRoot-&gt;left);</span><br><span class="line">        <span class="built_in">Mirror</span>(pRoot-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a><strong>对称的二叉树</strong></h2><p>判断二叉树是否对称。</p>
<p>中序遍历拆开   或者  不拆开直接判断，即递归，一样的。</p>
<p>非递归方法，使用stack，每次成双取出，判断p1-&gt;left == p2-&gt;right &amp;&amp; p1-&gt;right == p2-&gt;left。然后成双放入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span> || (!pRoot-&gt;left &amp;&amp; !pRoot-&gt;right))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(TreeNode*, TreeNode*)&gt; cpr = [&amp;](TreeNode* leftt, TreeNode* rightt)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftt == <span class="literal">nullptr</span> &amp;&amp; rightt == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 说明不全空</span></span><br><span class="line">            <span class="keyword">if</span>(leftt==<span class="literal">nullptr</span> || rightt == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//一空一不空</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> leftt-&gt;val == rightt-&gt;val</span><br><span class="line">                   &amp;&amp; <span class="built_in">cpr</span>(leftt-&gt;right, rightt-&gt;left)</span><br><span class="line">                   &amp;&amp; <span class="built_in">cpr</span>(leftt-&gt;left, rightt-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cpr</span>(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>边界条件处我犯了错。状态判断不好。</p>
<h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a><strong>从上往下打印二叉树</strong></h2><p>层次遍历。不赘述</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a><strong>二叉搜索树的后序遍历序列</strong></h2><p>二叉搜索树的中序遍历是递增的。</p>
<p>后序遍历的最后一位是根节点root</p>
<p>说明序列中，小于root-&gt;val的都是左子树，大于的都是右子树</p>
<p>接下来，相似的操作。</p>
<p>如  2 4 3 6 8 7 5   -&gt;    root = 5     left: 2 4 3   right: 6 8 7</p>
<p>2 4 3 -&gt; root=3  left = 2  right = 4             6 8 7 -&gt;  root = 7  left = 6  right = 8 </p>
<p><strong>递归</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">       std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(vector&lt;<span class="keyword">int</span>&gt;&amp;, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>)&gt; judge = </span><br><span class="line">           [&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp; seq, <span class="keyword">size_t</span> l, <span class="keyword">size_t</span> r)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> temp = seq[r];  <span class="comment">// root</span></span><br><span class="line">           <span class="keyword">int</span> i = r - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(i&gt;l &amp;&amp; seq[i]&gt;temp)&#123;</span><br><span class="line">               --i;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//找到分界点了</span></span><br><span class="line">           <span class="comment">// 判断左侧是否全部都是小于temp的</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">size_t</span> j = l;j&lt;i;++j)&#123;</span><br><span class="line">               <span class="keyword">if</span>(seq[j]&gt;temp)&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">judge</span>(seq, l, i) &amp;&amp; <span class="built_in">judge</span>(seq, i+<span class="number">1</span>, r<span class="number">-1</span>);</span><br><span class="line">       &#125;;</span><br><span class="line">        <span class="keyword">if</span>(sequence.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> n = sequence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(sequence, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树中和为某一值的路径-二"><a href="#二叉树中和为某一值的路径-二" class="headerlink" title="二叉树中和为某一值的路径(二)"></a><strong>二叉树中和为某一值的路径(二)</strong></h2><p>找出二叉树中结点值的和为目标值的所有路径（<strong>路径指根节点到叶子</strong>）</p>
<p><del>可以及时剪枝。</del>  </p>
<p>先序遍历的做法来遍历。</p>
<p>考虑负数！负数的话，大于的判断符号就没法使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> expect;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">FindPath</span>(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;expect = expectNumber;</span><br><span class="line">        </span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(TreeNode*, <span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp;)&gt; dfs = </span><br><span class="line">            [&amp;](TreeNode* rt, <span class="keyword">int</span> sum,vector&lt;<span class="keyword">int</span>&gt; temp, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans) -&gt; <span class="keyword">void</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rt == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=rt-&gt;val;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(rt-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(sum == expect &amp;&amp; rt-&gt;left == <span class="literal">nullptr</span> &amp;&amp; rt-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                temp.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// &lt;</span></span><br><span class="line">            <span class="keyword">if</span>(rt-&gt;left)</span><br><span class="line">                <span class="built_in">dfs</span>(rt-&gt;left, sum, temp, ans);</span><br><span class="line">            <span class="keyword">if</span>(rt-&gt;right)</span><br><span class="line">                <span class="built_in">dfs</span>(rt-&gt;right, sum, temp, ans);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, temp, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><strong>二叉搜索树与双向链表</strong></h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</p>
<p>方法一：直接中序重新构造</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(TreeNode*, TreeNode*&amp;)&gt; trans = [&amp;](TreeNode* root, TreeNode*&amp; last)-&gt;<span class="keyword">void</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">                <span class="built_in">trans</span>(root-&gt;left, last);</span><br><span class="line">            &#125;</span><br><span class="line">            last-&gt;right = root;</span><br><span class="line">            root-&gt;left = last;</span><br><span class="line">            last = root;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">                <span class="built_in">trans</span>(root-&gt;right, last);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        TreeNode* p = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">-1</span>);</span><br><span class="line">        TreeNode* q = p;</span><br><span class="line">        <span class="built_in">trans</span>(pRootOfTree, q);</span><br><span class="line">        p=p-&gt;right;</span><br><span class="line">        p-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>方法二：不开辟新的结点，直接在原节点操作。<strong>这就需要保存中序遍历过程中的前继结点。</strong>给个全局变量，保存前继。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* preNode;  <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先找到preNode</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(TreeNode*)&gt; trans = [&amp;](TreeNode* root)-&gt;<span class="keyword">void</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">trans</span>(root-&gt;left);  <span class="comment">//走到起始点</span></span><br><span class="line">            <span class="comment">// 找到最左侧，此时root == p</span></span><br><span class="line">        root-&gt;left = preNode;</span><br><span class="line">        preNode-&gt;right = root;</span><br><span class="line">        preNode = root;    </span><br><span class="line">        <span class="built_in">trans</span>(root-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        TreeNode* p = pRootOfTree;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;left)&#123;</span><br><span class="line">            p = p-&gt;left;  <span class="comment">// 链表的起始节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        preNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">trans</span>(pRootOfTree);</span><br><span class="line">        p-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> p;  <span class="comment">// 链表的头</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a><strong>序列化二叉树</strong></h2><p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">		TreeNode* left;</span><br><span class="line">		TreeNode* right;</span><br><span class="line">		<span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">	<span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		TreeNode* p = root;</span><br><span class="line">		<span class="built_in">preOrder</span>(p, res);</span><br><span class="line">		<span class="comment">// 使用递归，把最后一个逗号删除</span></span><br><span class="line">		res.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用迭代，最后还少个&quot;X&quot;</span></span><br><span class="line">		<span class="comment">// preOrder_case2(p, res);</span></span><br><span class="line">		<span class="comment">// res += &quot;X&quot;;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用递归方式</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root, string&amp; str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			str += <span class="string">&quot;X&quot;</span>;</span><br><span class="line">			str += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		str += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">		str += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">		<span class="built_in">preOrder</span>(root-&gt;left, str);</span><br><span class="line">		<span class="built_in">preOrder</span>(root-&gt;right, str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 非递归方式 进行前序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preOrder_case2</span><span class="params">(TreeNode* root, string&amp; str)</span> </span>&#123;</span><br><span class="line">		stack&lt;TreeNode*&gt; st;</span><br><span class="line">		st.<span class="built_in">push</span>(root);</span><br><span class="line">		str = str + <span class="built_in">to_string</span>(root-&gt;left-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">		TreeNode* temp = root;</span><br><span class="line">		<span class="keyword">int</span> visited_node = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (temp!= <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp!=<span class="literal">nullptr</span>) &#123;  <span class="comment">// 一直向左走</span></span><br><span class="line">				st.<span class="built_in">push</span>(temp);</span><br><span class="line">				str += <span class="built_in">to_string</span>(temp-&gt;val);   <span class="comment">// 不断保存经过的结点</span></span><br><span class="line">				str += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">				temp = temp-&gt;left;  <span class="comment">// 走到最左</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="comment">// 找右子树</span></span><br><span class="line">				str += <span class="string">&quot;X&quot;</span>;   <span class="comment">// 不断保存经过的结点</span></span><br><span class="line">				str += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">				temp = st.<span class="built_in">top</span>();  <span class="comment">// 回溯到父结点</span></span><br><span class="line">				st.<span class="built_in">pop</span>();</span><br><span class="line">				temp = temp-&gt;right;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;  <span class="comment">// 只给了一个string ，说明不能通过 前/中 + 后序  来确定唯一的二叉树</span></span><br><span class="line">		deque&lt;string&gt; que;</span><br><span class="line">		stringstream ss;</span><br><span class="line">		string temp;</span><br><span class="line">		ss &lt;&lt; data;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">getline</span>(ss, temp, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">			que.<span class="built_in">push_back</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 按照 ’,‘ 分割好了</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">anls</span>(que);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从左到右解析字符串</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">anls</span><span class="params">(deque&lt;string&gt;&amp; que)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// que 从前往后</span></span><br><span class="line">		<span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; que.<span class="built_in">front</span>() == <span class="string">&quot;X&quot;</span>) &#123;  <span class="comment">// 为空结点</span></span><br><span class="line">			que.<span class="built_in">pop_front</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> temp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(que.<span class="built_in">front</span>()));</span><br><span class="line">		que.<span class="built_in">pop_front</span>();</span><br><span class="line">		temp-&gt;left = <span class="built_in">anls</span>(que);</span><br><span class="line">		temp-&gt;right = <span class="built_in">anls</span>(que);</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a></h2><p>leetcode450</p>
<p>难点主要在于删除操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// cur的左右节点都为空，cur可以直接删除</span></span><br><span class="line">    <span class="comment">// 右节点为空，找左节点的最大值</span></span><br><span class="line">    <span class="comment">// 左节点为空，找右节点的最小值</span></span><br><span class="line">    <span class="comment">// 左右节点均不为空，那么去左边找最大值或右边找最小值都可以,来替换掉cur</span></span><br><span class="line">    <span class="comment">// 解法可以看作不断地重构二叉搜索树(BST)</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; key)&#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt; key)&#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left,key);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==key)&#123;  <span class="comment">// ==</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">// 直接删除root</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span>)&#123;  <span class="comment">// 右空，找左边最大值,刚好是左边第一个</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)&#123; <span class="comment">// 左空，找右边最小值，刚好是右边第一个</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两侧都不为空</span></span><br><span class="line">            <span class="comment">// 这里找右边最小值，换掉root</span></span><br><span class="line">            TreeNode* rep = root-&gt;right;</span><br><span class="line">            <span class="comment">// 如果右边第一个有左子树，那么就一直找,因为最小值如果在左子树，那么肯定在第一个结点的左子树</span></span><br><span class="line">            <span class="keyword">while</span>(rep-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                rep = rep-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时已经找到最小值的结点了</span></span><br><span class="line">            <span class="comment">// 重构需要删除结点的右子树， 值要根据rep（即替换节点的值重构</span></span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, rep-&gt;val);</span><br><span class="line">            <span class="comment">// 把这个结点替换掉需要删除的结点 root</span></span><br><span class="line">            rep-&gt;right = root-&gt;right;</span><br><span class="line">            rep-&gt;left = root-&gt;left;</span><br><span class="line">            <span class="keyword">return</span> rep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数</span></span><br><span class="line"><span class="comment">// [0,1,2,1,2],3    -&gt;   [0,1,1]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* case1  直接排序取前K</span></span><br><span class="line"><span class="comment">* case2  容量为K的优先队列(大顶堆)。 小于则进去且弹出堆顶</span></span><br><span class="line"><span class="comment">* case3  topK算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case1略</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// case2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（大顶）堆的建立，插入，删除"><a href="#（大顶）堆的建立，插入，删除" class="headerlink" title="（大顶）堆的建立，插入，删除"></a><strong>（大顶）堆的建立，插入，删除</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapBID</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 数组下标从0开始</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;  <span class="comment">// 向下调整</span></span><br><span class="line">		<span class="keyword">int</span> leftChild = k * <span class="number">2</span> + <span class="number">1</span>, rightChild = k * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> maxIndex = k; <span class="comment">//假设在当前节点，及其左、右子节点，共三个节点中，最大的是当前这个节点。后序我们就要更新max，看到底哪个才是最大的，把最大的那个和当前节点交换</span></span><br><span class="line">		<span class="keyword">if</span> (leftChild &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[leftChild] &gt; nums[maxIndex])</span><br><span class="line">			maxIndex = leftChild;</span><br><span class="line">		<span class="keyword">if</span> (rightChild &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[rightChild] &gt; nums[maxIndex])</span><br><span class="line">			maxIndex = rightChild;</span><br><span class="line">		<span class="keyword">if</span> (maxIndex != k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[maxIndex], nums[k]);</span><br><span class="line">			<span class="built_in">shiftDown</span>(nums, maxIndex); <span class="comment">// 如果原k节点调整了位置(上一步swap调整)，那么就要将k继续做shiftDown操作，直到它比它的左、右孩子都大</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  建立的是大顶堆</span></span><br><span class="line">	<span class="comment">// 向上调整，删除堆顶时候使用</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;  <span class="comment">// 向上调整</span></span><br><span class="line">		<span class="comment">// 首先将最后一个孩子节点插入到头节点</span></span><br><span class="line">		<span class="keyword">int</span> child = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span> (child &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[parent] &lt; nums[child]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(nums[parent], nums[child]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			child = parent;</span><br><span class="line">			parent = (child - <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">// 换层</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; ++i) &#123;  <span class="comment">// 从第一个非叶子节点开始，从下往上，将每棵子树调整成最大堆</span></span><br><span class="line">			<span class="built_in">shiftDown</span>(nums, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		nums.<span class="built_in">push_back</span>(x);</span><br><span class="line">		<span class="built_in">shiftUp</span>(nums);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pollHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> oldVal = nums[<span class="number">0</span>]; <span class="comment">// 头元素</span></span><br><span class="line">		nums[<span class="number">0</span>] = nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">		nums.<span class="built_in">pop_back</span>(); <span class="comment">// 弹出末尾</span></span><br><span class="line">		<span class="built_in">shiftDown</span>(nums, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; nums&#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span> &#125;;</span><br><span class="line">	HeapBID h;</span><br><span class="line">	h.<span class="built_in">buildMaxHeap</span>(nums);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;build heap&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; a : nums) &#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;insert&quot;</span> &lt;&lt; endl;</span><br><span class="line">	h.<span class="built_in">inHeap</span>(nums,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; a : nums) &#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pop &quot;</span> &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	h.<span class="built_in">pollHeap</span>(nums);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; a : nums) &#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pop all&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		cout &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		h.<span class="built_in">pollHeap</span>(nums);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/06/02/me9Agf8YLG5KMw7.png" alt="image-20220602224323732" style="zoom:67%;" />



<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><strong>顺时针打印矩阵</strong></h2><p>从外向里以顺时针打印。</p>
<p>螺旋输出，小心单行的情况，要判断 <code>if (top != bottom)</code>  和 <code>if (left != right)</code></p>
<p>在这里犯了错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, bottom = m<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right &amp;&amp; top&lt;=bottom)&#123;</span><br><span class="line">            <span class="comment">// 左到右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left;i&lt;=right;++i)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上到下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top+<span class="number">1</span>;i&lt;=bottom;++i)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 小心单行的情况</span></span><br><span class="line">            <span class="comment">//右到左</span></span><br><span class="line">            <span class="keyword">if</span> (top != bottom)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = right<span class="number">-1</span>; i&gt;=left;--i)&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下到上</span></span><br><span class="line">            <span class="keyword">if</span> (left != right)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom<span class="number">-1</span>;i&gt;top;--i)&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="队列-amp-栈"><a href="#队列-amp-栈" class="headerlink" title="队列&amp;栈"></a>队列&amp;栈</h1><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a><strong>包含min函数的栈</strong></h2><p>用了个辅助栈，保存当前最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; aux_st;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        st.<span class="built_in">push</span>(value);</span><br><span class="line">        <span class="keyword">if</span>(aux_st.<span class="built_in">empty</span>() || aux_st.<span class="built_in">top</span>() &gt;= value)&#123;</span><br><span class="line">            aux_st.<span class="built_in">push</span>(value);   <span class="comment">//保存当前最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(temp == aux_st.<span class="built_in">top</span>())&#123;</span><br><span class="line">            aux_st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aux_st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a><strong>栈的压入、弹出序列</strong></h2><p>判断出栈序列有没有可能是入栈序列的对应序列。</p>
<p>入栈1,2,3,4,5</p>
<p>出栈4,5,3,2,1</p>
<p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p>
<p>此时栈顶2≠4，继续入栈3</p>
<p>此时栈顶3≠4，继续入栈4</p>
<p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p>
<p>此时栈顶3≠5，继续入栈5</p>
<p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p>
<p>….</p>
<p>依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; pushV,vector&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; aux_st;</span><br><span class="line">        <span class="keyword">size_t</span> n = pushV.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">size_t</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">            aux_st.<span class="built_in">push</span>(pushV[i]);  <span class="comment">// 当前值入辅助栈</span></span><br><span class="line">            <span class="keyword">while</span>((!aux_st.<span class="built_in">empty</span>() &amp;&amp; aux_st.<span class="built_in">top</span>()==popV[j]))&#123;</span><br><span class="line">                <span class="comment">// 判断辅助栈当前顶部能否弹出和当前出栈序列对应的值</span></span><br><span class="line">                aux_st.<span class="built_in">pop</span>();</span><br><span class="line">                ++j;  <span class="comment">// 出栈序列后移一位</span></span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aux_st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><strong>字符串的排列</strong></h2><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="字符串的排列-1"><a href="#字符串的排列-1" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p><code>tag: 字符串  递归</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; vec;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string内没有重复字母</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permu_unique</span><span class="params">(string&amp; str, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == str.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index;i&lt;str.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(str[i], str[index]);</span><br><span class="line">            <span class="built_in">permu_unique</span>(str, index + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(str[i], str[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">permu_unique</span>(str, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string内有重复字母</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; visited; <span class="comment">// 记录重复字母</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// index代表选择的字母个数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permu</span><span class="params">(string&amp; str, <span class="keyword">int</span> index, string&amp; temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == str.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;str.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] || (i&gt;<span class="number">0</span> &amp;&amp; !visited[i<span class="number">-1</span>] &amp;&amp; str[i<span class="number">-1</span>] == str[i]))&#123;</span><br><span class="line">                <span class="comment">//!visited[i-1] &amp;&amp; str[i-1] == str[i]</span></span><br><span class="line">                <span class="comment">//这句代表，前一个是没访问过的状态，并且当前字母等于前一个字母</span></span><br><span class="line">                <span class="comment">// 说明  前一个字母已经遍历完了，把状态重置为0，才来这个字母</span></span><br><span class="line">                <span class="comment">// 而两个字母相同，所以不该对当前字母再进行搜索</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 选当前</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(str[i]);</span><br><span class="line">            <span class="comment">// 标记为已用</span></span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">permu</span>(str, index+<span class="number">1</span>, temp);</span><br><span class="line">            <span class="comment">// 回退</span></span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            visited[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        visited.<span class="built_in">resize</span>(str.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">permu</span>(str, <span class="number">0</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h1><h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  题目输入保证有解，不需要在进行验证</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a : numbers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;  <span class="comment">// 还没选数字</span></span><br><span class="line">                num  = a;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a == num)&#123;  <span class="comment">// 相同则给当前数字投一票</span></span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    --cnt;  <span class="comment">// 不同则减去一票</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




















      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-13 11:32:00" itemprop="dateCreated datePublished" datetime="2022-03-13T11:32:00+08:00">2022-03-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-14 11:13:55" itemprop="dateModified" datetime="2022-03-14T11:13:55+08:00">2022-03-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="分组交换网中的时延、丢包和吞吐量"><a href="#分组交换网中的时延、丢包和吞吐量" class="headerlink" title="分组交换网中的时延、丢包和吞吐量"></a>分组交换网中的时延、丢包和吞吐量</h2><h3 id="时延概述"><a href="#时延概述" class="headerlink" title="时延概述"></a>时延概述</h3><p>结点处理时延：如检查比特级别的差错所需要二时间，该差错出现在从上游结点向下级路由器传输这些分组比特的过程中。</p>
<p>排队时延：等待进入传输队列的时间。</p>
<p>传输时延：数据块从结点进入传播媒体的时间。</p>
<p>传播时延：从链路的起点到路由器所需要的时间。</p>
<h3 id="排队时延和丢包"><a href="#排队时延和丢包" class="headerlink" title="排队时延和丢包"></a>排队时延和丢包</h3><p>排队时延的大小取决于<strong>流量是周期性到达还是以突发形式到达</strong></p>
<h3 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h3><p>$$<br>d_{end-end} = N(d_{proc} + d_{trans} + d_{prop})<br>$$</p>
<p>无拥塞的情况下，没有排队时延。处理时延为proc， 传播时延为prop，trans为传输时延</p>
<h3 id="计算机网络中的吞吐量"><a href="#计算机网络中的吞吐量" class="headerlink" title="计算机网络中的吞吐量"></a>计算机网络中的吞吐量</h3><p>瞬时吞吐量</p>
<p>平均吞吐量</p>
<h2 id="计算机网络体系结构和参考模型"><a href="#计算机网络体系结构和参考模型" class="headerlink" title="计算机网络体系结构和参考模型"></a>计算机网络体系结构和参考模型</h2><h3 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h3><p>在计算机网络体系结构的各个层次中，每个报文都分为两部分：<strong>一</strong>是数据部分，即SDU（service Data Unit）服务数据单元；<strong>二</strong>是控制信息部分，即PCI（Protocol Control Information）。<strong>它们共同组成PDU（Protocol Data Unit）协议数据单元，PDU是对等层次之间传递的数据单位。</strong></p>
<p>物理层的PDU称为<strong>比特</strong></p>
<p>数据链路层的PDU称为<strong>帧</strong></p>
<p>网络层的PDU称为<strong>分组</strong></p>
<p>传输层的PDU称为<strong>报文</strong></p>
<p><img src="https://s2.loli.net/2022/03/13/tJvKZEYOLA51fil.png" alt="image-20220313144613003"></p>
<h3 id="计算机网络协议、接口、服务的概念"><a href="#计算机网络协议、接口、服务的概念" class="headerlink" title="计算机网络协议、接口、服务的概念"></a>计算机网络协议、接口、服务的概念</h3><p>协议就是规则的集合</p>
<p>接口是同一结点内相邻两层间交换信息的连接点，每层只能为紧邻的层次之间定义接口。</p>
<p><img src="https://s2.loli.net/2022/03/13/P9cmsOXhgaZlMfb.png" alt="image-20220313144815707"></p>
<p><img src="https://s2.loli.net/2022/03/13/geGP79jc2qAUKO1.png" alt="image-20220313145237354"></p>
<p><img src="https://s2.loli.net/2022/03/13/ohfX2Mc5SHrJKIE.png" alt="image-20220313145255059"></p>
<h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" class="headerlink" title="五层因特网协议栈"></a>五层因特网协议栈</h3><img src="https://s2.loli.net/2022/03/13/A14T9DUycgbzZqE.png" alt="image-20220313152319923" style="zoom:50%;" />

<p><strong>应用层：</strong></p>
<p>​    协议：HTTP, SMTP, FTP</p>
<p>​    信息分组：报文</p>
<p><strong>运输层：</strong></p>
<p>​    协议：两个运输协议：TCP、UDP</p>
<p>​    信息分组：报文段</p>
<p><strong>网络层：</strong></p>
<p>​    因特网的网络层负责将称为数据报的网络层分组从一台主机转移到另一台主机。</p>
<p>​    协议：IP协议</p>
<p>​    信息分组：数据报</p>
<p><strong>数据链路层：</strong></p>
<p>​    由链路层提供的服务取决于该链路的特定链路层协议。因为数据报从源到目的地传送通常要经过几条链路，一个数据报可能被沿途不同链路上的不同链路层协议处理。</p>
<p>​    协议：每个链路有自己特定的协议    </p>
<p>​    信息分组：帧</p>
<p><strong>物理层</strong></p>
<p>​    虽然链路层的任务是将一个个帧从一个网络元素移动到下一个网络元素，而物理层的任务是将该帧中的<strong>一个个比特</strong>从一个结点移动到下一个结点。</p>
<p>​    协议：这层的协议仍然是链路相关的，并且进一步与该链路的实际传输媒体相关。例如以太网具有许多物理层协议：关于双绞铜线、关于同轴电缆、关于光纤等。</p>
<h3 id="七层ISO-OSI模型"><a href="#七层ISO-OSI模型" class="headerlink" title="七层ISO/OSI模型"></a>七层ISO/OSI模型</h3><p><img src="https://s2.loli.net/2022/03/13/LYqPyRxNVna6CHG.png" alt="image-20220313145416137"></p>
<p><strong>物理层</strong></p>
<p>传输单位：比特</p>
<p>任务：传输比特流（<strong>二进制传输</strong>）</p>
<p>功能：在物理媒体上为数据端设备透明传输原始比特流。</p>
<p>主要协议：IEEE802.3</p>
<p><strong>数据链路层</strong></p>
<p>传输单位：帧</p>
<p>任务：将网络层传来的IP数据报组装成帧。</p>
<p>功能：成帧、差错控制、流量控制和传输管理等。</p>
<p>主要协议：MAC 、VLAN、PPP</p>
<p><strong>网络层</strong></p>
<p>传输单位：数据报</p>
<p>任务：把网络层的（PDU）协议数据单元（分组）从源端传到目的端。</p>
<p>功能：流量控制、拥塞控制、差错控制和网际互连等功能。</p>
<p>主要协议：IP、IPX、ICMP（Internet Control Message Protocol）、ARP（Address Resolution Protocol）</p>
<p>因特网的主要协议是无连接的网际协议（IP，  internet Protocol）和许多路由选择协议，因此因特网的网络层也叫网际层和IP层</p>
<p><strong>传输层</strong></p>
<p>传输单位：报文段（TCP报文）或数据用户报（UDP）</p>
<p>任务：负责主机中两个进程之间的通信</p>
<p>功能：为端到端提供可靠的传输服务，为端到端提供流量控制、差错控制、服务质量、数据传输管理等服务。</p>
<p>主要协议：TCP、UDP</p>
<p><strong>会话层</strong></p>
<p>传输单位：会话层协议数据单元（Session Protocol Data Unit, SPDU）</p>
<p>任务：允许不同主机上的各个进程之间进行会话。会话也称<strong>建立同步</strong>（synchronize）</p>
<p>功能：负责管理主机间的会话进程，包括建立、管理及终止进程间的会话</p>
<p>主要协议：RPC（远程调用协议  Remote Procedure Call Protocol）、NFS（Network File System）</p>
<p><strong>表现层</strong></p>
<p>传输单位：PPDU（Presentation Protocol Data Unit 表示协议数据单元）</p>
<p>功能：对数据进行翻译、加密和压缩</p>
<p>主要协议：ASCII、JPEG</p>
<p><strong>应用层</strong></p>
<p>传输单位：APDU（Application Protocol Data Unit  应用协议数据单元）</p>
<p>功能：允许访问OSI环境的手段</p>
<p>主要协议：FTP、HTTP、DNS</p>
<img src="https://img-blog.csdn.net/20180719225055535?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlbGFpc3Vu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="OSI协议栈" style="zoom: 33%;" />



<h3 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h3><p><img src="https://s2.loli.net/2022/03/13/DHmPletYio7VZQn.png" alt="image-20220313145451650"></p>
<p><img src="https://s2.loli.net/2022/03/14/Bh1EDnu7ldZqvtW.png" alt="image-20220314104243592"></p>
<h3 id="TCP-IP模型与OSI参考模型的比较"><a href="#TCP-IP模型与OSI参考模型的比较" class="headerlink" title="TCP/IP模型与OSI参考模型的比较"></a>TCP/IP模型与OSI参考模型的比较</h3><ul>
<li><p>相似之处</p>
<ul>
<li>二者都采用分层体系结构，将庞大且复杂的问题划分为若干较容易处理的、范围较小的问题。</li>
<li>二者都是基于独立的协议栈的概念。<ul>
<li>协议栈（英语：Protocol stack），又称协议堆叠，是计算机网络协议套件的一个具体的软件实现。协议套件中的一个协议通常是只为一个目的而设计的，这样可以使得设计更容易。因为每个协议模块通常都要和上下两个其他协议模块通信，它们通常可以想象成是协议栈中的层。</li>
</ul>
</li>
<li>二者都可以解决异构网络的互联，实现不同计算机之间的通信。</li>
</ul>
</li>
<li><p>不同之处</p>
<ul>
<li>OSI参考模型的最大贡献就是精确地定义了三个主要概念：服务、协议和接口，这与面向对象的设计思想非常吻合。而TCP/IP模型在这三个概念上没有明确的区分。</li>
<li>OSI参考模型在协议发明之前，没有偏向于任何特定的协议，通用性良好。TCP/IP模型在设计方面最先出现的是协议，模型实际上是对已有协议的描述，因此不会出现协议不匹配模型的情况，但是模型不适合于非TCP/IP模型。</li>
<li>TCP/IP模型在设计之初就考虑到了多种异构网的互联问题，并把IP作为一个单独的重要层次。</li>
<li>OSI参考模型在网络层支持无连接和面向连接的通信，而在传输层仅又面向连接的通信。而TCP/IP模型认为可靠性是端到端的问题，因此它在网际层仅有一种无连接的通信模式，但传输层支持无连接和面向连接的通信模式。</li>
</ul>
</li>
</ul>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p><img src="https://s2.loli.net/2022/03/14/SklYUD7CzyabQHq.png" alt="image-20220314111335985"></p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-02 09:49:14" itemprop="dateCreated datePublished" datetime="2022-03-02T09:49:14+08:00">2022-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-18 15:51:11" itemprop="dateModified" datetime="2022-04-18T15:51:11+08:00">2022-04-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="操作系统实验"><a href="#操作系统实验" class="headerlink" title="操作系统实验"></a>操作系统实验</h2><p><img src="https://s2.loli.net/2022/03/02/Qzg8JCPSdDK1W2b.png" alt="image-20220302095346362"></p>
<h2 id="操作系统概览"><a href="#操作系统概览" class="headerlink" title="操作系统概览"></a>操作系统概览</h2><h4 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h4><p><strong>用户角度：</strong> 操作系统是一个 <strong>控制软件</strong>：</p>
<ul>
<li>管理应用程序。</li>
<li>为应用程序提供服务。</li>
<li>杀死应用程序。</li>
</ul>
<p><strong>对内角度：</strong> 操作系统用于<strong>资源管理</strong>：</p>
<ul>
<li>管理外设、分配资源。</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/02/hyO78dDNgHeQYsB.png" alt="image-20220302110840436"></p>
<p>操作系统是<strong>硬件之上、应用程序</strong>之下的层次结构。<br>操作系统位于应用软件之下，为应用软件提供服务支撑。</p>
<p><strong>外壳（shell）</strong> <strong>内核（kernel）。</strong></p>
<p><strong>内核空间</strong>是操作系统内核访问的区域，独立于普通的应用程序，是受保护的内存空间。</p>
<p>用户空间是普通应用程序可访问的内存区域。</p>
<h4 id="操作系统包含什么"><a href="#操作系统包含什么" class="headerlink" title="操作系统包含什么"></a>操作系统包含什么</h4><p>硬件资源三大块：CPU、内存、磁盘。</p>
<p><strong>CPU：</strong> CPU调度、进程线程。<br><strong>内存：</strong> <strong>物理内存管理</strong>、<strong>虚拟内存管理</strong>（在有限物理内存之上为应用提供内存）。MMU<br><strong>文件系统：</strong> disk过于底层，不方便上层应用。所以我们做出<strong>文件系统管理</strong>。<br><strong>中断处理与设备驱动：</strong> 驱动实现操作系统。</p>
<h4 id="OS-Kernel的特征："><a href="#OS-Kernel的特征：" class="headerlink" title="OS Kernel的特征："></a>OS Kernel的特征：</h4><p>1.并发<br>并发：在<strong>一段时间内</strong>多个程序运行，需要OS管理和调度。<br>并行：在<strong>一个时间点</strong>上共同运行（因此<strong>只有一个CPU无法完成并行</strong>）。</p>
<p>2.共享<br>是“同时”访问还是互斥共享，根据情况而定。</p>
<p>3.虚拟<br>把硬件虚拟化。比如：把CPU虚拟化为进程，把磁盘虚拟化为文件，内存虚拟化为地址空间。<br>利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务。</p>
<p>4.异步<br>程序执行不是一贯到底，而是走走停停，向前推进速度不可预知。<br>但只要运行环境相同，OS需要保证程序运行的结果也相同。<br>（异步双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送，所以在发送的信息中就要有提示接收方开始接收的信息，如开始位，同时在结束时有停止位。）</p>
<h2 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h2><p>通电之后，如何启动。</p>
<ul>
<li><strong>DISK：</strong> 存放OS</li>
<li><strong>BIOS：</strong> 基本I/O处理系统。（检查各种外设）</li>
</ul>
<p>在DISK上，还存在<strong>Bootloader</strong>，用于加载OS。</p>
<p><img src="https://s2.loli.net/2022/03/02/N1YvmFifcIqVj2g.png" alt="image-20220302114048633"></p>
<p>开始加电时，BIOS从CS:IP（图示为x86）这个地址开始执行，之后完成一系列工作，包括：</p>
<p>POST（加电自检）：寻找显卡和执行BIOS等。</p>
<h4 id="BIOS加载Bootloader"><a href="#BIOS加载Bootloader" class="headerlink" title="BIOS加载Bootloader"></a>BIOS加载Bootloader</h4><p>Bootloader放在硬盘的第一个主引导扇区（512字节）。BIOS从硬盘的第一个扇区寻找，一下便找到Bootloader，<strong>Bootloader再负责加载OS</strong>。之后，由Bootloader将操作系统的代码和数据从硬盘加载到内存中。<strong>之后，控制权交给到OS。</strong>（跳转到OS的地址）</p>
<h4 id="操作系统的interface（系统调用、异常、中断）"><a href="#操作系统的interface（系统调用、异常、中断）" class="headerlink" title="操作系统的interface（系统调用、异常、中断）"></a>操作系统的interface（系统调用、异常、中断）</h4><p><strong>定义</strong></p>
<ul>
<li><p>系统调用（来源于<strong>应用程序的请求</strong>）</p>
<p>应用程序主动向操作系统发出请求</p>
</li>
<li><p>异常（来源于<strong>不良的应用程序</strong>）</p>
<p>非法指令或其他坏的处理状态（如：内存出错）</p>
</li>
<li><p>中断（<strong>来源于外设</strong>）</p>
<p>来自不同的硬件设备的计时器和网络的中断</p>
</li>
</ul>
<p><strong>处理时间</strong></p>
<ul>
<li>异常： 同步    （知道什么时候产生，比如 除以0）</li>
<li>中断： 异步 （不知道什么时候产生）</li>
<li>系统调用： 异步或同步（返回过程可能是异步的，即系统处理完之后再告诉应用程序，应用程序再切回）</li>
</ul>
<p><strong>响应</strong></p>
<ul>
<li>异常： 杀死或重新执行 意想不到的应用程序指令。</li>
<li>中断： 持续，对用户应用程序是透明的（见不到）。</li>
<li>系统调用： 等待和持续。</li>
</ul>
<p><strong>终端和异常处理机制</strong></p>
<p>中断、异常都有针对软硬件的处理过程。对中断和异常进行编号（中断表），编号对应特定地址，跳到处理历程，解决问题。<br>但是，中断打断了一个程序的正常执行，因此要设置保护与恢复机制。</p>
<ul>
<li><strong>中断</strong><br>硬件： ​    1. 设置中断标记（CPU初始化），将内部、外部事件设置中断标记。​    2. 产生中断号（中断事件ID），发给OS，OS来找到对应的处理历程。</li>
</ul>
<p>​        软件：</p>
<p>​            1. 保存当前处理状态（保存被打断的执行现场。由OS完成）。</p>
<p>​            2. 中断服务程序处理；</p>
<p>​            3. 清除中断标记；</p>
<p>​            4. 恢复之前保存的处理状态。<strong>因此，应用程序完全不用感知到中断的产生。</strong></p>
<ul>
<li><p><strong>异常：异常编号</strong></p>
<ol>
<li><p>保存现场</p>
</li>
<li><p>异常处理</p>
<p> 2.1. 杀死产生了异常的程序</p>
<p> 2.2. 重新执行异常指令</p>
</li>
<li><p>恢复现场</p>
</li>
</ol>
</li>
<li><p><strong>系统调用</strong></p>
<ol>
<li><p>应用程序需要操作系统提供服务，而这些服务无法由应用程序直接执行，而需要操作系统执行，这就需要操作系统提供接口，这些接口就叫做系统调用接口。</p>
</li>
<li><p>程序访问主要是通过高层次的API接口而不是直接进行系统调用。<img src="https://s2.loli.net/2022/03/02/1uaxRUnmCDSFtey.png" alt="image-20220302121501364" style="zoom: 50%;" /></p>
</li>
<li><img src="https://s2.loli.net/2022/03/02/ah5sBSGOVnDCE1z.png" alt="image-20220302134933641" style="zoom: 80%;" /></li>
</ol>
</li>
</ul>
<p>一旦执行系统调用之后，用户态会转换为内核态</p>
<p><strong>程序的用户态</strong>是指级别比较低的状态；<br><strong>操作系统的内核态</strong>是等级最高的状态。可以控制整个计算机系统。</p>
<p><strong>函数调用和系统调用是不同的。</strong></p>
<hr>
<p>函数调用：</p>
<p>ESP是栈指针寄存器，存储着栈顶的地址<br>EBP存储着栈底的地址<br>EIP是返回地址<br>栈空间主要通过这两个地址确定</p>
<p><img src="https://s2.loli.net/2022/03/03/IbMcOpuhnlwt1jW.png" alt="image-20220303164250542" style="zoom: 50%;" /><img src="https://s2.loli.net/2022/03/03/LsDaec3HFCRMP56.png" alt="image-20220303164400123" style="zoom:50%;" /><img src="https://s2.loli.net/2022/03/03/c4b6fW7Gn9uFxko.png" alt="image-20220303164422815" style="zoom:50%;" /><img src="https://s2.loli.net/2022/03/03/xSOL5GdKEeltTAv.png" alt="image-20220303164444703" style="zoom:50%;" /></p>
<p><img src="https://s2.loli.net/2022/03/03/DmQXxO8nls4RqGb.png" alt="image-20220303164500922" style="zoom:50%;" /><img src="https://s2.loli.net/2022/03/03/47FTVzo1J8n5uMc.png" alt="image-20220303164533760" style="zoom:50%;" /><img src="https://s2.loli.net/2022/03/03/GUMe26l3WhfCYOJ.png" alt="image-20220303164618366" style="zoom:50%;" /><img src="https://s2.loli.net/2022/03/03/PKYDUaqReCohXJS.png" alt="image-20220303164641942" style="zoom:50%;" /><img src="https://s2.loli.net/2022/03/03/fvly4gXiP6Vm2eY.png" alt="image-20220303164710823" style="zoom:50%;" /><img src="https://s2.loli.net/2022/03/03/opuMm2riP1X5kG9.png" alt="image-20220303164754462" style="zoom:50%;" /><img src="https://s2.loli.net/2022/03/03/KSisNqkaGQ9hVmI.png" alt="image-20220303164824766" style="zoom:50%;" /><img src="https://s2.loli.net/2022/03/03/D5c3Sv1pUmkFXOJ.png" alt="image-20220303164921104" style="zoom:50%;" /><img src="https://s2.loli.net/2022/03/03/7R5U6caxSJQpjmb.png" alt="image-20220303164934992" style="zoom:50%;" /></p>
<p>结束func1，返回主程序过程类似。</p>
<hr>
<p>函数调用是在一个栈空间完成函数之间参数的传递。</p>
<p>应用程序发出系统调用之后，<strong>应用程序、操作系统、内核都有自己的堆栈</strong>，要<strong>切换堆栈（操作系统堆栈与其不同，需要开销。即系统调用开销大于函数调用，但好处是安全、可靠）</strong>，也要实现<strong>由用户态到内核态的转换</strong>。系统处理完之后，要把数据从内核空间拷贝到用户空间，接着实现状态转换。</p>
<p><img src="https://s2.loli.net/2022/03/02/wMtQbJs6nkxq3aB.png" alt="image-20220302135601695"></p>
<p>（TLB（快表）：TLB是Translation Lookaside Buffer的简称，可翻译为“地址转换后援缓冲器。简而言之就是页表的Cache)</p>
<h4 id="为什么应用程序不能直接访问外设呢？（必须要经过操作系统？）"><a href="#为什么应用程序不能直接访问外设呢？（必须要经过操作系统？）" class="headerlink" title="为什么应用程序不能直接访问外设呢？（必须要经过操作系统？）"></a><strong>为什么应用程序不能直接访问外设呢？（必须要经过操作系统？）</strong></h4><p>在计算机运行中，内核是被信任的<strong>第三方。</strong><br>只有内核可以执行特权指令。<br>为了方便应用程序。</p>
<h2 id="计算机的体系结构及内存分层体系"><a href="#计算机的体系结构及内存分层体系" class="headerlink" title="计算机的体系结构及内存分层体系"></a>计算机的体系结构及内存分层体系</h2><h3 id="计算机基本硬件结构"><a href="#计算机基本硬件结构" class="headerlink" title="计算机基本硬件结构"></a>计算机基本硬件结构</h3><p><img src="https://s2.loli.net/2022/03/02/aIMsPG1SwfcCUkR.png" alt="image-20220302140147945"></p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存的层次结构</p>
<p><img src="https://s2.loli.net/2022/03/02/l475hJugdyRtrDL.png" alt="image-20220302140238204"></p>
<p><em>主存：物理内存</em></p>
<h4 id="操作系统需要完成的一些事情"><a href="#操作系统需要完成的一些事情" class="headerlink" title="操作系统需要完成的一些事情"></a><strong>操作系统需要完成的一些事情</strong></h4><p><img src="https://s2.loli.net/2022/03/02/S1Uh2JRsZWn5dfK.png" alt="image-20220302140612170"></p>
<p>MMU: 内存管理单元（memory management unit)  </p>
<ul>
<li>抽象</li>
<li>保护</li>
<li>共享（进程间的数据传递机制）</li>
<li>虚拟化</li>
</ul>
<h4 id="在操作系统中管理内存的不同方法"><a href="#在操作系统中管理内存的不同方法" class="headerlink" title="在操作系统中管理内存的不同方法"></a><strong>在操作系统中管理内存的不同方法</strong></h4><ul>
<li>程序重定位</li>
<li>分段</li>
<li>分页</li>
<li>虚拟内存</li>
<li>按需分页虚拟内存</li>
</ul>
<h4 id="地址空间和地址生成"><a href="#地址空间和地址生成" class="headerlink" title="地址空间和地址生成"></a>地址空间和地址生成</h4><p>几个问题：</p>
<pre><code>               1. 什么是地址空间？逻辑地址空间和物理地址空间的区别？
               2. 地址空间是怎么生成的？什么时候生成逻辑地址空间？什么时候生成物理地址空间？
               1. OS如何保护不同的地址之间不受干扰？
</code></pre>
<p><strong>地址空间</strong></p>
<p><img src="https://s2.loli.net/2022/03/02/nhPdJ8HouNbj5v7.png" alt="image-20220302141411806"></p>
<p>物理地址空间：主存、磁盘</p>
<p>逻辑地址空间：一个程序所看到的地址空间。所有的逻辑空间最终都落到物理空间内。</p>
<p>e.g.</p>
<p><img src="https://s2.loli.net/2022/03/02/ZrJUnNYSMkeXPRb.png" alt="image-20220302141627635"></p>
<p>编译和汇编阶段，地址都是以变量名代表。</p>
<p>.c   .s  .o  .exe程序都是放在硬盘之中， 最后的程序在内存中运行。可以看到运行时产生了内存偏移。</p>
<p>逻辑地址生成阶段，基本上不需要OS的参与。</p>
<p>即使程序放在内存中了，但其实还是逻辑地址，并不是物理地址。 </p>
<p><strong>CPU查找逻辑地址和物理地址的映射</strong></p>
<p><img src="https://s2.loli.net/2022/03/02/vnWsYMguHBycr7o.png" alt="image-20220302142233028"></p>
<p><strong>当CPU需要执行某条指令的时候：</strong></p>
<pre><code> 1. ALU需要知道指令的内容，需要发出请求，请求中所带的参数就是逻辑地址
 2. MMU会去查找逻辑地址映射表中是否存在逻辑地址对应的物理地址。
 3. 如果有，那么完成。如果没有，那么会产生处理过程，去内存中找（MMU没有）。如果找到了，CPU控制器会给主存发出请求，获取某一物理地址的内容。
 4. 主存会把内存的内容通过总线传给CPU，之后CPU开始执行。
</code></pre>
<p><strong>在这个过程中，OS所做的操作就是需要在这些操作之前把映射关系建立好。</strong></p>
<p><strong>OS需要确保不同程序的地址不受干扰。加以限制和约束（如图）。</strong></p>
<p><img src="https://s2.loli.net/2022/03/02/SCeGVBgIjZicb3x.png" alt="image-20220302142850662"></p>
<h4 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h4><h5 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h5><ul>
<li>无法进一步利用的空间。</li>
<li><strong>外碎片：</strong> 分配单元间的碎片；</li>
<li><strong>内碎片：</strong> 分配单元内没有使用的碎片</li>
</ul>
<h5 id="分区的动态分配"><a href="#分区的动态分配" class="headerlink" title="分区的动态分配"></a>分区的动态分配</h5><p><img src="https://s2.loli.net/2022/03/03/u654zUmcPaENIKx.png" alt="image-20220303165833008"></p>
<h6 id="首次适配算法"><a href="#首次适配算法" class="headerlink" title="首次适配算法"></a><strong>首次适配算法</strong></h6><p><img src="https://s2.loli.net/2022/03/03/Sz6OmFPwjT2Yl8y.png" alt="image-20220303165913647"></p>
<p>碰到第一个能满足需求的空块，那么就分配。如图，需求400 byte，那么从低地址到高地址，可以看到第一块1K的就满足要求。</p>
<p>需求：</p>
<p>​    按地址排序的空闲块列表。</p>
<p>​    重分配需要检查，看自由分区能合并于相邻的空闲分区。</p>
<h6 id="最优分配算法"><a href="#最优分配算法" class="headerlink" title="最优分配算法"></a><strong>最优分配算法</strong></h6><img src="https://s2.loli.net/2022/03/03/U5h7ioOv2NaRPSG.png" alt="image-20220303171858880" style="zoom: 67%;" />

<img src="https://s2.loli.net/2022/03/03/4qNwJcKeFXskOh7.png" alt="image-20220303171933297" style="zoom:80%;" />

<h6 id="最差适配算法"><a href="#最差适配算法" class="headerlink" title="最差适配算法"></a><strong>最差适配算法</strong></h6><img src="https://s2.loli.net/2022/03/03/HsWtvTSfGjYnVBL.png" alt="image-20220303172111143" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/03/08/OxbsETpmwGa4nIg.png" alt="image-20220303172157479" style="zoom:67%;" />

<h5 id="压缩式碎片整理（紧致算法）"><a href="#压缩式碎片整理（紧致算法）" class="headerlink" title="压缩式碎片整理（紧致算法）"></a><strong>压缩式碎片整理（紧致算法）</strong></h5><ul>
<li>重置程序以合并孔洞</li>
<li>要求所有程序是 动态可重置的</li>
<li>问题？ <ul>
<li>何时重置</li>
<li>开销</li>
</ul>
</li>
</ul>
<h5 id="交换式碎片整理"><a href="#交换式碎片整理" class="headerlink" title="交换式碎片整理"></a><strong>交换式碎片整理</strong></h5><img src="https://s2.loli.net/2022/03/03/95mqt2g6kfNJwTn.png" alt="image-20220303173035887" style="zoom:67%;" />

<p>利用起<strong>硬盘</strong>，将等待中的程序所占用的内存放到硬盘上。</p>
<p>问题： 哪些程序进行交换？开销？（<strong>后续虚存管理会提及</strong>）</p>
<h4 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h4><p><img src="https://s2.loli.net/2022/03/03/KX32ehQqnVZrPWc.png" alt="image-20220303175127951"></p>
<p><img src="https://s2.loli.net/2022/03/03/wXyKnGvbDuSf56h.png" alt="image-20220303175156111"></p>
<p><img src="https://s2.loli.net/2022/03/03/CXTmBH4nwcMotKz.png" alt="image-20220303175336780"></p>
<h5 id="分段（更好的分离和共享）"><a href="#分段（更好的分离和共享）" class="headerlink" title="分段（更好的分离和共享）"></a>分段（更好的分离和共享）</h5><ul>
<li>程序的分段地址空间</li>
<li>分段寻址方案</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/03/UiH7DfbACtzgO41.png" alt="image-20220303175545711"></p>
<p><img src="https://s2.loli.net/2022/03/03/kIx2Qu91T3VjorO.png" alt="image-20220303175704679"></p>
<h6 id="分段访问方案"><a href="#分段访问方案" class="headerlink" title="分段访问方案"></a>分段访问方案</h6><ul>
<li>段访问机制</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/03/9NjziLuyWEmGRYx.png" alt="image-20220303175944470"></p>
<p><img src="https://s2.loli.net/2022/03/03/d4wYauZ3NOGmXKp.png" alt="image-20220303180049323"></p>
<p>操作系统在正式寻址之前建立段表</p>
<h5 id="分页（目前cpu主要采取机制）"><a href="#分页（目前cpu主要采取机制）" class="headerlink" title="分页（目前cpu主要采取机制）"></a>分页（目前cpu主要采取机制）</h5><ul>
<li>分页地址空间</li>
<li>页寻址方案</li>
</ul>
<p>分页需要一个页号和一个页内偏移。</p>
<p><strong>和分段机制的区别：段的尺寸是可变的，页的大小是固定不变的。</strong></p>
<ul>
<li>划分物理内存到<strong>固定大小的帧</strong>（frame）<ul>
<li>大小是2的幂</li>
</ul>
</li>
<li>划分逻辑地址空间至<strong>相同大小的页</strong>（page）<ul>
<li>大小是2的幂</li>
</ul>
</li>
<li>建立方案  转换逻辑地址为物理地址（pages to frames）<ul>
<li>页表</li>
<li>MMU/TLB（TLB叫快表）</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/03/7t9D6NLhYdX5mVC.png" alt="image-20220303181106638"></p>
<p>2^S 一帧的大小   f为帧号   o是页内偏移</p>
<p><img src="https://s2.loli.net/2022/03/03/dBqPigH7hwu3cAG.png" alt="image-20220303181504551"></p>
<p><img src="https://s2.loli.net/2022/03/03/6IMxGOSE3Q1mrpL.png" alt="image-20220303195530575"></p>
<img src="https://s2.loli.net/2022/03/03/eOzKj6xCQWZp3Ri.png" alt="image-20220303195601460"  />

<p><img src="https://s2.loli.net/2022/03/03/5I1DtVNxqXL9sJA.png" alt="image-20220303200419753"></p>
<p>逻辑地址空间一般<strong>大于</strong>物理地址空间（存不下的会使用虚拟内存）</p>
<h6 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h6><ul>
<li>页表概述</li>
<li>转换后备缓冲区</li>
<li>二级/多级 页表  （时间换空间）</li>
<li>反向页表</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/04/Li9nNgXMF5oGqKP.png" alt="image-20220304154133037"></p>
<p>逻辑地址大小为64KB，物理地址大小为32KB</p>
<p>（4，0）-&gt; 可以找到第四页100，页帧号均为0，说明不存在。产生内存访问异常。</p>
<p>（3，1023)-&gt;可以找到第三页011，页帧号为00100，页帧内偏移和页偏移相同为1023，可以得到（4，1023）</p>
<p><strong>分页机制的性能问题</strong></p>
<p>​    1）访问一个内存单元需要两次内存访问：一次用于获取页表项，一次用于访问数据</p>
<p>​    2）页表可能非常大。如64位及其如果每页1024字节，那么一个页表的大小为（2^64 /2^10 = 2^54），这是不合理的。     每个程序都有自己的页表，那么页表也非常大。</p>
<p>可以使用<strong>缓存（caching）</strong> ， <strong>间接（indirecting）访问</strong>   两种方法来解决</p>
<p><strong>TLB（Translation Look-aside Buffer）</strong></p>
<p>把经常访问的页表项放到TLB中<img src="https://s2.loli.net/2022/03/04/ucAG5BswJgFTNZI.png" alt="image-20220304155407574"></p>
<p>为了减少TLB的缺失，要注意程序的局部性。</p>
<p><strong>二级页表</strong></p>
<p><img src="https://s2.loli.net/2022/03/04/dmzDNhUc9qgFvi4.png" alt="image-20220304155941131"></p>
<p><strong>页表基寄存器（<em>PTBR</em>）指向页表. 页表长度寄存器（PTLR）指示页表的大小</strong></p>
<p>一级页表存的是二级页表的起始地址</p>
<p>二级页表可以节省空间</p>
<p><strong>e.g.</strong>  页面的大小为4KB，每个页表项为4B，所以每个页面中可以存放1K个（1024）个页表项，因此每1K个连续的页表项为一组，每组刚好占一个页面，这样就<strong>需要为离散的页表再建立一张页表</strong>，称为<strong>页目录表</strong>。 </p>
<p>32位的逻辑地址空间，页表项大小为4B，页面大小4KB，则页内地址占12位将页表分为分为1024个表，每个表中包含1024个页表项，形成二级页表。二级页表结构的逻辑地址结构如下图：<img src="https://s2.loli.net/2022/03/04/W6zU5PER4tTd9QD.png" alt="image-20220304164358274" style="zoom: 67%;" /></p>
<p><strong>多级页表</strong></p>
<p><img src="https://s2.loli.net/2022/03/04/2CAHaQ5Ljp1qfso.png" alt="image-20220304164955556"></p>
<p><strong>反向页表</strong></p>
<p><img src="https://s2.loli.net/2022/03/04/j7cG3QUa4DTntzA.png" alt="image-20220304165316766"></p>
<p>以物理页号来查找逻辑页号</p>
<p><img src="https://s2.loli.net/2022/03/04/bjzYRVrOJkutGNs.png" alt="image-20220304165432223"></p>
<p>页容量只与物理页地址大小相关。好处是节省空间</p>
<p><strong>问题：</strong>如何根据page frame号查找page号？</p>
<p><img src="https://s2.loli.net/2022/03/04/WZ5n7DerubvAymL.png" alt="image-20220304165636788"></p>
<p><img src="https://s2.loli.net/2022/03/04/CQEAl6ixoU1SjYJ.png" alt="image-20220304165748983"></p>
<p><strong>基于关联内存的方案（设计成本太大）</strong></p>
<p><img src="https://s2.loli.net/2022/03/04/yUsAq9TNxci7J8S.png" alt="image-20220304165814703"></p>
<p><strong>基于哈希（hash）查找的方案</strong></p>
<p>page frame number （hash）-&gt; page number</p>
<p><img src="https://s2.loli.net/2022/03/04/hQC1ngWTutvkPDo.png" alt="image-20220304170118030"></p>
<p><img src="https://s2.loli.net/2022/03/04/KsjrUOiJ5v2lyke.png" alt="image-20220304170216697"></p>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><ul>
<li>起因 （程序规模的增长远大于存储器容量的增长）</li>
<li>覆盖技术</li>
<li>交换技术</li>
<li>虚存技术<ul>
<li>目标</li>
<li>程序局部性原理</li>
<li>基本概念</li>
<li>基本特征</li>
<li>虚拟页式内存管理</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/04/BVuDflk2wrYzA6P.png" alt="image-20220304170733457"></p>
<p><img src="https://s2.loli.net/2022/03/04/q8aPfWZp9DrTRnU.png" alt="image-20220304193756065"></p>
<p>把一些希望通过OS的管理把不常用的数据放在硬盘，常用的数据放在内存中，这样使得有限的内存能够存放常用的代码和数据。这种管理方式需要CPU（硬件）、MMU（硬件）、OS内核协同管理之下可以实现。</p>
<p><img src="https://s2.loli.net/2022/03/04/NdiuZtqmCxapDIg.png" alt="image-20220304194234186"></p>
<h5 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h5><p><img src="https://s2.loli.net/2022/03/07/HSTGwWX5ZEo81jy.png" alt="image-20220307195820595"></p>
<p>e.g.</p>
<p><img src="https://s2.loli.net/2022/03/07/vI1eqLifC68gpGj.png" alt="image-20220307195843199"></p>
<p>A在常驻区（固定区），把相互之间没有调用关系的程序放到同一个区，在需要调用前，再调入覆盖区，替换掉覆盖区原有的段。</p>
<p>注：另一种覆盖方法</p>
<p>​        A占一个分区20K</p>
<p>​        B、E和F 共用一个分区50K</p>
<p>​        C和D 共用一个分区30K</p>
<p>覆盖技术的缺点：</p>
<ul>
<li>由程序员来把一个大的程序划分为若干个小地功能模块，并确定各个模块之间的覆盖关系，费时费力，增加了编程复杂度。</li>
<li>覆盖模块由外存装入内存，实际上是以时间来换取空间。</li>
</ul>
<h5 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h5><p><img src="https://s2.loli.net/2022/03/07/O5qKgjuCfTarBHt.png" alt="image-20220307200955050"></p>
<p>交换技术的问题：</p>
<ul>
<li>何时发生交换？ 因为内存和外存的读写速度差异太大，因此频繁的交换会造成巨大的开销，只当内存空间不够或有危险的时候换出。</li>
<li>如何划分硬盘，交换区的大小？</li>
<li>程序换入时的重定位。换出后和换入时的内存地址一定要是一样吗？可以采取<strong>动态</strong>地址映射来解决。</li>
</ul>
<p><strong>覆盖和交换的比较</strong></p>
<p><img src="https://s2.loli.net/2022/03/07/4EXJcpPlqmYMn7e.png" alt="image-20220307201733036"></p>
<p>交换发生在内存的程序之间，覆盖发生在运行中的程序之内。</p>
<h5 id="虚存技术"><a href="#虚存技术" class="headerlink" title="虚存技术"></a>虚存技术</h5><p><img src="https://s2.loli.net/2022/03/07/AZG8CK2vFgeTXbO.png" alt="image-20220307201950432"></p>
<p><strong>虚存技术的目标：</strong></p>
<ul>
<li>像覆盖技术那样，不是把程序的所有内容都放在内存中，但是是自动执行的，无需程序员干涉；</li>
<li>像交换技术那样，实现进程在内存与外存之间的交换，但是不是以一个程序为粒度，而是以<strong>页</strong>为粒度。</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/07/6B3ncaOjzT5HJI2.png" alt="image-20220307203523022"></p>
<p><strong>e.g.</strong> </p>
<p><img src="https://s2.loli.net/2022/03/07/UEPmGeMI3rgXCpb.png" alt="image-20220307204113840"></p>
<p><img src="https://s2.loli.net/2022/03/07/O1g924UVHDzP5uE.png" alt="image-20220307204215209"></p>
<p>4byte x 1024 = 4k，正好是一页</p>
<p><img src="https://s2.loli.net/2022/03/07/HO2bq5XZ1g4f3xW.png" alt="image-20220307204738244"></p>
<p>以<strong>页</strong>或<strong>段</strong></p>
<p><img src="https://s2.loli.net/2022/03/07/18GzoIgjBskR5OQ.png" alt="image-20220307205429633"></p>
<h6 id="虚存技术-虚拟页式内存管理"><a href="#虚存技术-虚拟页式内存管理" class="headerlink" title="虚存技术--虚拟页式内存管理"></a>虚存技术--虚拟页式内存管理</h6><p><img src="https://s2.loli.net/2022/03/08/G2c4lhfYxLtXR5g.png" alt="image-20220308094031524"></p>
<p><img src="https://s2.loli.net/2022/03/08/IgP3GW4YlXdERH1.png" alt="image-20220308094623664"></p>
<p><img src="https://s2.loli.net/2022/03/08/eWMVhot1APRsy2Q.png" alt="image-20220308095025342"></p>
<p><img src="https://s2.loli.net/2022/03/08/U7KzqkLhWScCwMn.png" alt="image-20220308095238169"></p>
<p><img src="https://s2.loli.net/2022/03/08/QHeYILrGJ9BKq3f.png" alt="image-20220308100151048"></p>
<p><strong>有效存储器访问时间（effective memory access time）</strong></p>
<p>EAT = 访存时间 * 页表命中几率 + page fault处理时间 * page fault概率</p>
<h6 id="页面置换算法（局部页面置换算法）"><a href="#页面置换算法（局部页面置换算法）" class="headerlink" title="页面置换算法（局部页面置换算法）"></a>页面置换算法（局部页面置换算法）</h6><ul>
<li>最佳页面置换算法（OPT）</li>
<li>先进先出算法</li>
<li>最近最久未使用算法</li>
<li>时钟页面置换算法</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/08/wxOXJ3Vr8EbIkvS.png" alt="image-20220308101453507"></p>
<p>OPT以时间来记录，替换掉<strong>距离下一次访问最长时间内不被访问</strong>的页面</p>
<p><img src="https://s2.loli.net/2022/03/08/Rt6Dpg5xiBWEGM7.png" alt="image-20220308102021090"></p>
<p>FIFO（队列），产生的缺页多</p>
<p><img src="https://s2.loli.net/2022/03/08/aRmzq2ywOjSYThH.png" alt="image-20220308102745774"></p>
<p>LRU是OPT的一个近似，LRU向之前看，OPT向后看</p>
<p>LRU算法需要记录每个页面使用时间的先后顺序，开销比较大。</p>
<p><img src="https://s2.loli.net/2022/03/08/wbltRmcidhJOCBW.png" alt="image-20220308104438059"></p>
<p>二次机会法（改进型CLOCK置换算法），在使用位的基础上再增加一个修改位。</p>
<ul>
<li> 最近未被访问，也未被修改（u=0,m=0）</li>
<li>最近被访问，但未被修改（u=1,m=0）</li>
<li>最近未被访问，但被修改（u=0,m=1）</li>
<li>最近被访问，被修改（u=1,m=1）</li>
</ul>
<img src="https://s2.loli.net/2022/03/08/xzlrbJp8GHv9TiD.png" alt="image-20220308145535269"  />



<p>计数器（寄存器的开销太大），每次寻找计数值最小的页面，开销也很大。</p>
<p>LFU存在的问题：一个页面在进程开始时使用的很多，但以后就不用了</p>
<h6 id="页面置换算法（全局页面置换算法）"><a href="#页面置换算法（全局页面置换算法）" class="headerlink" title="页面置换算法（全局页面置换算法）"></a>页面置换算法（全局页面置换算法）</h6><ul>
<li>局部页替换算法的问题</li>
<li>工作集模型</li>
<li>工作集页置换算法</li>
<li>缺页率页面置换算法</li>
<li>抖动问题 </li>
</ul>
<p><strong>局部页面置换算法问题</strong></p>
<ul>
<li>物理页帧大小对于置换算法性能影响极大。实际情况中，程序是分段进行的，物理页帧可变的，那该如何进行物理页帧大小分配？</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/08/g42mOYiDETKpnUM.png" alt="image-20220308151845704"></p>
<p><img src="https://s2.loli.net/2022/03/08/7DcNz5snBkEvW6u.png" alt="image-20220308152010332"></p>
<p><strong>工作集：</strong>一个进程当前正在使用的逻辑页面集合</p>
<p><img src="https://s2.loli.net/2022/03/08/cxWs61a9y4JqBwv.png" alt="image-20220308152428943"></p>
<p><img src="https://s2.loli.net/2022/03/08/vR8XYbyOhWIVKln.png" alt="image-20220308152448344"></p>
<p><img src="https://s2.loli.net/2022/03/08/eguEbnDWkCjmoM6.png" alt="image-20220308152722739"></p>
<p><strong>工作集页置换算法</strong></p>
<p><img src="https://s2.loli.net/2022/03/08/j4ZAQtDBzm62i3C.png" alt="image-20220308153419283"></p>
<p>t=-2，访问page e</p>
<p>t=-1，访问page d</p>
<p>t=0，访问page a；  那么time0，初始化有三个页面</p>
<p>t=1，page c产生缺页，然后加入了page c， t=2时，未产生缺页，但是因为 τ = 4，所以要拿出page e。在拿出page e时候要判断该页是否修改过，若修改过那么需要进行内存和硬盘的同步。</p>
<p><strong>缺页率页面置换算法</strong></p>
<p><img src="https://s2.loli.net/2022/03/08/HQKTkcum7t5RpNw.png" alt="image-20220308153913289"></p>
<p><img src="https://s2.loli.net/2022/03/08/cjyVv4WgTK7AOZN.png" alt="image-20220308154011120"></p>
<p>程序的编写，局部性影响缺页率。</p>
<p>若运行的程序的缺页率过高。则通过<strong>增加工作集来分配更多的物理页面</strong>:若运行的程序的<strong>缺页率过低</strong>，则通过<strong>减少工作集来减少它的物理页面数</strong>。力图使运行的每个程序的缺页率保持在一个合理的范围内。</p>
<p><img src="https://s2.loli.net/2022/03/08/8Cl2tVgRF6ha7L5.png" alt="image-20220308155040892"></p>
<p><img src="https://s2.loli.net/2022/03/08/YyrUE6HLseDAORf.png" alt="image-20220308155156719"></p>
<p><strong>抖动问题</strong></p>
<p><img src="https://s2.loli.net/2022/03/08/EGCro1RqpTV7SWO.png" alt="image-20220308155720956"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><img src="https://s2.loli.net/2022/03/08/um3erCNcQG7EMvl.png" alt="image-20220308161130626"></p>
<h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p>一个具有一定独立功能的程序在一个数据集合上一次动态执行过程</p>
<h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><p><img src="https://s2.loli.net/2022/03/08/ux6iNUv1TzoMCQY.png" alt="image-20220308161040945"></p>
<p><img src="https://s2.loli.net/2022/03/08/Gg7xoqQjsNZFkaY.png" alt="image-20220308161405802"></p>
<h3 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h3><ul>
<li>动态性：可动态地创建、结束进程。</li>
<li>并发性：进程可以被独立调度并占用处理机运行。</li>
<li>独立性：不同进程的工作不相互影响。（页表等手段加以访问空间限制）</li>
<li>制约性：因访问共享数据/资源或进程间同步而产生制约。</li>
</ul>
<h3 id="进程控制结构"><a href="#进程控制结构" class="headerlink" title="进程控制结构"></a>进程控制结构</h3><p>描述进程的数据结构：PCB（Process Control Block）。PCB是进程存在的唯一标志。</p>
<p><img src="https://s2.loli.net/2022/03/08/3t1FLQu6SmX4qsw.png" alt="image-20220308162648121"></p>
<p><img src="https://s2.loli.net/2022/03/08/OqlI6f259AcVsty.png" alt="image-20220308162707592"></p>
<p><img src="https://s2.loli.net/2022/03/08/Ty12F4mtzKpbgGZ.png" alt="image-20220308165341384"></p>
<p><img src="https://s2.loli.net/2022/03/08/U2zaTK1uICxrpeQ.png" alt="image-20220308165641433"></p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul>
<li>进程的生命期管理</li>
<li>进程状态变化模型</li>
<li>进程挂起模型</li>
</ul>
<h4 id="进程的生命期管理"><a href="#进程的生命期管理" class="headerlink" title="进程的生命期管理"></a>进程的生命期管理</h4><p>创建—运行—等待—唤醒—结束</p>
<p><strong>进程创建</strong></p>
<p>引起进程创建的3个主要事件：</p>
<ol>
<li>系统初始化时；</li>
<li>用户请求创建一个新进程；</li>
<li>正在运行的进程执行了创建进程的系统调用。</li>
</ol>
<p><strong>进程运行</strong></p>
<p>内核选择一个就绪进程，让它占用处理机并执行。如何选择？此类问题将在调度算法中讨论。</p>
<p><strong>进程等待</strong></p>
<p>在以下情况下，进程等待（阻塞）：</p>
<ol>
<li>请求并等待系统服务，无法马上完成；</li>
<li>启动某种操作，无法马上完成；</li>
<li>需要的数据没有到达。</li>
</ol>
<p><strong>进程只能自己阻塞自己</strong>，因为只用进程自身才能知道何时需要等待某种事件的发生。</p>
<p><strong>进程唤醒</strong><br>进程唤醒的原因：</p>
<ul>
<li>被阻塞进程需要的资源可以被满足。</li>
<li>被阻塞进程等待的事件到达。</li>
<li>将该进程的PCB插入到就绪队列。</li>
<li>进程只能被别的进程或者操作系统唤醒。</li>
</ul>
<p><strong>进程结束</strong><br>在以下四种情况下，进程结束：</p>
<ul>
<li>正常退出（自愿的）；</li>
<li>错误退出（自愿的）；</li>
<li>致命错误（强制性的）；</li>
<li>被其他进程所杀（强制性的）。</li>
</ul>
<h4 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h4><p><img src="https://s2.loli.net/2022/03/08/eKsyV9PMW4OxT2B.png" alt="image-20220308195829362"></p>
<p><img src="https://s2.loli.net/2022/03/08/kULZbIFpTYrXNyn.png" alt="image-20220308195912986"></p>
<h4 id="进程挂起模型"><a href="#进程挂起模型" class="headerlink" title="进程挂起模型"></a>进程挂起模型</h4><p>定义：进程没有占用内存空间。处在挂起状态的进程映像在磁盘上。</p>
<p><img src="https://s2.loli.net/2022/03/08/1r4OimSXvIzPn72.png" alt="image-20220308202421901"></p>
<p><img src="https://s2.loli.net/2022/03/08/bIpQVoXdKmCtevZ.png" alt="image-20220308202732327"></p>
<img src="https://s2.loli.net/2022/03/13/QUwKAG1NZf2rpYC.png" alt="image-20220308202950585"  />

<p><img src="https://s2.loli.net/2022/03/08/1VyXThjmfAY7vUg.png" alt="image-20220308203027637"></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>定义：线程是进程当中的一条执行流程。</p>
<p><img src="https://s2.loli.net/2022/03/10/XtKV4kJS7ur9ZQv.png" alt="image-20220310101623209"></p>
<p>TCB（thread control block）</p>
<p><img src="https://s2.loli.net/2022/03/10/oxF7nE8iqhDIc43.png" alt="image-20220310101655975"></p>
<p><img src="https://s2.loli.net/2022/03/10/CPXIjVQOy4WumTa.png" alt="image-20220310102058483"></p>
<p>需要有各自独立的寄存器、堆栈，但是能共享代码段、数据段、网络资源等等，</p>
<p><img src="https://s2.loli.net/2022/03/10/7R6pij4xnS5tWmP.png" alt="image-20220310102451819"></p>
<p>线程的创建和终止时间较短是因为不需要去考虑资源的创建和释放问题。<br>线程的切换时间不需要切换内存管理所需要的页表，而进程需要切换页表，这一操作开销很大。</p>
<h4 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h4><p>用户线程和内核线程的关系</p>
<ul>
<li>1对1</li>
<li>1对多</li>
<li>多对多</li>
</ul>
<p>操作系统看不到TCB，OS只能看到进程信息，看不到进程内的线程信息。所以说整个线程的调度和管理主要是由线程库（用户级的线程库）管理，OS不直接参与。</p>
<p><strong>用户线程：</strong></p>
<p><img src="https://s2.loli.net/2022/03/10/wAPqcSkNTUjxD5p.png" alt="image-20220310103051707"></p>
<p><img src="https://s2.loli.net/2022/03/10/915iU4YrHq7TNwV.png" alt="image-20220310103118949"></p>
<p><img src="https://s2.loli.net/2022/03/10/DW6BLT3CuMjfU9d.png" alt="image-20220310103409435"></p>
<p><strong>内核线程：</strong></p>
<p><img src="https://s2.loli.net/2022/03/10/lvAnMsgaJm1ZGxK.png" alt="image-20220310103538101"></p>
<p>一个PCB管理了一个TCB的list，但是在具体的线程调度时，还是TCB进行</p>
<p><strong>轻量级进程</strong></p>
<p>定义：是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持。</p>
<p><img src="https://s2.loli.net/2022/03/10/mOTxRvbJt3s984V.png" alt="image-20220310104353987"></p>
<p><strong>内核线程</strong><br>内核线程只运行在内核态，不受用户态上下文的拖累。</p>
<ul>
<li><p>处理器竞争：可以在全系统范围内竞争处理器资源；</p>
</li>
<li><p>使用资源：唯一使用的资源是内核栈和上下文切换时保持寄存器的空间</p>
</li>
<li><p>调度：调度的开销可能和进程自身差不多昂贵</p>
</li>
<li><p>同步效率：资源的同步和数据共享比整个进程的数据同步和共享要低一些。</p>
</li>
</ul>
<p><strong>轻量级进程</strong><br>轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。内核线程只能由内核管理并像普通进程一样被调度。</p>
<p>轻量级进程由clone()系统调用创建，参数是CLONE_VM，即与父进程是共享进程地址空间和系统资源。</p>
<p><strong>与普通进程区别：LWP只有一个最小的执行上下文和调度程序所需的统计信息</strong>。</p>
<ul>
<li><p>处理器竞争：因与特定内核线程关联，因此可以在全系统范围内竞争处理器资源</p>
</li>
<li><p>使用资源：与父进程共享进程地址空间</p>
</li>
<li><p>调度：像普通进程一样调度</p>
</li>
</ul>
<p><strong>用户线程</strong><br>用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁全又库函数在用户空间完成，不需要内核的帮助。因此这种线程是极其低消耗和高效的。</p>
<ul>
<li><p>处理器竞争：单纯的用户线程是建立在用户空间，其对内核是透明的，因此其所属进程单独参与处理器的竞争，而进程的所有线程参与竞争该进程的资源。</p>
</li>
<li><p>使用资源：与所属进程共享进程地址空间和系统资源。</p>
</li>
<li><p>调度：由在用户空间实现的线程库，在所属进程内进行调度</p>
</li>
</ul>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p><img src="https://s2.loli.net/2022/03/10/O1mIJrEBeCNUKvD.png" alt="image-20220310113333580"></p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><h4 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h4><h4 id="加载和执行进程"><a href="#加载和执行进程" class="headerlink" title="加载和执行进程"></a>加载和执行进程</h4><h4 id="等待和终止进程"><a href="#等待和终止进程" class="headerlink" title="等待和终止进程"></a>等待和终止进程</h4><h2 id="协程补充"><a href="#协程补充" class="headerlink" title="协程补充"></a>协程补充</h2><p><strong>进程：</strong> 进程是一个具有一定独立功能的程序关于某个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%9B%86&spm=1001.2101.3001.7020">数据集</a>合上的一次运行活动，是系统资源分配和独立运行的最小单位；<br><strong>线程：</strong> 线程是进程的一个执行单元，是任务调度和系统执行的最小单位；<br><strong>协程：</strong> 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。</p>
<p><strong>进程与线程的区别</strong></p>
<p>1、根本区别： 进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。<br>2、地址空间区别： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该 进程的地址空间，一个线程的非法操作会使整个进程崩溃。<br>3、上下文切换开销区别： 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</p>
<p>当系统线程较少的时候没有什么问题，但是当线程数量非常多的时候，却产生了问题。<strong>一是系统线程会占用非常多的内存空间，二是过多的线程切换会占用大量的系统时间。</strong></p>
<p>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</p>
<p>实际上协程并不是什么银弹，协程只有在等待IO的过程中才能重复利用线程，上面我们已经讲过了，线程在等待IO的过程中会陷入阻塞状态，意识到问题没有？</p>
<p>假设协程运行在线程之上，并且协程调用了一个阻塞IO操作，这时候会发生什么？实际上操作系统并不知道协程的存在，它只知道线程，<strong>因此在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的。</strong></p>
<p>因此在协程中不能调用导致线程阻塞的操作。也就是说，协程只有和异步IO结合起来，才能发挥最大的威力。</p>
<p>那么如何处理在协程中调用阻塞IO的操作呢？一般有2种处理方式：</p>
<ol>
<li><strong>在调用阻塞IO操作的时候，重新启动一个线程去执行这个操作，等执行完成后，协程再去读取结果。这其实和多线程没有太大区别。</strong></li>
<li><strong>对系统的IO进行封装，改成异步调用的方式，这需要大量的工作，最好寄希望于编程语言原生支持。</strong><br>（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/172471249%EF%BC%89">https://zhuanlan.zhihu.com/p/172471249）</a></li>
</ol>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><ul>
<li><p>上下文切换</p>
<ul>
<li><p>切换CPU的当前任务，从一个进程/线程到另一个。</p>
</li>
<li><p>保存当前进程/线程在PCB/TCB中的执行上下文（CPU状态）。</p>
</li>
<li><p>读取下一个进程/线程的上下文。</p>
</li>
</ul>
</li>
<li><p>CPU调度</p>
<ul>
<li>从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程。</li>
<li>调度程序：挑选进程/线程的内核函数（通过一些调度策略）</li>
<li>什么时候进行调度？</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/10/rDEVQqh4awOu2CR.png" alt="image-20220310142248386"></p>
<h3 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h3><ul>
<li>CPU使用率</li>
</ul>
<p>​        CPU处于<strong>忙状态所占时间</strong>的百分比。</p>
<ul>
<li>吞吐量</li>
</ul>
<p>​        在<strong>单位时间</strong>内完成的进程数量。</p>
<ul>
<li>周转时间</li>
</ul>
<p>​        一个进程<strong>从初始化到结束</strong>， <strong>所花费的时间</strong>。</p>
<ul>
<li>等待时间</li>
</ul>
<p>​        进程在<strong>就绪队列中</strong>的时间。</p>
<ul>
<li>响应时间</li>
</ul>
<p>​        从一个请求<strong>被提交到第一次产生响应</strong>  所花费的时间。</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul>
<li>FCFS        先来先服务</li>
<li>SPN(SJF)   SRT    短进程优先（短作业优先）   短剩余时间<ul>
<li>可以是抢占的（SRT）或者是不可抢占的（SPN）</li>
</ul>
</li>
<li>HRRN      最高响应比优先</li>
<li>Round Robin    轮循（时间片轮转调度算法）</li>
<li>Multilevel Feedback Queues     多级反馈队列<ul>
<li>是时间片轮转调度算法和优先级调度算法的综合和发展，动态调整进程优先级和时间片大小。</li>
</ul>
</li>
<li>Fair Share Scheduling      公平共享调度</li>
</ul>
<h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><p>实时调度所面对的系统为Real Time System（实时系统）。</p>
<p>对于实时系统：</p>
<ul>
<li>时间约束的及时性（deadlines）很重要；</li>
<li>速度和平均性能相对不重要；</li>
<li>时间约束的可预测性是其主要特性。</li>
</ul>
<p>实时系统可分为：</p>
<ul>
<li>强实时系统：需要在保证的时间内完成重要的任务，必须完成；</li>
<li>弱实时系统：要求重要的进程的优先级更高，尽量完成，并非必须。</li>
</ul>
<p>比如视频掉帧，就是弱实时系统的体现。</p>
<p><img src="https://s2.loli.net/2022/03/10/t5BTvwfziFDg2d4.png" alt="image-20220310155516515"></p>
<h3 id="多处理器调度与优先反转"><a href="#多处理器调度与优先反转" class="headerlink" title="多处理器调度与优先反转"></a>多处理器调度与优先反转</h3><p><img src="https://s2.loli.net/2022/03/10/x8Q4eKGsMRonuXq.png" alt="image-20220310160002562"></p>
<p>如何避免优先级反转：</p>
<p>优先级继承</p>
<p>优先级天花板</p>
<p><img src="https://s2.loli.net/2022/03/10/idSmTJx3oOjE8XK.png" alt="image-20220310160622217"></p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程之间的交互会造成共享资源的访问。</p>
<p><img src="https://s2.loli.net/2022/03/10/kVb3q2jnSUM7Haw.png" alt="image-20220310165436516"></p>
<p><img src="https://s2.loli.net/2022/03/10/7IZBL6Cc8yU2Jkm.png" alt="image-20220310165822882"></p>
<p>next_pid保存的是当前最大的进程ID。但是这种方法，在两个进程并行时，会产生冲突。</p>
<p>所谓<strong>原子操作</strong>是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch </p>
<p><strong>临界资源</strong></p>
<p>一次仅允许一个进程使用的资源称为临界资源。</p>
<p><strong>临界区</strong></p>
<p>临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域。</p>
<p><strong>互斥</strong></p>
<p>当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源。</p>
<p><strong>死锁</strong></p>
<p>两个或以上的进程，在相互等待完成任务，而最终没法将自身任务进行下去。</p>
<p><strong>饥饿（starvation）</strong></p>
<p>一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行。</p>
<h4 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h4><ul>
<li><p><strong>硬件实现方法</strong></p>
<p><strong>禁用中断（中断屏蔽）</strong></p>
<p>当一个进程在使用处理机执行它的临界区代码时，防止其他进程进入临界区进行访问的最简单方法是，禁止一切中断发生。因为CPU只在发生中断时引起进程切换，但是在多CPU情况下，中断屏蔽不可使用，因为其他CPU还能访问临界区。</p>
</li>
<li><p><strong>软件方法</strong></p>
</li>
</ul>
<p>​        1. 单标志法</p>
<p>​        2. 双标志法先检查</p>
<p>​        3. 双标志发后检查</p>
<p>​        4. Peterson’s Algorithm    </p>
<p>​                P82</p>
<ul>
<li><strong>更高级的抽象</strong></li>
</ul>
<p>​        <img src="https://s2.loli.net/2022/03/11/YJWKlU9Lphq3EIe.png" alt="image-20220311155942022"></p>
<p><img src="https://s2.loli.net/2022/03/11/QZbigJYutK4lo8a.png" alt="image-20220311160026267"></p>
<p><img src="https://s2.loli.net/2022/03/11/YNoMLIdcZkSnJO1.png" alt="image-20220311160849414"></p>
<p>test-and-set是不允许执行中断的</p>
<p><img src="https://s2.loli.net/2022/03/11/PHVkOCrwWB1fhNj.png" alt="image-20220311161512979"></p>
<p><img src="https://s2.loli.net/2022/03/11/lAjUxBDno5ratSy.png" alt="image-20220311162052788"></p>
<p><img src="https://s2.loli.net/2022/03/11/IwqOvLUKgZxCtXJ.png" alt="image-20220311171025863"></p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p><img src="https://s2.loli.net/2022/03/11/YKLa4Isxg5zyhCv.png" alt="image-20220311171229318"></p>
<p> <img src="https://s2.loli.net/2022/03/11/SGar3xLyJYQVnAM.png" alt="image-20220311171848157"></p>
<p><img src="https://s2.loli.net/2022/03/11/rn2yhU6Qbl597Zk.png" alt="image-20220311172004248"></p>
<p><img src="https://s2.loli.net/2022/03/11/ZnSd6vK3g2q9HLz.png" alt="image-20220311172547273"></p>
<p><img src="https://s2.loli.net/2022/03/11/nU3pYIulHaoBE5R.png" alt="image-20220311172747406"></p>
<p><strong>消费者问题需要引入同步和互斥操作。</strong></p>
<p><img src="https://s2.loli.net/2022/03/11/E1KYUl8aNufwoGB.png" alt="image-20220311172825230"></p>
<p><img src="https://s2.loli.net/2022/03/11/yosWSEJPKaBvV4b.png" alt="image-20220311173017337"></p>
<p><img src="https://s2.loli.net/2022/03/11/Cw23VPlSAZJXN7B.png" alt="image-20220311173234150"></p>
<p><img src="https://s2.loli.net/2022/03/12/AZSTVjsUNowgneL.png" alt="image-20220312095247585"></p>
<p><img src="https://s2.loli.net/2022/03/12/dRcnOCQilL7UP2D.png" alt="image-20220312095513514"></p>
<p><strong>P,V操作的顺序有影响，P操作能够产生阻塞。</strong>若Deposit交换前两个P操作，即先做mutex-&gt;P()，在执行emptyBuffers-&gt;p()，若生产者非常快，把fullbuffer填满了，那么下一个操作会执行mutex-&gt;P()，没问题，在下一个操作对emptyBuffer执行P操作，此时因为buffer满了，那么emptyBuffer为0，导致挂起，在此之后，消费者是没法执行操作的。<strong>陷入了死锁。</strong></p>
<p><img src="https://s2.loli.net/2022/03/12/sZL8Od37KExCDBR.png" alt="image-20220312101537375"></p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>比信号量的抽象程度更高。</p>
<p><strong>目的：</strong>分离互斥和条件同步</p>
<p>定义：包含了一系列的共享变量（共享资源的数据结构），以及对该共享变量实时操作的一组过程。</p>
<p><strong>要访问管程管理的那些函数只能有一个线程。</strong></p>
<p><img src="https://s2.loli.net/2022/03/12/zKpSorjuYqJ3WIi.png" alt="image-20220312103414643"></p>
<p> <img src="https://s2.loli.net/2022/03/12/k8GCcYJqBITFzi4.png" alt="image-20220312103405772"></p>
<p>wait时一定要release，不然会导致无法释放lock，导致死锁。</p>
<p><strong>用管程来解决生产者、消费者问题：</strong></p>
<p><img src="https://s2.loli.net/2022/03/12/O49JkD1wofKXWpP.png" alt="image-20220312103705994"></p>
<p>操作时一定要先上锁，优先满足进程互斥条件。</p>
<p><strong>Hansen和Hoare方法</strong></p>
<p>在管程中，A线程将B线程唤醒，是先执行A还是先执行B？Hanse和Hoare两位科学家给出了不同的解决办法。</p>
<p><img src="https://s2.loli.net/2022/03/12/vLAGtQp6x57rNJn.png" alt="image-20220312104515844"></p>
<p>其中，Hansen机制较为容易实现（较为简单直观），实践中大量使用。</p>
<p><img src="https://s2.loli.net/2022/03/12/fdKkSUrLRXxqGmy.png" alt="image-20220312104842461"></p>
<p>hansen使用while，release之后会造成多个等待进程抢占cpu资源。</p>
<p>hoare使用if，release之后只会有一个等待进程使用CPU。</p>
<p><img src="https://s2.loli.net/2022/03/12/mK4bQSBw9EXJyk5.png" alt="image-20220312104952749"></p>
<h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul>
<li>死锁问题</li>
<li>系统模型</li>
<li>死锁特征</li>
<li>死锁处理方法<ul>
<li>死锁预防</li>
<li>死锁避免</li>
<li>死锁检测</li>
<li>死锁恢复</li>
</ul>
</li>
</ul>
<p>定义：是指多个进程因竞争资源而造成的一种僵局（互相等待）。</p>
<p><img src="https://s2.loli.net/2022/03/12/Dfmqr3wsJjby56W.png" alt="image-20220312112144926"></p>
<p>需要一个资源的情况下，没有死锁。</p>
<p><img src="https://s2.loli.net/2022/03/12/FTXI3tMgAEck2yw.png" alt="image-20220312112414132"></p>
<p><strong>死锁一定产生环，有环不一定有死锁。</strong></p>
<h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><p>有死锁产生，一定有这四种条件满足。满足这四种条件，不一定产生死锁。</p>
<ol>
<li><p>互斥条件</p>
<p>在一个时间只能有一个进程使用资源。</p>
</li>
<li><p>不剥夺条件</p>
<p>以恶搞资源只能被进程自愿释放。</p>
</li>
<li><p>请求并保持条件</p>
<p>进程保持至少一个资源正在等待获取其他进程持有的额外资源。</p>
</li>
<li><p>循环等待条件</p>
<p>存在等待进程集合 [P0, P1, … , PN] ，产生环。</p>
</li>
</ol>
<h3 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h3><ol>
<li><p>死锁预防</p>
<p>设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个，以防止死锁产生。</p>
</li>
<li><p>死锁避免</p>
<p>在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。</p>
</li>
<li><p>死锁检测</p>
<p>无需采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。</p>
</li>
</ol>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><p>破坏死锁产生的4个必要条件之一。</p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p>避免死锁同样属于事先预防策略，并不是在事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。</p>
<h4 id="系统安全状态"><a href="#系统安全状态" class="headerlink" title="系统安全状态"></a>系统安全状态</h4><p>是指系统能够按某种进程推进顺序为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。</p>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>把操作系统视为银行家，操作系统管理的资源相当于银行家的资源，进程向操作系统请求分配资源相当于用户向银行家贷款。</p>
<p>进程运行之前先<strong>声明</strong>对各种资源的最大需求量，当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过该进程声明的最大需求量。若超过则拒绝分配资源，若未超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</p>
<p><img src="https://s2.loli.net/2022/03/12/o5sKZnlQwW4DTrP.png" alt="image-20220312170442725"></p>
<p><strong>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态之后，便可能进入死锁状态。反之，只要系统处于安全状态，系统便可避免进入死锁状态。</strong></p>
<p><img src="https://s2.loli.net/2022/03/12/rLtAgbUQ8ZVzGMR.png" alt="image-20220312171202629"></p>
<p><img src="https://s2.loli.net/2022/03/12/9mHcgUSvZnWFy8A.png" alt="image-20220312171733152"></p>
<h5 id="银行家算法-1"><a href="#银行家算法-1" class="headerlink" title="银行家算法"></a>银行家算法</h5><p><img src="https://s2.loli.net/2022/03/12/qhIBON83eTgmM1S.png" alt="image-20220312172345316"></p>
<h5 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h5><p><img src="https://s2.loli.net/2022/03/12/2uKxQ7YRXyL6FUM.png" alt="image-20220312172830717"></p>
<p><img src="https://s2.loli.net/2022/03/12/mCGgTLxhU4Od1Hc.png" alt="image-20220312172837053"></p>
<p><img src="https://s2.loli.net/2022/03/12/584bcnAS7JQuWsN.png" alt="image-20220312172840088"></p>
<p><img src="https://s2.loli.net/2022/03/12/zxZuYL1A2oEls5g.png" alt="image-20220312172905505"></p>
<p>同理P4。</p>
<p>P2-P1-P3-P4是个安全状态</p>
<h4 id="死锁检测和死锁恢复"><a href="#死锁检测和死锁恢复" class="headerlink" title="死锁检测和死锁恢复"></a>死锁检测和死锁恢复</h4><p><strong>死锁检测</strong></p>
<p><img src="https://s2.loli.net/2022/03/12/ft8zNdnjc7r4Iha.png" alt="image-20220312175652848"></p>
<p>把资源分配图做一定的简化，变为一个等待图（去掉资源节点，只留下进程节点）</p>
<p><img src="https://s2.loli.net/2022/03/13/oP2E15sCa9vXW6g.png" alt="image-20220313100946622"></p>
<p><img src="https://s2.loli.net/2022/03/13/mHd5oV4szNRYqMC.png" alt="image-20220313102212433"></p>
<p><strong>死锁恢复（死锁解除）</strong></p>
<p><img src="https://s2.loli.net/2022/03/13/ZKS3gcD2TMLiFOP.png" alt="image-20220313102303054"></p>
<ol>
<li><p>资源剥夺</p>
<p>挂起某些死锁进程，并剥夺它的资源，</p>
</li>
<li><p>撤销进程</p>
<p>强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。</p>
</li>
<li><p>进程回退</p>
<p>让一个或多个进程回退到足以回避思死锁的地步，进程回退时自愿释放资源而非被剥夺。</p>
</li>
</ol>
<h2 id="进程间通信（IPC-InterProcess-Communication）"><a href="#进程间通信（IPC-InterProcess-Communication）" class="headerlink" title="进程间通信（IPC  InterProcess Communication）"></a>进程间通信（IPC  InterProcess Communication）</h2><p><strong>消息传递</strong></p>
<ol>
<li>直接通信方式</li>
<li>间接通信方式</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/13/taFSjIACkfrnZ4g.png" alt="image-20220313103326104"></p>
<p><img src="https://s2.loli.net/2022/03/13/yVTtY517cDhPQvk.png" alt="image-20220313103440391"></p>
<p><img src="https://s2.loli.net/2022/03/13/ekh4sF5dNyUiBCj.png" alt="image-20220313103557925"></p>
<p><img src="https://s2.loli.net/2022/03/13/jyonL6NcTafAD8i.png" alt="image-20220313103641277"></p>
<p><img src="https://s2.loli.net/2022/03/13/a7KlzbIJE6WNxMd.png" alt="image-20220313104347692"></p>
<h3 id="进程间通信常用的手段"><a href="#进程间通信常用的手段" class="headerlink" title="进程间通信常用的手段"></a>进程间通信常用的手段</h3><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p><img src="https://s2.loli.net/2022/03/13/EQB6sL1lTdbv5Fh.png" alt="image-20220313104740602"></p>
<p><img src="https://s2.loli.net/2022/03/13/ZpSUDvliuKoXrEm.png" alt="image-20220313105038246"></p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道是用来数据交换的。</p>
<p>管道通信中，存储空间进化成了缓冲区，缓冲区只允许一边写入、另一边读出，因此只要缓冲区有数据，进程就能从缓冲区中读出，而不必担心会因为其他进程在其中进行写操作而遭到阻塞，因为写进程会先把缓冲区写满，才让读进程读，当缓冲区中还有数据时，写进程不会向其中写数据。</p>
<p><strong>管道通信必然是双半工通信。</strong></p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p><img src="https://s2.loli.net/2022/03/13/vL9Z5kpEPAFCYad.png" alt="image-20220313110438370"></p>
<p>有buffer的size限制，当满或空，也会出现sleep机制。</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p><img src="https://s2.loli.net/2022/03/13/Bry3kXxP897alDK.png" alt="image-20220313110543798"></p>
<p><img src="https://s2.loli.net/2022/03/13/eLKniTvBarGD7Vu.png" alt="image-20220313110846641"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
