<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="我的一些记录">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="我的一些记录">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>我的一些记录</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我的一些记录</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/08/6-828Lab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/08/6-828Lab6/" class="post-title-link" itemprop="url">6-828Lab6</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-08 14:34:24" itemprop="dateCreated datePublished" datetime="2022-07-08T14:34:24+08:00">2022-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-22 20:18:20" itemprop="dateModified" datetime="2022-07-22T20:18:20+08:00">2022-07-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Network-Driver-default-final-project"><a href="#Network-Driver-default-final-project" class="headerlink" title="Network Driver (default final project)"></a>Network Driver (default final project)</h1><p><strong>Lab 6 Network Driver</strong></p>
<p>网卡基于E1000芯片</p>
<p>除了编写驱动之外，还需要创建一个 system call 来访问我们的驱动程序。我们将实现缺失的网络服务器代码，以在网络堆栈和驱动程序之间传输数据包。我们还可以通过完成web服务器将所有内容绑定在一起。使用新的web服务器，我们能够从文件系统中提供文件。</p>
<p>没有框架文件，没有固定的系统调用接口，许多设计决策都留给您。</p>
<h2 id="QEMU’s-virtual-network"><a href="#QEMU’s-virtual-network" class="headerlink" title="QEMU’s virtual network"></a><strong>QEMU’s virtual network</strong></h2><p>QEMU是一个模拟处理器软件，默认提供一个运行在IP 10.0.2.2 上的虚拟路由，并为JOS分配IP 10.0.2.15 ，为了解决内网连接问题，host无法运行在QEMU上的web server，我们配置QEMU在主机某个端口上运行服务。该端口只需连接到JOS中的某个端口，并在真实主机和虚拟网络之间来回传送数据。 </p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220710105135537.png" alt="image-20220710105135537" style="zoom:50%;" />

<p><strong>echo server</strong>是回显服务,用户输入<em>什么</em>,服务器将输入信息返回给客户端。</p>
<p><strong>webserver</strong> 是指驻留于因特网上某种类型计算机的程序。当Web浏览器（客户端）连到服务器上并请求文件时，服务器将处理该请求并将文件反馈到该浏览器上，附带的信息会告诉浏览器如何查看该文件（即文件类型）。服务器使用HTTP（超文本传输协议）与客户机浏览器进行信息交流，这就是人们常把它们称为HTTP服务器的原因。目前最主流的三个Web服务器是Apache Nginx IIS。</p>
<h2 id="Packet-Inspection"><a href="#Packet-Inspection" class="headerlink" title="Packet Inspection"></a>Packet Inspection</h2><p>Makefile 配置了QEMU的网络栈，将进出的网络包记录到 qemu.pcap中。我们可以使用图形化的 wireshark，或是使用命令行获得网络包的hex/ASCII信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -XXnr qemu.pcap</span><br></pre></td></tr></table></figure>



<h2 id="Debugging-the-E1000"><a href="#Debugging-the-E1000" class="headerlink" title="Debugging the E1000"></a>Debugging the E1000</h2><p>The E1000 can produce a lot of debug output, so you have to enable specific logging channels. Some channels you might find useful are:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>tx</td>
<td>日志发送操作</td>
</tr>
<tr>
<td>txerr</td>
<td>日志发送错误</td>
</tr>
<tr>
<td>rx</td>
<td>Log changes to RCTL</td>
</tr>
<tr>
<td>rxfilter</td>
<td>Log 日志入方向过滤</td>
</tr>
<tr>
<td>rxerr</td>
<td>Log 接受错误</td>
</tr>
<tr>
<td>unknown</td>
<td>Log 对未知寄存器进行读写操作</td>
</tr>
<tr>
<td>eeprom</td>
<td>Log reads from the EEPROM(带电可擦可编程只读存储器)</td>
</tr>
<tr>
<td>interrupt</td>
<td>Log 记录中断和中断寄存器的更改。</td>
</tr>
</tbody></table>
<p>To enable “tx” and “txerr” logging, for example, use make E1000_DEBUG=tx,txerr ….</p>
<h2 id="The-Network-Server"><a href="#The-Network-Server" class="headerlink" title="The Network Server"></a>The Network Server</h2><p>从零开始写一个网络栈是十分困难的，因此我们使用<code>lwIP</code>， 其是一个开源的轻量级TCP/IP协议套件，其中包含网络栈。</p>
<p><strong>网络服务器实际上是四个环境的组合:</strong></p>
<ul>
<li><p>核心网络服务器环境(包括套接字调用调度程序和lwIP)</p>
</li>
<li><p>输入环境</p>
</li>
<li><p>输出环境</p>
</li>
<li><p>计时器的环境</p>
</li>
</ul>
<p>我们将实现图中标记为绿色的部分。</p>
<p><a target="_blank" rel="noopener" href="https://img-blog.csdnimg.cn/20190717163505895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NtYWxsX1BvbmQ=,size_16,color_FFFFFF,t_70"><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NtYWxsX1BvbmQ=,size_16,color_FFFFFF,t_70.png" alt="MIT6.828 Lab6_Network Driver"></a></p>
<h2 id="The-Core-Network-Server-Environment"><a href="#The-Core-Network-Server-Environment" class="headerlink" title="The Core Network Server Environment"></a>The Core Network Server Environment</h2><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70-20220710112319607.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190718154556909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bhc2hhbmh1NjQwMg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>For each user environment IPC, the dispatcher in the network server calls the appropriate BSD socket interface function provided by lwIP on behalf of the user. </p>
<p>Regular user environments do not use the nsipc_* calls directly. Instead, they use the functions in lib/sockets.c, which provides a file descriptor-based sockets API. </p>
<p>文件服务器和网络服务器之间有一个关键的区别。像accept和recv这样的BSD套接字调用可以无限阻塞。由于这是不可接受的，网络服务器使用用户级线程来避免阻塞整个服务器环境。</p>
<p>除了核心网络环境之外，还有三个辅助环境。除了接收来自用户应用程序的消息外，核心网络环境的调度程序还接收来自输入环境和计时器环境的消息。</p>
<p>核心网络服务器环境是由所有套接字调用分发者和lwIP组成。套接字调度器和文件服务器工作类似。用户环境使用根(<code>lib/nsipc.c</code><br>)发送IPC消息给核心网络环境。如果你查看<code>lib/nsipc.c</code><br>，你可以看到核心网络服务器和文件服务器一样:<code>i386_init</code><br>创建带有<code>NS_TYPE_NS</code><br>的环境，所以我们扫描<code>envs</code><br>，找到特殊的环境类型。对于每个用户环境IPC，网络服务器的调度器调用合适BSD套接字接口函数</p>
<p>常用的用户环境不使用<code>nsipc_*</code><br>直接调用。相反，他们使用<code>lib/sockets.c</code><br>中的函数，它提供了一个基于文件描述符的套接字API。因此，用户环境通过文件描述符指向套接字，就像指向磁盘上的文件一样。大量的操作(<code>connect</code><br>, <code>accept</code><br>等)是指定套接字的，但是<code>read</code><br>, <code>write</code><br>和<code>close</code><br>是通过普通的文件描述符<code>lib/fd.c</code><br>完成的。和文件服务器为所有打开的文件保留唯一ID一样，lwIP也生成唯一ID为所有打开的套接字。在文件服务器和网络服务器中，我们使用保存在<code>struct Fd</code><br>中的信息来映射每个环境文件描述符到这些唯一ID空间</p>
<p>尽管文件服务器和网络服务器的IPC调度器行为一样，但是还有一个关键的区别。BSD套接字调用像<code>accept</code><br>和<code>recv</code><br>能无限阻塞。如果调度器允许lwIP执行阻塞调用中的一个，调度器也会阻塞，整个系统，同一个时间只有一个网络调用。因为这是不能接受的，所以网络服务器使用用户级别的线程来避免阻塞整个服务环境。对于每个到达的IPC消息，调度器创建一个线程，在线程中处理请求。如果线程阻塞，只有那个线程进入休眠，其他线程会继续执行</p>
<p>除了核心网络环境之外，也有三个辅助环境，除了从用户程序接收消息，核心网络环境调度器也从输入和时间环境接收消息</p>
<p><strong>输出环境</strong></p>
<p>当正在服务用户环境的套接字调用时，lwIP会为网卡生成包数据.lwIP发送每个包给输出辅助环境，使用<code>NSREQ_OUTPUT</code><br>的IPC消息，包数据会在IPC的页参数带上。输出环境负责接收这些消息，通过你创建的系统调用接口分发给设备驱动</p>
<p><strong>输入环境</strong></p>
<p>通过网卡接收到的包，需要注入到lwIP中，对于每一个设备驱动接收到的包，输入环境从内核空间拉出包(使用你需要实现的内核系统调用)，然后发送包数据到核心服务环境，使用<code>NSREQ_INPUT</code><br>的IPC消息</p>
<p>包输入功能与核心网络环境分离，因为JOS很难同时接收IPC消息，同时轮询或等待设备驱动数据包也很困难。在JOS中，我们没有<code>select</code><br>系统调用，这个系统调用可以监听多个输入源来区分哪个输入准备进行了</p>
<p>如果你阅读过<code>net/input.c</code><br>和<code>net/output.c</code><br>，你会发现这两个都需要你实现。这是主要的，因为实现决定了系统调用接口。在你实现了驱动和系统调用接口之后，你需要为两个辅助环境编写代码</p>
<p><strong>定时器环境</strong></p>
<p>定时器环境周期性发送<code>NSREQ_TIMER</code><br>类型消息给核心网络服务器，通知一个定时器已经过期了。来自线程的定时器消息被lwIP用来实现各种各样的网络超时</p>
<h1 id="Part-A-Initialization-and-transmitting-packets-实现和转发包-报文"><a href="#Part-A-Initialization-and-transmitting-packets-实现和转发包-报文" class="headerlink" title="Part A: Initialization and transmitting packets 实现和转发包(报文)"></a>Part A: Initialization and transmitting packets 实现和转发包(报文)</h1><p>你的内核代码没有时间概念，所以你需要添加。现在有时钟中断，这是由硬件每10ms生成的。每个时钟中断，我们可以递增变量来表明时间已经提前了10ms。这个实现在<code>kern/time.c</code><br>，但是没有植入到你的内核中</p>
<p>我们需要为我们的内核添加时间概念。使用时钟中断，并用一个变量进行计数。</p>
<p>Add a call to time_tick for every clock interrupt in <code>kern/trap.c</code>(in <code>kern/time.c</code>). Implement <code>sys_time_msec</code> and add it to syscall in <code>kern/syscall.c</code> so that user space has access to the time.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">case</span> (IRQ_OFFSET + IRQ_TIMER):</span><br><span class="line">        <span class="comment">// 回应8259A 接收中断。</span></span><br><span class="line">        lapic_eoi();</span><br><span class="line">        time_tick();</span><br><span class="line">        sched_yield();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_time_msec</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 6: Your code here.</span></span><br><span class="line">    <span class="keyword">return</span> time_msec();</span><br><span class="line">    <span class="comment">// panic(&quot;sys_time_msec not implemented&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">case</span> SYS_time_msec:</span><br><span class="line">        <span class="keyword">return</span> sys_time_msec();</span><br></pre></td></tr></table></figure>



<h2 id="The-Network-Interface-Card"><a href="#The-Network-Interface-Card" class="headerlink" title="The Network Interface Card"></a>The Network Interface Card</h2><p>Browse Intel’s <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/8254x_GBe_SDM.pdf">Software Developer’s Manual</a> for the E1000. 本手册涵盖了几个密切相关的以太网控制器。QEMU模拟82540EM。</p>
<p><strong>接收和发送描述:</strong></p>
<p>数据包接收</p>
<p>​    识别到网络上存在一个数据包，</p>
<p>​    执行地址过滤,</p>
<p>​    将数据包存储在接收数据FIFO中，</p>
<p>​    将数据传输到主机内存中的接收缓冲区，</p>
<p>​            buffer size <code>RCTL.BSIZE &amp; RCTL.BSEX</code></p>
<p>​    updating the state of a receive descriptor.</p>
<p>​            Status</p>
<p>​            Errors</p>
<p>​            Specia</p>
<h2 id="PCI-Interface"><a href="#PCI-Interface" class="headerlink" title="PCI Interface"></a>PCI Interface</h2><p>PCI是外围设备互连(Peripheral Component Interconnect)的简称，是在目前计算机系统中得到广泛应用的通用总线接口标准：</p>
<p>在一个PCI系统中，最多可以有256根PCI总线，一般主机上只会用到其中很少的几条。<br>在一根PCI总线上可以连接多个物理设备，可以是一个网卡、显卡或者声卡等，最多不超过32个。<br>一个PCI物理设备可以有多个功能，比如同时提供视频解析和声音解析，最多可提供8个功能。<br>每个功能对应1个256字节的PCI配置空间</p>
<p>为了在引导期间执行PCI初始化，PCI代码遍历PCI总线以寻找设备。 当它找到设备时，它会读取其供应商ID和设备ID，并使用这两个值作为搜索pci_attach_vendor数组的键。 该数组由struct pci_driver条目组成，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> key1, key2;</span><br><span class="line">    <span class="keyword">int</span> (*attachfn) (struct pci_func *pcif);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果发现的设备的供应商ID和设备ID与数组中的条目匹配，则PCI代码会调用该条目的<code>attachfn</code>来执行设备初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_func</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_bus</span> *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> dev;</span><br><span class="line">    <span class="keyword">uint32_t</span> func;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> dev_id;</span><br><span class="line">    <span class="keyword">uint32_t</span> dev_class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> reg_base[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_size[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> irq_line;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们重点关注<code>struct pci_func</code>的最后三个成员，因为它们记录了设备的negotiated memory，I/O 和中断资源。 <code>reg_base</code>和<code>reg_size</code>数组包含最多六个基址寄存器或BAR的信息。<code>reg_base</code>存储内存映射 I/O 区域的基地址（或 I/O 端口资源的基本 I/O 端口），<code>reg_size</code>包含<code>reg_base</code>中相应基值的大小（以字节为单位）或 I/O 端口数， 和<code>irq_line</code>包含分配给设备的 IRQ line 以进行中断。</p>
<p><code>pci_func_enable</code>将会使能设备，协调资源，并将其填入<code>struct pci_func</code>。</p>
<h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><blockquote>
<p>Implement an attach function to initialize the E1000.</p>
</blockquote>
<p>查看手册以及根据内核启动时的打印信息，我们可以知道 E1000 的 Vender ID = 0x8086， Device ID = 0x100E。</p>
<p>Add an entry to the pci_attach_vendor array in <code>kern/pci.c</code> to trigger your function if a matching PCI device is found，将E1000加入数组中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">pci_attach_vendor</span>[] =</span> &#123;</span><br><span class="line">    &#123; PCI_E1000_VENDOR_ID, PCI_E1000_DEVICE_ID, &amp;pci_e1000_attach&#125;,</span><br><span class="line">    &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>编写 <code>e1000.c</code> and <code>e1000.h</code>文件。.c文件写 attach函数， 在.h 文件中定义其 PCI ID等信息。</p>
<p>just enable the E1000 device via pci_func_enable.</p>
<h2 id="Memory-mapped-I-O"><a href="#Memory-mapped-I-O" class="headerlink" title="Memory-mapped I/O"></a>Memory-mapped I/O</h2><p>软件通过 Memory-mapped I/O 与 E1000 进行通信。之前我们已经两次接触过 MMIO这个概念了，分别在 CGA控制台和 lapic。 我们通过内存地址对设备进行读写。这些以内存地址为基础的读写目标并不是 DRAM，而是设备。</p>
<p><code>pci_func_enable</code> 为 E1000分配了一个 MMIO 区域并且在 BAR0 中存储了它的 base and size。这是分配给设备的一系列物理内存地址，这意味着我们必须通过虚拟地址访问它。 由于MMIO区域被分配了非常高的物理地址（通常高于3GB），因为JOS的256MB限制，我们无法使用KADDR（内核地址）访问它。所以我们将创建一个新的映射。我们还是使用<code>mmio_map_region</code>分配<code>MMIOBASE</code>以上的区域，其保证了我们不会修改到之前创建的 LAPIC 映射。<strong>由于PCI设备初始化发生在JOS创建用户环境之前</strong>，因此您可以在kern_pgdir中创建映射，并且它总是可用的。</p>
<h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><p>In your attach function, create a virtual memory mapping for the E1000’s BAR 0 by calling mmio_map_region (which you wrote in lab 4 to support memory-mapping the LAPIC).</p>
<p>将E1000的物理地址映射到虚拟地址，同时记录映射的虚拟地址，方便之后对 E1000 设备的访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射，并保存其虚拟地址，方便访问。</span></span><br><span class="line">e1000 = mmio_map_region(pcif-&gt;reg_base[<span class="number">0</span>], pcif-&gt;reg_size[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;device status:[%08x]\n&quot;</span>, *(<span class="keyword">uint32_t</span> *)((<span class="keyword">uint8_t</span> *)e1000 + E1000_DEVICE_STATUS));</span><br><span class="line"><span class="comment">// 或者写为 e1000[E1000_DEVICE_STATUS &gt;&gt; 2];</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E1000_LOCATE(offset)  (offset &gt;&gt; 2)</span></span><br><span class="line">cprintf(<span class="string">&quot;device status:[%08x]\n&quot;</span>, e1000[E1000_LOCATE(E1000_DEVICE_STATUS)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">PCI function <span class="number">00</span>:<span class="number">03.0</span> (<span class="number">8086</span>:<span class="number">100</span>e) enabled</span><br><span class="line">device status:[<span class="number">80080783</span>]</span><br></pre></td></tr></table></figure>





<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>通过读写 E1000 寄存器来传输接收数据包是十分低效的做法，并且还需要E1000 缓存数据包。因此考虑到各个方面的因素，我们采用 DMA 的方式直接访问内存。驱动程序负责为发送和接收队列分配内存，设置DMA描述符，并使E1000定位到这些队列，但之后的所有内容都会变成异步的。</p>
<p>从抽象层来看，接收和发送队列非常相似。 两者都由一系列描述符组成。 虽然这些描述符的确切结构各不相同，但每个描述符包含一些标志和数据包数据缓冲区的物理地址（要发送的网卡的数据包数据，或者操作系统为网卡写入接收数据包而分配的缓冲区）。</p>
<h2 id="Transmitting-Packets"><a href="#Transmitting-Packets" class="headerlink" title="Transmitting Packets"></a>Transmitting Packets</h2><p>初始化要发送的网卡。传输初始化的第一步是设置传输队列。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/20190717163648563.png" alt="MIT6.828 Lab6_Network Driver"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Transmit Descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E1000TxDesc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> buffer_addr;       <span class="comment">/* Address of the descriptor&#x27;s data buffer */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> length;    <span class="comment">/* Data buffer length */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> cso;        <span class="comment">/* Checksum offset */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> cmd;        <span class="comment">/* Descriptor control */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> status;     <span class="comment">/* Descriptor status */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> css;        <span class="comment">/* Checksum start */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> special;</span><br><span class="line"></span><br><span class="line">&#125;__attribute__((packed));</span><br></pre></td></tr></table></figure>

<p>在驱动程序初始化期间为每个描述符保留数据包缓冲区的空间，并简单地将数据包数据复制到这些预分配的缓冲区中。</p>
<h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p>执行第14.5节(但不是它的子节)中描述的初始化步骤。使用第13节作为初始化过程中引用的寄存器的参考，使用第3.3.3节和第3.4节作为传输描述符和传输描述符数组的参考。</p>
<p>在对各寄存器进行初始化时，要不断得在第13章找到其偏移地址和详细定义。最后按照要求写入地址。</p>
<p>我们必须将要传输的数据包添加到传输队列的尾部，这意味着需要将数据包数据复制到下一个数据包缓冲区，然后更新TDT（传输描述符尾部）寄存器以通知网卡在传输队列中有另一个数据包。[Note] TDT 是传输描述符数组的索引而不是偏移地址。</p>
<p>如果在发送描述符的命令字段中设置RS（Report Status）位，则当网卡在该描述符中发送了数据包时，网卡将在描述符的状态字段中设置DD（Descriptor Done）位。 如果设置了描述符的DD位，我们就能回收该描述符并使用它来传输另一个数据包。</p>
<p>如果用户调用传输系统调用，但下一个描述符的<code>DD</code>位未置位，表明传输队列已满，该怎么办？ 你必须决定在这种情况下该做什么。你可以简单地丢弃数据包。网络协议对此具有弹性，但如果丢弃大量数据包，协议可能无法恢复。我们可以告诉用户环境它必须重试，就像我们对<code>sys_ipc_try_send</code>所做的那样。This has the advantage of pushing back on the environment generating the data.。</p>
<h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><p>编写一个函数，通过检查下一个描述符是否空闲来传输一个包，将包数据复制到下一个描述符，并更新TDT。确保您处理的传输队列已满。</p>
<h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><p>添加一个系统调用，允许您从用户空间传输数据包。具体的界面取决于您。不要忘记检查从用户空间传递给内核的指针</p>
<h2 id="Transmitting-Packets-Network-Server传输报文-网络服务器"><a href="#Transmitting-Packets-Network-Server传输报文-网络服务器" class="headerlink" title="Transmitting Packets: Network Server传输报文:网络服务器"></a>Transmitting Packets: Network Server传输报文:网络服务器</h2><p>既然我们已经有了 packet send 的系统调用，也是时候发送数据包了。output helper environment 运行在一个循环中：从 core network server 接收 <code>NSREQ_OUTPUT</code> IPC 信息，使用 system call 将伴随 IPC 发送过来的 Packet 发送到设备驱动中。 <code>NSREQ_OUTPUT</code>由在<code>net/lwip/jos/jif/jif.c</code>文件中的<code>low_level_output</code> 函数发送 , which glues the lwIP stack to JOS’s network system. 每个IPC 都包含一个由 <code>union Nsipc</code>构成的页，packet 存在于 <code>struct kif_pkt</code>字段。struct jif_pkt looks like：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jif_pkt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> jp_len;</span><br><span class="line">    <span class="keyword">char</span> jp_data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在结构的末尾使用像<code>jp_data</code>这样的<strong>零长度数组</strong>是用于表示没有预定长度的缓冲区的常见C技巧（有些人会说是恶心）。 由于C不进行数组边界检查，只要确保结构后面有足够的未使用内存，就可以使用<code>jp_data</code>，就好像它是一个任意大小的数组一样。</p>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><p>Implement net/output.c.</p>
<p>在<code>/net/serv.c</code>中创建了一个相当于守护进程<code>output</code>，在output 中我们需要接收 ipc， 解析信息然后调用 system call 发送数据包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">output</span><span class="params">(<span class="keyword">envid_t</span> ns_envid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    binaryname = <span class="string">&quot;ns_output&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 6: Your code here:</span></span><br><span class="line">    <span class="comment">//     - read a packet from the network server</span></span><br><span class="line">    <span class="comment">//    - send the packet to the device driver</span></span><br><span class="line">    <span class="keyword">uint32_t</span> whom;</span><br><span class="line">    <span class="keyword">int</span> perm;</span><br><span class="line">    <span class="keyword">int32_t</span> req;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        req = ipc_recv((<span class="keyword">envid_t</span> *)&amp;whom, &amp;nsipcbuf, &amp;perm);</span><br><span class="line">        <span class="keyword">if</span> (req != NSREQ_OUTPUT) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (sys_pkt_try_send(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sys_yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/08/6-828Lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/08/6-828Lab5/" class="post-title-link" itemprop="url">6-828Lab5</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-08 14:34:18" itemprop="dateCreated datePublished" datetime="2022-07-08T14:34:18+08:00">2022-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-22 20:18:29" itemprop="dateModified" datetime="2022-07-22T20:18:29+08:00">2022-07-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Lab-5-File-system-Spawn-and-Shell"><a href="#Lab-5-File-system-Spawn-and-Shell" class="headerlink" title="Lab 5: File system, Spawn and Shell"></a>Lab 5: File system, Spawn and Shell</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In this lab, you will implement <code>spawn</code>, a library call that loads and runs on-disk executables. 然后，您将充实内核和库操作系统，使其足以在控制台上运行shell。这些特性需要一个文件系统，本实验室介绍了一个简单的读写文件系统。</p>
<table>
<thead>
<tr>
<th>file</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>fs/fs.c</code></td>
<td>操纵文件系统磁盘上结构的代码。</td>
</tr>
<tr>
<td><code>fs/bc.c</code></td>
<td>一个建立在用户级页面错误处理设施之上的简单块缓存。</td>
</tr>
<tr>
<td><code>fs/ide.c</code></td>
<td>最小的基于pio(非中断驱动)的IDE驱动程序代码。</td>
</tr>
<tr>
<td><code>fs/serv.c</code></td>
<td>使用文件系统IPCS与客户机环境交互的文件系统服务器。</td>
</tr>
<tr>
<td><code>lib/fd.c</code></td>
<td>实现通用类unix文件描述符接口的代码。</td>
</tr>
<tr>
<td><code>lib/file.c</code></td>
<td>用于磁盘上文件类型的驱动程序，实现为文件系统IPC客户机。</td>
</tr>
<tr>
<td><code>lib/console.c</code></td>
<td>控制台输入/输出文件类型的驱动程序。</td>
</tr>
<tr>
<td><code>lib/spawn.c</code></td>
<td><code>spawn</code>库调用的代码框架。</td>
</tr>
</tbody></table>
<h2 id="File-system-preliminaries（文件系统初步）"><a href="#File-system-preliminaries（文件系统初步）" class="headerlink" title="File system preliminaries（文件系统初步）"></a>File system preliminaries（文件系统初步）</h2><p>我们要完成一个相对简单的文件系统，其可以实现创建、读、写以及删除在分层目录结构中组织的文件。目前我们的OS只支持单用户，因此我们的文件系统也不支持UNIX文件拥有或权限的概念。同时也不支持硬链接、符号链接、时间戳或是特别的设备文件。</p>
<h3 id="On-Disk-File-System-Structure"><a href="#On-Disk-File-System-Structure" class="headerlink" title="On-Disk File System Structure"></a>On-Disk File System Structure</h3><p>大多数UNIX文件系统将可用磁盘空间划分为两种主要类型的区域:inode区域和数据区域。UNIX文件系统为文件系统中的每个文件分配一个inode;一个文件的inode保存着关于该文件的关键元数据，比如它的属性和指向其数据块的指针。数据区域被划分为更大的数据块(通常为8KB或更多)，文件系统在其中存储文件数据和目录元数据。目录项包含文件名和指向索引节点的指针;如果文件系统中的多个目录条目引用了该文件的inode，则该文件被称为硬链接文件。由于我们的文件系统不支持硬链接，我们不需要这种间接级别，因此可以进行方便的简化:我们的文件系统根本不使用inode，而只是将一个文件(或子目录)的所有元数据存储在描述该文件的(唯一的)目录条目中。</p>
<p>文件和目录在逻辑上都由一系列数据块组成，这些数据块可以分散在磁盘中，就像环境的虚拟地址空间的页面可以分散在物理内存中一样。文件系统环境隐藏了块布局的细节，提供了在文件中任意偏移位置读取和写入字节序列的接口。文件系统环境在内部处理对目录的所有修改，作为执行文件创建和删除等操作的一部分。我们的文件系统允许用户环境直接读取目录元数据(例如，使用read)，这意味着用户环境可以自己执行目录扫描操作(例如，实现ls程序)，而不必依赖于对文件系统的额外特殊调用。这种目录扫描方法的缺点是，它使应用程序依赖于目录元数据的格式，在不更改或至少重新编译应用程序的情况下，很难更改文件系统的内部布局，这也是大多数现代UNIX变体不鼓励使用这种方法的原因。</p>
<h4 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h4><p>扇区是对磁盘的概念，块是对OS的概念。 块的 size 必须是扇区size 的整数倍。</p>
<h4 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h4><p>文件系统通常在磁盘上的“易于查找”位置保留某些磁盘块（例如从最开始或最后）以保存描述文件系统属性的元数据，例如块大小 ，磁盘大小，查找根目录所需的任何元数据，上次挂载文件系统的时间，文件系统上次检查错误的时间等等。 这些特殊块称为超级块。</p>
<p>我们的文件系统将只有一个超级块，它始终位于磁盘上的第1块。它的布局由struct Super在<code>inc/fs.h</code>中定义。<strong>块0通常保留来保存引导加载程序和分区表</strong>，因此文件系统通常不使用第一个磁盘块。许多“真正的”文件系统维护多个超级块，复制到磁盘上几个间隔很宽的区域，因此，如果其中一个超级块损坏或磁盘在该区域出现了媒体错误，仍然可以找到其他超级块，并使用它们访问文件系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_magic;        <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_nblocks;        <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>        <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>Superblock, Inode, Dentry 和 File 都属于元数据(Metadata)，</strong>根据维基百科中的解释，<strong>所谓元数据，就是描述数据的数据（data about data），主要是描述数据属性（property）的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。Linux/Unix 文件系统的元数据以多级结构保存</strong>。</p>
<p>superblock：记录此filesystem 的整体信息，包括inode[表情]ock的总量、使用量、剩余量， 以及档案系统的格式与相关信息等；<br>inode：记录档案的属性，一个档案占用一个inode，同时记录此档案的资料所在的block 号码；<br>block：实际记录档案的内容，若档案太大时，会占用多个block 。</p>
<p>Superblock 是文件系统最基本的元数据，它定义了文件系统的类似、大小、状态，和其他元数据结构的信息（元数据的元数据）。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/disk.png" alt="Disk layout"></p>
<h4 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h4><p>The layout of the meta-data describing a file in our file system is described by struct File in <code>inc/fs.h</code>. Unlike in most “real” file systems, for simplicity we will use this one File structure to represent file meta-data</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> f_name[MAXNAMELEN];    <span class="comment">// filename</span></span><br><span class="line">    <span class="keyword">off_t</span> f_size;            <span class="comment">// file size in bytes</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_type;        <span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Block pointers.</span></span><br><span class="line">    <span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_direct[NDIRECT];    <span class="comment">// direct blocks</span></span><br><span class="line">    <span class="keyword">uint32_t</span> f_indirect;        <span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pad out to 256 bytes; must do arithmetic in case we&#x27;re compiling</span></span><br><span class="line">    <span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line">    <span class="keyword">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));    <span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/file.png" alt="File structure"></p>
<h4 id="Directories-versus-Regular-Files-目录与普通文件"><a href="#Directories-versus-Regular-Files-目录与普通文件" class="headerlink" title="Directories versus Regular Files(目录与普通文件)"></a>Directories versus Regular Files(目录与普通文件)</h4><p>我们的文件系统中的超级块包含一个 <code>File</code>结构，其保存了文件系统根目录的元数据。这个目录文件的内容是一系列文件结构体，其描述了文件系统根目录下的文件和目录。任何根目录下的子目录可能包含更多表示子子目录的文件结构体，以此类推。</p>
<h2 id="The-File-System"><a href="#The-File-System" class="headerlink" title="The File System"></a>The File System</h2><p>我们实现的文件系统的关键部分是:</p>
<ul>
<li><p>读数据到缓存中并能写回到磁盘；</p>
</li>
<li><p>分配磁盘块; </p>
</li>
<li><p>将文件偏移映射到磁盘块; </p>
</li>
<li><p>并在IPC接口中实现读，写和打开。</p>
</li>
</ul>
<h3 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h3><p>操作系统中的文件系统环境需要能够访问磁盘，但是我们还没有在内核中实现任何磁盘访问功能。我们没有采用传统的“单片”操作系统策略，即在内核中添加IDE磁盘驱动程序以及允许文件系统访问它的必要系统调用，而是将IDE磁盘驱动程序作为用户级文件系统环境的一部分来实现。我们仍然需要稍微修改内核，以便让文件系统环境拥有实现磁盘访问所需的权限。</p>
<p>只要我们依赖于轮询、基于“编程I/O”(PIO)的磁盘访问，并且不使用磁盘中断，就很容易通过这种方式在用户空间中实现磁盘访问。也可以在用户模式下实现中断驱动的设备驱动程序(例如，L3和L4内核就可以做到这一点)，但难度更大，因为内核必须字段设备中断并将它们分派到正确的用户模式环境中。</p>
<p>x86处理器使用EFLAGS寄存器中的IOPL位来确定是否允许保护模式代码执行特殊的设备I/O指令，如in和OUT指令。因为我们需要访问的所有IDE磁盘寄存器都位于x86的I/O空间中，而不是内存映射的，所以给文件系统环境“I/O特权”是我们唯一需要做的事情，以便允许文件系统访问这些寄存器。实际上，EFLAGS寄存器中的IOPL位为内核提供了一种简单的“全或无”方法来控制用户模式代码是否可以访问I/O空间。在我们的示例中，我们希望文件系统环境能够访问I/O空间，但是我们根本不希望任何其他环境能够访问I/O空间。</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1:"></a>Exercise 1:</h4><p> i386_init通过将类型ENV_TYPE_FS传递给环境创建函数env_create来标识文件系统环境。在env.c中修改env_create，使它赋予文件系统环境I/O权限，但不赋予任何其他环境该权限。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">env_create</span><span class="params">(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span>   <span class="comment">// 新建一个进程</span></span><br><span class="line">    <span class="keyword">int</span> r = env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;env_create: env alloc error: %e&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配成功</span></span><br><span class="line">    e-&gt;env_type = type;</span><br><span class="line">    <span class="comment">// 添加文件权限</span></span><br><span class="line">    <span class="keyword">if</span>(type == ENV_TYPE_FS)&#123;</span><br><span class="line">        e-&gt;env_tf.tf_eflages |= FL_IOPL_MASK</span><br><span class="line">    &#125;</span><br><span class="line">    load_icode(e, binary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Question</strong></p>
<ol>
<li><p>Do you have to do anything else to ensure that this I/O privilege setting is saved and restored properly when you subsequently switch from one environment to another? Why?</p>
<p>不需要，因为在环境切换时，会保存eflags的值，后续也会使用env_pop_tf来恢复eflags的值。</p>
</li>
</ol>
<h3 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h3><p>在我们的文件系统中，我们将在处理器的虚拟内存系统的帮助下实现一个简单的“缓冲区缓存”(实际上只是块缓存)。块缓存的代码在<code>fs/bc.c</code>中。</p>
<p>我们的文件系统只能处理3GB或更小的磁盘。我们在文件系统环境的地址空间中保留了一个很大的、固定的3GB区域，从0x10000000 (DISKMAP)到0xD0000000 (DISKMAP+DISKMAX)，作为磁盘的“内存映射”版本。例如，磁盘块0映射到虚拟地址0x10000000，磁盘块1映射到虚拟地址0x10001000，依此类推。fs/bc.c中的diskaddr函数实现了从磁盘块号到虚拟地址的转换(以及一些完整性检查)。</p>
<p>将整个磁盘读入内存需要很长时间，因此我们将实现一种<strong>请求页面调度</strong>，当进程在运行时需要访问某部分程序和数据时，若发现请求页面不在内存，便提出请求，由OS将其所需页面调入内存。这样，我们就可以假装整个磁盘都在内存中。</p>
<h4 id="Exercise-2："><a href="#Exercise-2：" class="headerlink" title="Exercise 2："></a><strong>Exercise 2：</strong></h4><p>implement the <code>bc_pgfault</code> and <code>flush_block</code> functions in <code>fs/bc.c</code>. </p>
<p><code>bc_pgfault</code> is a page fault handler, just like the one your wrote in the previous lab for copy-on-write fork, 只不过它的工作是从磁盘加载页面以响应页面错误. </p>
<p>When writing this, keep in mind that</p>
<p>​    (1) <code>addr</code> may not be aligned to a block boundary and </p>
<p>​    (2) <code>ide_read</code> operates in sectors, not blocks.</p>
<p>如果需要，flush_block函数应该将一个块写入磁盘。如果块甚至不在块缓存中(也就是说，页面没有映射)，或者它不是脏的，则Flush_block不应该做任何事情。我们将使用VM硬件来跟踪磁盘块自上次从磁盘读取或写入磁盘以来是否被修改过。要查看一个块是否需要写入，我们只需查看uvpt条目中是否设置了PTE_D“脏”位。PTE_D位由处理器设置，以响应对该页的写操作;参见386参考手册第五章5.2.4.3。)将块写入磁盘后，flush_block应该使用sys_page_map清除PTE_D位。</p>
<p>采用了wb</p>
<p><strong>块号与扇区号有一定的区别，在完成这两个函数时，要注意区分这两个概念。 JOS 块大小位4kB，扇区大小为512B，每次读写一个块，就需要读写4个扇区。因此，JOS使用了一个宏定义<code>#define BLKSECTS (BLKSIZE / SECTSIZE)</code>来描述两者的关系。</strong></p>
<p><strong>bc_pgfault()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">bc_pgfault</span><span class="params">(struct UTrapframe *utf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">   <span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">   <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check that the fault was within the block cache region</span></span><br><span class="line">   <span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">      panic(<span class="string">&quot;page fault in FS: eip %08x, va %08x, err %04x&quot;</span>,</span><br><span class="line">            utf-&gt;utf_eip, addr, utf-&gt;utf_err);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Sanity check the block number.</span></span><br><span class="line">   <span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">      panic(<span class="string">&quot;reading non-existent block %08x\n&quot;</span>, blockno);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allocate a page in the disk map region, read the contents</span></span><br><span class="line">   <span class="comment">// of the block from the disk into that page.</span></span><br><span class="line">   <span class="comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span></span><br><span class="line">   <span class="comment">// the disk.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// LAB 5: you code here:</span></span><br><span class="line">    addr = (<span class="keyword">void</span>*) ROUNDUP(addr, PGSIZE);</span><br><span class="line">    <span class="comment">// Allocate a page of memory and map it at &#x27;addr&#x27; with permission &#x27;PTE_P|PTE_W|PTE_U&#x27; in the address space of &#x27;envid&#x27;.</span></span><br><span class="line">    <span class="keyword">if</span>((r = sys_page_alloc(<span class="number">0</span>,addr,PTE_P|PTE_W|PTE_U))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;in bc_pgfault, sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (r = ide_read(blockno*BLKSECTS, addr, BLKSECTS)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;in bc_pgfault, ide_read: %e&quot;</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Clear the dirty bit for the disk block page since we just read the</span></span><br><span class="line">   <span class="comment">// block from disk</span></span><br><span class="line">   <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check that the block we read was allocated. (exercise for</span></span><br><span class="line">   <span class="comment">// the reader: why do we do this *after* reading the block</span></span><br><span class="line">   <span class="comment">// in?)</span></span><br><span class="line">   <span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">      panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>flush_block()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果需要，将包含VA的块的内容清除到磁盘，然后使用sys_page_map清除PTE_D位。</span></span><br><span class="line"><span class="comment">// 如果该块不在块缓存中或不是脏的，则不做任何操作。</span></span><br><span class="line"><span class="comment">// Hint: Use va_is_mapped, va_is_dirty, and ide_write.</span></span><br><span class="line"><span class="comment">// Hint: Use the PTE_SYSCALL constant when calling sys_page_map.</span></span><br><span class="line"><span class="comment">// Hint: Don&#x27;t forget to round addr down.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">flush_block</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))    <span class="comment">// 越界</span></span><br><span class="line">      panic(<span class="string">&quot;flush_block of bad va %08x&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">   <span class="comment">//panic(&quot;flush_block not implemented&quot;);</span></span><br><span class="line">    addr = (<span class="keyword">void</span> *)ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> (va_is_mapped(addr) &amp;&amp; va_is_dirty(addr)) &#123;  <span class="comment">// 映射过并且为脏</span></span><br><span class="line">        ide_write(blockno*BLKSECTS, addr , BLKSECTS);  <span class="comment">// 写回到磁盘</span></span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)   <span class="comment">// 清空PTE_D (脏)位</span></span><br><span class="line">            panic(<span class="string">&quot;in flush_block, sys_page_map: %e&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fs/fs.c中的fs_init()将会初始化super和bitmap全局指针变量。</p>
<p>至此对于文件系统进程只要访问虚拟内存[DISKMAP, DISKMAP+DISKMAX]范围中的地址addr，就会访问到磁盘((uint32_t)addr - DISKMAP) / BLKSIZE block中的数据。</p>
<p>如果block数据还没复制到内存物理页，bc_pgfault()缺页处理函数会将数据从磁盘拷贝到某个物理页，并且将addr映射到该物理页。这样FS进程只需要访问虚拟地址空间[DISKMAP, DISKMAP+DISKMAX]就能访问磁盘了。</p>
<p><strong>JOS FS进程地址空间和磁盘映射：</strong></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220708171856337.png" alt="image-20220708171856337"></p>
<h3 id="The-Block-Bitmap"><a href="#The-Block-Bitmap" class="headerlink" title="The Block Bitmap"></a>The Block Bitmap</h3><p>在fs_init设置位图(btimap)指针之后，我们可以将位图视为一个位的压缩数组，磁盘上的每个块对应一个位。例如，<code>block_is_free</code>，它只是检查位图中给定的块是否被标记为空闲。</p>
<h4 id="Exercise-3："><a href="#Exercise-3：" class="headerlink" title="Exercise 3："></a>Exercise 3：</h4><p>使用free_block作为模型来实现fs/fs.c中的alloc_block，它应该在位图中找到一个空闲的磁盘块，标记它已被使用，并返回该块的编号。当您分配一个块时，您应该立即使用flush_block将更改后的位图块刷新到磁盘，以帮助文件系统保持一致性。</p>
<p><strong>我们以一个实例来分析 bitmap的工作原理， 若标记第35个块（块号为34）为使用状态， 则将bitmap[1] 的第 2 （34%32）位标记为 0。 讲道理应该位图位为0是free的呀，JOS这里反过来了。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search the bitmap for a free block and allocate it.  When you</span></span><br><span class="line"><span class="comment">// allocate a block, immediately flush the changed bitmap block</span></span><br><span class="line"><span class="comment">// to disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return block number allocated on success,</span></span><br><span class="line"><span class="comment">// -E_NO_DISK if we are out of blocks.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: use free_block as an example for manipulating the bitmap.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">alloc_block</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// The bitmap consists of one or more blocks.  A single bitmap block</span></span><br><span class="line">   <span class="comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span></span><br><span class="line">   <span class="comment">// super-&gt;s_nblocks blocks in the disk altogether.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">   <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;super-&gt;s_nblocks;++i)&#123;</span><br><span class="line">        <span class="comment">// block_is_free(): Check to see if the block bitmap indicates that block &#x27;blockno&#x27; is free.</span></span><br><span class="line">        <span class="comment">// Return 1 if the block is free, 0 if not.</span></span><br><span class="line">        <span class="keyword">if</span>(block_is_free(i))&#123;  <span class="comment">// 没有使用，则标记为已使用</span></span><br><span class="line">            bitmap[i/<span class="number">32</span>] &amp;=  ~(<span class="number">1</span>&lt;&lt;(i%<span class="number">32</span>));</span><br><span class="line">            flush_block(&amp;bitmap[i/<span class="number">32</span>]);  <span class="comment">// 写回并重置脏位</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//panic(&quot;alloc_block not implemented&quot;);</span></span><br><span class="line">   <span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a>File Operations</h3><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4:"></a>Exercise 4:</h4><p>实现file_block_walk和file_get_block。file_block_walk将文件中的块偏移量映射到struct file或间接块中该块的指针，非常像pgdir_walk对页表所做的。File_get_block更进一步，映射到实际的磁盘块，如果需要，分配一个新的磁盘块。</p>
<p>file_block_walk 获得文件第<code>filebno</code>块的地址（其本身是个指针），编写需要注意以下几点。</p>
<ul>
<li><code>ppdiskbno</code> 是块指针（记录块的地址）</li>
<li><code>f_indirect</code> 直接记录块号，而不是记地址。</li>
<li><strong>Don’t forget to clear any block you allocate.</strong> 对分配的块进行清零操作后，要写入 disk 中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the disk block number slot for the &#x27;filebno&#x27;th block in file &#x27;f&#x27;.</span></span><br><span class="line"><span class="comment">// Set &#x27;*ppdiskbno&#x27; to point to that slot.</span></span><br><span class="line"><span class="comment">// The slot will be one of the f-&gt;f_direct[] entries,</span></span><br><span class="line"><span class="comment">// or an entry in the indirect block.</span></span><br><span class="line"><span class="comment">// When &#x27;alloc&#x27; is set, this function will allocate an indirect block</span></span><br><span class="line"><span class="comment">// if necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">// 0 on success (but note that *ppdiskbno might equal 0).</span></span><br><span class="line"><span class="comment">// -E_NOT_FOUND if the function needed to allocate an indirect block, but</span></span><br><span class="line"><span class="comment">//    alloc was 0.</span></span><br><span class="line"><span class="comment">// -E_NO_DISK if there&#x27;s no space on the disk for an indirect block.</span></span><br><span class="line"><span class="comment">// -E_INVAL if filebno is out of range (it&#x27;s &gt;= NDIRECT + NINDIRECT).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Analogy: This is like pgdir_walk for files.</span></span><br><span class="line"><span class="comment">// Hint: Don&#x27;t forget to clear any block you allocate.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">file_block_walk</span><span class="params">(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">uint32_t</span> **ppdiskbno, <span class="keyword">bool</span> alloc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// filenno   file block number</span></span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;file_block_walk not implemented&quot;);</span></span><br><span class="line">    <span class="comment">// ppdiskbno 块指针</span></span><br><span class="line">    <span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;   <span class="comment">// NDIRECT: Number of block pointers in a File descriptor</span></span><br><span class="line">        <span class="comment">// but note that *ppdiskbno might equal 0</span></span><br><span class="line">        <span class="keyword">if</span>(ppdiskbno)</span><br><span class="line">            *ppdiskbno = &amp;(f-&gt;f_direct[filebno]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filebno &gt;= NDIRECT + NINDIRECT)  <span class="comment">// NINDIRECT: Number of direct block pointers in an indirect block</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件还没分配</span></span><br><span class="line">    filebno -= NDIRECT;</span><br><span class="line">    <span class="keyword">if</span> (!!f-&gt;f_indirect) &#123;  <span class="comment">// !!把非0转换为1，而0还是0</span></span><br><span class="line">        <span class="keyword">if</span> (alloc == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">        <span class="comment">// 分配一个 indirect block</span></span><br><span class="line">        <span class="keyword">uint32_t</span> blockno;</span><br><span class="line">        <span class="keyword">if</span> ( (blockno = alloc_block()) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> blockno;</span><br><span class="line">        <span class="comment">// f_indirect 直接记录块号，而不是记地址</span></span><br><span class="line">        <span class="comment">// f-&gt;f_indirect = (uint32_t)diskaddr(blockno);</span></span><br><span class="line">        f-&gt;f_indirect = blockno;</span><br><span class="line">        <span class="built_in">memset</span>(diskaddr(blockno), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">        flush_block(diskaddr(blockno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ppdiskbno)</span><br><span class="line">        *ppdiskbno = (<span class="keyword">uint32_t</span> *)diskaddr(f-&gt;f_indirect) + filebno;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set *blk to the address in memory where the filebno&#x27;th</span></span><br><span class="line"><span class="comment">// block of file &#x27;f&#x27; would be mapped.</span></span><br><span class="line"><span class="comment">// 将*blk设置为文件&#x27;f&#x27;的第filebno块在内存中的映射地址。</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">// -E_NO_DISK if a block needed to be allocated but the disk is full.</span></span><br><span class="line"><span class="comment">// -E_INVAL if filebno is out of range.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: Use file_block_walk and alloc_block.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">file_get_block</span><span class="params">(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">char</span> **blk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *pdiskbno;  <span class="comment">// 块的块号指针</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ( (r = file_block_walk(f, filebno, &amp;pdiskbno, <span class="number">1</span>))&lt; <span class="number">0</span>)  <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> r;  <span class="comment">// 找到文件第filebno块的位置pdiskbno</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*pdiskbno == <span class="number">0</span>) &#123;  <span class="comment">// 这个位置还没分配</span></span><br><span class="line">        <span class="comment">// 文件块还未分配</span></span><br><span class="line">        <span class="keyword">if</span> ( (r = alloc_block()) &lt; <span class="number">0</span>)   <span class="comment">// alloc_block 在位图中搜索一个空闲块并分配它。当您分配一个块时，立即将更改的位图块刷新到磁盘。</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        *pdiskbno = r;</span><br><span class="line">        <span class="built_in">memset</span>(diskaddr(r), <span class="number">0</span>, BLKSIZE);</span><br><span class="line">        flush_block(diskaddr(r));  <span class="comment">// wb</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终指向块</span></span><br><span class="line">    *blk = diskaddr(*pdiskbno);  <span class="comment">// // Return the virtual address of this disk block.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// panic(&quot;file_get_block not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h3><p>由于其他环境无法直接调用文件系统环境中的函数，因此我们将通过 RPC 或在JOS的IPC机制上构建的RPC抽象来公开对文件系统环境的访问。 </p>
<p>RPC(Remote Procedure Call)。它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib/fd.c)  |   |   (fs/fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib/file.c) |   |  (fs/serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +-------------------+</span><br></pre></td></tr></table></figure>

<p>本质上RPC还是借助IPC机制实现的，普通进程通过IPC向FS进程间发送具体操作和操作数据，然后FS进程执行文件操作，最后又将结果通过IPC返回给普通进程。从上图中可以看到客户端的代码在lib/fd.c和lib/file.c两个文件中。服务端的代码在fs/fs.c和fs/serv.c两个文件中。<br>相关数据结构之间的关系可用下图来表示：</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/lab5_7_open()%E5%8E%9F%E7%90%86.png" alt="lab5_7_open原理.png"></p>
<p>文件系统服务端代码在fs/serv.c中，serve()中有一个无限循环，接收IPC请求，将对应的请求分配到对应的处理函数，然后将结果通过IPC发送回去。<br>对于客户端来说：发送一个32位的值作为请求类型，发送一个Fsipc结构作为请求参数，该数据结构通过IPC的页共享发给FS进程，在FS进程可以通过访问fsreq(0x0ffff000)来访问客户进程发来的Fsipc结构。<br>对于服务端来说：FS进程返回一个32位的值作为返回码，对于FSREQ_READ和FSREQ_STAT这两种请求类型，还额外通过IPC返回一些数据。</p>
<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p>Implement <code>serve_read</code> in <code>fs/serv.c.</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">serve_read</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc)</span>  <span class="comment">// 从指定文件中读取出内容，返回给调用者</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> =</span> &amp;ipc-&gt;read;  <span class="comment">// 指定文件</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> =</span> &amp;ipc-&gt;readRet;  <span class="comment">// 调用者</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (debug)</span><br><span class="line">      cprintf(<span class="string">&quot;serve_read %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Lab 5: Your code here:</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">openFile</span>* <span class="title">opf</span>;</span></span><br><span class="line">    <span class="keyword">if</span>((r = openfile_lookup(envid, req-&gt;req_fileid, &amp;opf))&lt;<span class="number">0</span>)&#123;  <span class="comment">// Look up an open file for envid.</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((r = file_read(opf-&gt;o_file, ret-&gt;ret_buf, req-&gt;req_n, opf-&gt;o_fd-&gt;fd_offset))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    of-&gt;o_fd-&gt;fd_offset +=r;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><p>Implement <code>serve_write</code> in <code>fs/serv.c</code> and <code>devfile_write</code> in <code>lib/file.c</code>.</p>
<p><strong>serve_write</strong>: 在<code>file_write</code>中考虑了块边界的问题<code>bn = MIN(BLKSIZE - pos % BLKSIZE, offset + count - pos);</code>，因此我们同样不需要对 req_n 进行处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">serve_write</span><span class="params">(<span class="keyword">envid_t</span> envid, struct Fsreq_write *req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">&quot;serve_write %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">of</span>;</span></span><br><span class="line">    <span class="keyword">int</span> reqn;</span><br><span class="line">    <span class="keyword">if</span> ( (r = openfile_lookup(envid, req-&gt;req_fileid, &amp;of)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    reqn = req-&gt;req_n &gt; PGSIZE? PGSIZE:req-&gt;req_n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( (r = file_write(of-&gt;o_file, req-&gt;req_buf, reqn, of-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    of-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>devfile_write</strong>:  <code>devfile_write</code>需要调用<code>fsipc</code>，其向文件服务器发送一个进程间请求，并等待回复。请求体保存在<code>fsipcbuf</code>中，回复部分也应该写回到 <code>fsipcbuf</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">devfile_write</span><span class="params">(struct Fd *fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 5: Your code here</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ( n &gt; <span class="keyword">sizeof</span> (fsipcbuf.write.req_buf)) </span><br><span class="line">        n = <span class="keyword">sizeof</span> (fsipcbuf.write.req_buf);</span><br><span class="line">    </span><br><span class="line">    fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">    fsipcbuf.write.req_n = n;</span><br><span class="line">    memmove(fsipcbuf.write.req_buf, buf, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  fsipc(FSREQ_WRITE, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Spawning-Processes"><a href="#Spawning-Processes" class="headerlink" title="Spawning Processes"></a>Spawning Processes</h2><p><code>slib/spawn.c中的spawn()创建一个新的进程，从文件系统加载用户程序，然后启动该进程来运行这个程序。spawn()就像UNIX中的fork()后面马上跟着exec()。 </code>spawn(const char *prog, const char **argv)`做如下一系列动作：</p>
<ol>
<li>从文件系统打开prog程序文件</li>
<li>调用系统调用sys_exofork()创建一个新的Env结构</li>
<li>调用系统调用sys_env_set_trapframe()，设置新的Env结构的Trapframe字段（该字段包含寄存器信息）。</li>
<li>根据ELF文件中program herder，将用户程序以Segment读入内存，并映射到指定的线性地址处。</li>
<li>调用系统调用sys_env_set_status()设置新的Env结构状态为ENV_RUNNABLE。</li>
</ol>
<p>我们实现了<code>spawn</code>而不是UNIX风格的<code>exec</code>，因为在没有内核特殊帮助的情况下，<code>spawn</code>更容易以“exokernel fashion”从用户空间实现。</p>
<h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><p>spawn C依赖新的系统调用sys_env_set_trapframe来初始化新创建的环境的状态。 在kern/syscall.c中实现sys_env_set_trapframe(不要忘记在sycall()中调度新的系统调用)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set envid&#x27;s trap frame to &#x27;tf&#x27;.</span></span><br><span class="line"><span class="comment">// tf is modified to make sure that user environments always run at code</span></span><br><span class="line"><span class="comment">// protection level 3 (CPL 3), interrupts enabled, and IOPL of 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">// -E_BAD_ENV if environment envid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//    or the caller doesn&#x27;t have permission to change envid.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_env_set_trapframe</span><span class="params">(<span class="keyword">envid_t</span> envid, struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">   <span class="comment">// Remember to check whether the user has supplied us with a good</span></span><br><span class="line">   <span class="comment">// address!</span></span><br><span class="line">   <span class="comment">// panic(&quot;sys_env_set_trapframe not implemented&quot;);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ( (r = envid2env(envid, &amp;env, <span class="number">1</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 什么时候会出现没有权限访问的问题？</span></span><br><span class="line">    user_mem_assert(env, tf, <span class="keyword">sizeof</span>(struct Trapframe), PTE_U);</span><br><span class="line">    <span class="comment">// 直接整个结构体也是可以赋值的</span></span><br><span class="line">    env-&gt;env_tf = *tf;</span><br><span class="line">    env-&gt;env_tf.tf_cs |= <span class="number">0x3</span>;</span><br><span class="line">    env-&gt;env_tf.tf_eflags &amp;=  (~FL_IOPL_MASK);</span><br><span class="line">    env-&gt;env_tf.tf_eflags |= FL_IF;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h3><p>在fork和spawn之间共享library的状态</p>
<p>在JOS中，每个设备类型都具有相应的<code>struct Dev</code>，其中包含指向实现读/写/等的函数指针。对于该设备类型。 <code>lib / fd.c</code>在此基础上实现了类似UNIX的通用文件描述符接口。 每个结构体Fd表示它的设备类型，<code>lib/fd.c</code>中的大多数函数只是将操作分派给适当的<code>struct Dev</code>中的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-device-class file descriptor operations</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dev_id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dev_name;</span><br><span class="line">    <span class="keyword">ssize_t</span> (*dev_read)(struct Fd *fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*dev_write)(struct Fd *fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*dev_close)(struct Fd *fd);</span><br><span class="line">    <span class="keyword">int</span> (*dev_stat)(struct Fd *fd, struct Stat *stat);</span><br><span class="line">    <span class="keyword">int</span> (*dev_trunc)(struct Fd *fd, <span class="keyword">off_t</span> length);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>UNIX文件描述符是一个大的概念，包含pipe，控制台I/O。在JOS中每种设备对应一个struct Dev结构，该结构包含函数指针，指向真正实现读写操作的函数。<br>lib/fd.c文件实现了UNIX文件描述符接口，但大部分函数都是简单对struct Dev结构指向的函数的包装。</p>
<p>我们希望共享文件描述符，JOS中定义PTE新的标志位PTE_SHARE，如果有个页表条目的PTE_SHARE标志位为1，那么这个PTE在fork()和spawn()中将被直接拷贝到子进程页表，从而让父进程和子进程共享相同的页映射关系，从而达到父子进程共享文件描述符的目的。</p>
<h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><p>修改lib/fork.c中的duppage()，使之正确处理有PTE_SHARE标志的页表条目。同时实现lib/spawn.c中的copy_shared_pages()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">void</span> *addr = (<span class="keyword">void</span>*) (pn * PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> (uvpt[pn] &amp; PTE_SHARE) &#123;</span><br><span class="line">        sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_SYSCALL);        <span class="comment">//对于标识为PTE_SHARE的页，拷贝映射关系，并且两个进程都有读写权限</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) &#123; <span class="comment">//对于UTOP以下的可写的或者写时拷贝的页，拷贝映射关系的同时，需要同时标记当前进程和子进程的页表项为PTE_COW</span></span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line">        <span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_U|PTE_P);    <span class="comment">//对于只读的页，只需要拷贝映射关系即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy the mappings for shared pages into the child address space.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copy_shared_pages</span><span class="params">(<span class="keyword">envid_t</span> child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> addr;</span><br><span class="line">    <span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; UTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">            (uvpt[PGNUM(addr)] &amp; PTE_U) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_SHARE)) &#123;</span><br><span class="line">            sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span>*)addr, child, (<span class="keyword">void</span>*)addr, (uvpt[PGNUM(addr)] &amp; PTE_SYSCALL));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="The-keyboard-interface"><a href="#The-keyboard-interface" class="headerlink" title="The keyboard interface"></a>The keyboard interface</h2><p>目前我们只能在内核监视器中才能接收输入。<code>kern/console.c</code> already contains the keyboard and serial drivers that have been used by the kernel monitor since lab 1, but now you need to attach these to the rest of the system.</p>
<p><code>kern/console.c</code> 已经包含了从实验1开始内核监视器就在使用的键盘和串行驱动程序，但是现在您需要将它们附加到系统的其他部分。</p>
<p>在<code>/kern/console.c/cons_getc()</code>中的代码，实现了在 monitor 模式下（禁止中断）可以正常获取用户输入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poll for any pending input characters,</span></span><br><span class="line">    <span class="comment">// so that this function works even when interrupts are disabled</span></span><br><span class="line">    <span class="comment">// (e.g., when called from the kernel monitor).</span></span><br><span class="line">    serial_intr();</span><br><span class="line">    kbd_intr();</span><br></pre></td></tr></table></figure>

<p>在 trap.c 中加入中断处理函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (IRQ_OFFSET + IRQ_KBD):</span><br><span class="line">    lapic_eoi();</span><br><span class="line">    kbd_intr();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> (IRQ_OFFSET + IRQ_SERIAL):</span><br><span class="line">    lapic_eoi();</span><br><span class="line">    serial_intr();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<h2 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>Lab5 主要介绍了文件系统的基本组成，为超级块分配易查找的位置，并在超级块中记录根目录文件，此后递进存储即实现了FS的多级目录。利用虚拟地址和MMIO实现了类似统一编址方式，我们可以很方便实现文件访问，其操作过程与内存访问很类似（在文件结构体中 walk 到块号）。</p>
<p>JOS在用户环境实现FS，FS接口是这个Lab的重点。其通过RPC公开接口，在JOS中利用IPC机制构建RPC抽象。regular env-&gt;read-&gt;ipc_send -&gt; ipc_recv-&gt;serve-&gt;file_read。<br>这实际上以微内核的方式实现的FS，FS的<code>serv</code>相当于一种微服务进程，其接收、解析内核转发的信息再执行相应的操作。消息通过一个页映射的<code>Union Fsipc</code>进行传递。</p>
<p><code>spawn</code>函数表现得像在Unix下创建子进程带有一个立刻执行<code>exec</code>的<code>fork</code>函数。exec()会把当前执行进程覆盖掉来执行外部程序，spawn()则会创建一个新的进程来执行。<strong>对于spawn的设计，还是有一些困惑，因为不明白 Unix-Style的exec是如何实现的，所以不能理解为什么spawn更容易在用户空间实现。</strong> </p>
<p>最后的Keyboard 接口和Shell都相对简单，比较容易理解。</p>
<ol>
<li>其他环境无法直接调用文件系统环境中的函数，要通过IPC，进程间消息传递实现。这里应该就是微内核的概念了。但为什么不能直接调用，是怎么实现不能直接调用的？是特意不让别的环境直接使用其函数吗？有没有方法可以实现不同用户程序可以直接调用其他用户程序的函数？</li>
</ol>
<p>不能直接调用，应该是因为每个用户态的代码都存在于自身的地址空间中，其他用户程序无法访问到。但是我如果在源代码中的某个环境直接#include并且调用另一个环境文件夹下的代码（例如fs），即在编译前就调用了，这会出现什么情况？这样就相当于是宏内核的概念了吗？ 或者是这样设计会增大代码的耦合性？这让我十分疑惑。毕竟这与越过系统调用不一样，系统调用有权限限制。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/04/6-828Lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/04/6-828Lab4/" class="post-title-link" itemprop="url">6-828Lab4</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-04 22:41:44" itemprop="dateCreated datePublished" datetime="2022-07-04T22:41:44+08:00">2022-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-08 14:33:20" itemprop="dateModified" datetime="2022-07-08T14:33:20+08:00">2022-07-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LAB4-Preemtive-Multitasking-抢占式多任务处理"><a href="#LAB4-Preemtive-Multitasking-抢占式多任务处理" class="headerlink" title="LAB4: Preemtive Multitasking   抢占式多任务处理"></a>LAB4: Preemtive Multitasking   抢占式多任务处理</h1><p>您将在多个同时活跃的用户模式环境中实现抢占式多任务处理。</p>
<p>在A部分中，您将向JOS添加多处理器支持，实现循环调度，并添加基本的环境管理系统调用(创建和销毁环境的调用，以及分配/映射内存的调用)。</p>
<p>在B部分中，您将实现一个类unix的fork()，它允许用户模式环境创建自身的副本。</p>
<p>最后，在C部分中，您将添加对进程间通信(IPC)的支持，允许不同的用户模式环境显式地相互通信和同步。您还将添加对硬件时钟中断和抢占的支持</p>
<h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking多处理器支持和多任务协作"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking多处理器支持和多任务协作" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking多处理器支持和多任务协作"></a>Part A: Multiprocessor Support and Cooperative Multitasking多处理器支持和多任务协作</h2><p>我们首先需要把 JOS 扩展到在多处理器系统中运行。然后实现一些新的 JOS 系统调用来允许用户进程创建新的进程。我们还要实现协同轮询调度，允许内核在当前进程自愿放弃CPU（或退出cpu）时从一个环境切换到另一个环境。</p>
<p>我们即将使 JOS 能够支持“对称多处理” (<strong>Symmetric MultiProcessing, SMP</strong>)。这种模式使所有 CPU 能对等地访问内存、I/O 总线等系统资源。虽然 CPU 在 SMP 下以同样的方式工作，在启动过程中他们可以被分为两个类型：引导处理器(<strong>BootStrap Processor, BSP</strong>) 负责初始化系统以及启动操作系统；应用处理器( <strong>Application Processors, AP</strong> ) 在操作系统拉起并运行后由 BSP 激活。哪个 CPU 作为 BSP 由硬件和 BIOS 决定。也就是说目前我们所有的 JOS 代码都运行在 BSP 上。<br>在 SMP 系统中，每个 CPU 都有一个附属的 LAPIC 单元。LAPIC 单元用于传递中断，并给它所属的 CPU 一个唯一的 ID。在 lab4 中，我们将会用到 LAPIC 单元的以下基本功能 ( 见kern/lapic.c中 )：</p>
<ul>
<li>读取 APIC ID 来判断我们的代码运行在哪个 CPU 之上。(see  <code>cpunum()</code> )</li>
<li>从 BSP 发送<code>STARTUP</code> 跨处理器中断 (InterProcessor Interrupt, IPI) 来启动 AP。(see <code>lapic_startap()</code> )</li>
<li>在 part C 中，我们为 LAPIC 的内置计时器编程来触发时钟中断以支持抢占式多任务处理。(see <code>apic_init()</code> )</li>
</ul>
<p>处理器通过<strong>映射在内存上的 I/O (Memory-Mapped I/O, MMIO)</strong> 来访问它的 LAPIC。在 MMIO 中，<strong>物理内存</strong>的一部分被<strong>硬连接</strong>到一些 I/O 设备的寄存器，因此，访问内存的 load/store 指令可以被用于访问设备的寄存器。实际上，我们在 lab1 中已经接触过这样的 IO hole，如<code>0xA0000</code>被用来写 VGA 显示缓冲。LAPIC 开始于<strong>物理地址</strong><code>0xFE000000</code> ( 4GB以下32MB处 )。如果用以前的映射算法（将<code>0xF0000000</code> 映射到 <code>0x00000000</code>，也就是说内核空间最高只能到物理地址<code>0x0FFFFFFF</code>）显然太高了。因此，JOS 在 <code>MMIOBASE</code> (即 虚拟地址<code>0xEF800000</code>) 预留了 4MB 来映射这类设备。我们需要写一个函数来分配这个空间并在其中映射设备内存。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705140300109.png" alt="image-20220705140300109"></p>
<p><strong>LAPIC 和 IOAPIC</strong></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/v2-869caa0c51df2aa8be0e868f38e1d322_1440w.jpg" alt="LAPIC 和 IOAPIC"></p>
<p>APIC全称是Advanced Programmable Interrupt Controller，高级可编程中断控制器。它是在奔腾P54C之后被引入进来的。</p>
<p>在现在的计算机它通常由两个部分组成，分别为<strong>LAPIC（Local APIC，本地高级可编程中断控制器）</strong>和<strong>IOAPIC(I/O高级可编程中断控制器）</strong>。</p>
<p>LAPIC在CPU中，IOAPIC通常位于南桥。</p>
<p>APIC是在PIC (Programmable Interrupt Controller) 的基础上发展而来的</p>
<p><strong>IOAPIC:</strong> IOAPIC的主要作用是中断的分发。最初有一条专门的APIC总线用于IOAPIC和LAPIC通信，在Pentium4 和Xeon 系列CPU出现后，他们的通信被合并到系统总线中。</p>
<h3 id="Exercise-1-Multiprocessor-Support"><a href="#Exercise-1-Multiprocessor-Support" class="headerlink" title="Exercise 1: Multiprocessor Support"></a><strong>Exercise 1: Multiprocessor Support</strong></h3><p>Implement <code>mmio_map_region</code> in <code>kern/pmap.c</code>. To see how this is used, look at the beginning of <code>lapic_init</code> in <code>kern/lapic.c</code>. You’ll have to do the next exercise, too, before the tests for <code>mmio_map_region</code> will run.</p>
<p>*<em>void <em>mmio_map_region(physaddr_t pa, size_t size)</em></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Reserve size bytes in the MMIO region and map [pa,pa+size) at this location.  Return the base of the reserved region.</span><br><span class="line">在MMIO区域保留大小为size字节的区域，然后把[pa, pa+size]映射到此区域，返回该区域的base.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">mmio_map_region</span><span class="params">(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Where to start the next region.  Initially, this is the</span></span><br><span class="line">   <span class="comment">// beginning of the MMIO region.  Because this is static, its</span></span><br><span class="line">   <span class="comment">// value will be preserved between calls to mmio_map_region</span></span><br><span class="line">   <span class="comment">// (just like nextfree in boot_alloc).</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Hint: The staff solution uses boot_map_region.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// Your code here:</span></span><br><span class="line">   <span class="comment">// panic(&quot;mmio_map_region not implemented&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取整页数</span></span><br><span class="line">    <span class="keyword">size_t</span> roundup_sz = ROUNDUP(size, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(base+roundup_sz &gt; MMIOLIM)&#123;</span><br><span class="line">        panic(<span class="string">&quot;mmio_map_region: out of MMIOLIM.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    boot_map_region(kern_pgdir, base, roundup_sz, pa, PTE_PCD|PTE_PWT|PTE_W);</span><br><span class="line">    <span class="keyword">uintptr_t</span> res_region_base = base;</span><br><span class="line">    base += roundup_sz;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)res_region_base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>void lapic_init(void)</strong></p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705153621702.png" alt="image-20220705153621702" style="zoom:50%;" />

<p>该函数一开始就调用了<code>mmin_map_region</code>函数，pa为lapicaddr，size为4096 = 4KB，即将从lapicaddr开始的4KB的物理地址映射到虚拟地址(保留区域)，以便我们能访问，然后返回保留区域的起始地址。</p>
<h3 id="Exercise-2-Application-Processor-Bootstrap"><a href="#Exercise-2-Application-Processor-Bootstrap" class="headerlink" title="Exercise 2: Application Processor Bootstrap"></a>Exercise 2: Application Processor Bootstrap</h3><p>在启动 APs 之前，BSP 需要先搜集多处理器系统的信息，例如 CPU 的总数，CPU 各自的 APIC ID，LAPIC 单元的 MMIO 地址。<code>kern/mpconfig.c</code> 中的 <code>mp_init()</code> 函数通过阅读 BIOS 区域内存中的 MP 配置表来获取这些信息。<br><code>boot_aps()</code> 函数驱动了 AP 的引导。APs 从实模式开始，如同 <code>boot/boot.S</code> 中 bootloader 的启动过程。因此 <code>boot_aps()</code> 将 AP 的入口代码 (<code>kern/mpentry.S</code>) 拷贝到实模式可以寻址的内存区域 (<code>0x7000</code>, <code>MPENTRY_PADDR</code>)。<br>此后，<code>boot_aps()</code> 通过发送 <code>STARTUP</code> 这个跨处理器中断到各 LAPIC 单元的方式，逐个激活 APs。激活方式为：初始化 AP 的 <code>CS:IP</code> 值使其从入口代码执行。通过一些简单的设置，AP 开启分页进入保护模式，然后调用 C 语言编写的 <code>mp_main()</code>。<code>boot_aps()</code> 等待 AP 发送 <code>CPU_STARTED</code> 信号，然后再唤醒下一个。</p>
<p>Read <code>boot_aps()</code> and <code>mp_main()</code> in <code>kern/init.c</code>, and the assembly code in <code>kern/mpentry.S</code>. Make sure you understand the control flow transfer during the bootstrap of APs. Then modify your implementation of <code>page_init()</code> in <code>kern/pmap.c</code>to avoid adding the page at <code>MPENTRY_PADDR</code> to the free list, so that we can safely copy and run AP bootstrap code at that physical address. Your code should pass the updated <code>check_page_free_list()</code> test (but might fail the updated <code>check_kern_pgdir()</code> test, which we will fix soon).</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705161234358.png" alt="image-20220705161234358"></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705161244343.png" alt="image-20220705161244343"></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705162615525.png" alt="image-20220705162615525"></p>
<p><strong>real mode表示我们看到的都是直接的物理地址</strong></p>
<p><strong>Question</strong></p>
<ol>
<li>Compare <code>kern/mpentry.S</code> side by side with <code>boot/boot.S</code>. Bearing in mind that <code>kern/mpentry.S</code> is compiled and linked to run above <code>KERNBASE</code> just like everything else in the kernel, <strong>what is the purpose of macro <code>MPBOOTPHYS</code>?</strong> Why is it necessary in <code>kern/mpentry.S</code> but not in <code>boot/boot.S</code>? In other words, what could go wrong if it were omitted in <code>kern/mpentry.S</code>?<br>Hint: recall the differences between the link address and the load address that we have discussed in Lab 1.</li>
</ol>
<p>​    <code>MPBOOTPHYS</code>的作用：</p>
<p><code>kern/mpentry.S</code>是运行在kernbase之上的，因此在实地址模式下，无法进行寻址（即无法访问）。</p>
<p><strong>kern/mpentry.S</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># This code is similar to boot/boot.S except that</span><br><span class="line">#    - it does not need to enable A20</span><br><span class="line">#    - it uses MPBOOTPHYS to calculate absolute addresses of its</span><br><span class="line">#      symbols, rather than relying on the linker to fill them</span><br><span class="line"></span><br><span class="line">#define RELOC(x) ((x) - KERNBASE)</span><br><span class="line">#define MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR)</span><br></pre></td></tr></table></figure>

<p>((s) - mpentry_start + MPENTRY_PADDR) 表示把mpentry地址转换到MPENTRY_PADDR。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705163912143.png" alt="image-20220705163912143"></p>
<p><code>kern/init.c</code>中已经进行了内容的拷贝，因此boot.S不需要再次 进行拷贝。而mpentry.S需要宏进行拷贝。</p>
<h3 id="Per-CPU-State-and-Initialization-CPU私有状态和初始化"><a href="#Per-CPU-State-and-Initialization-CPU私有状态和初始化" class="headerlink" title="Per-CPU State and Initialization(CPU私有状态和初始化)"></a>Per-CPU State and Initialization(CPU私有状态和初始化)</h3><p>当写一个多处理器操作系统时，分清 CPU 的私有状态 ( per-CPU state) 及全局状态 (global state) 非常关键。 <code>kern/cpu.h</code> 定义了大部分的 per-CPU 状态。<br>我们需要注意的 per-CPU 状态有：</p>
<ul>
<li><p>Per-CPU 内核栈<br>因为多 CPU 可能同时陷入内核态，我们需要给每个处理器一个独立的内核栈。用户态切到内核态，内核将用户态时的堆栈寄存器的值保存在内核栈中，以便于从内核栈切换回进程栈时能找到用户栈的地址。</p>
<p><code>percpu_kstacks[NCPU][KSTKSIZE]</code><br>在 Lab2 中，我们将 BSP 的内核栈映射到了 KSTACKTOP 下方。相似地，在 Lab4 中，我们需要把每个 CPU 的内核栈都映射到这个区域，每个栈之间留下一个空页作为缓冲区避免 overflow。CPU 0 ，即 BSP 的栈还是从 <code>KSTACKTOP</code> 开始，间隔 <code>KSTACKGAP</code> 的距离就是 CPU 1 的栈，以此类推。</p>
</li>
<li><p>Per-CPU TSS 以及 TSS 描述符<br>为了指明每个 CPU 的内核栈位置，需要任务状态段 (Task State Segment, TSS)，其功能在 Lab3 中已经详细讲过。</p>
</li>
<li><p>Per-CPU 当前环境指针<br>因为每个 CPU 能够同时运行各自的用户进程，我们重新定义了基于<code>cpus[cpunum()]</code> 的 <code>curenv</code>。</p>
</li>
<li><p>Per-CPU 系统寄存器<br>所有的寄存器，包括系统寄存器，都是 CPU 私有的。因此，初始化这些寄存器的指令，例如 <code>lcr3(), ltr(), lgdt(), lidt()</code> 等，必须在每个 CPU 都执行一次。</p>
</li>
</ul>
<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3."></a>Exercise 3.</h4><p>Modify <code>mem_init_mp()</code> (in <code>kern/pmap.c</code>) to map per-CPU stacks starting at <code>KSTACKTOP</code>, as shown in <code>inc/memlayout.h</code>. The size of each stack is <code>KSTKSIZE</code> bytes plus <code>KSTKGAP</code> bytes of unmapped guard pages. Your code should pass the new check in <code>check_kern_pgdir()</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">mem_init_mp</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// LAB 4: Your code here:</span></span><br><span class="line">    <span class="comment">// LAB 2 中只把BSP的内核栈 map 到了KSTACKTOP下方，这次把所有的cpu都进行map</span></span><br><span class="line">    <span class="comment">// 在 kern/cpu.h 中可以找到对 NCPU 以及全局变量 percpu_kstacks 的声明</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> start_addr = KSTACKTOP - KSTKSIZE;   <span class="comment">// 倒着来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = start_addr; i&lt;NCPU;++i)&#123;  <span class="comment">// i代表cpu编号</span></span><br><span class="line">        boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)start_addr, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);</span><br><span class="line">        start_addr-=(KSTKSIZE+KSTKGAP); <span class="comment">//gap是两个cpu之间的缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 即使从KSTACKTOP重新开始分配，之前的BSP会直接被覆盖掉，不会有影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a>Exercise 4.</h4><p>在 <code>inc/memlayout.h</code> 中可以看到之前分配BSP时，TSS0的定义</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705172629111.png" alt="image-20220705172629111"></p>
<p>这只是对单CPU而言的定义，那么对于多个cpu，就需要其他的TSS，<strong>如何寻找这个TSS？</strong>trap_init_percpu()注释中说明了</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705172824320.png" alt="image-20220705172824320"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize and load the per-CPU TSS and IDT</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_init_percpu</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// LAB 4: Your code here:</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span>* <span class="title">this_ts</span> =</span> &amp;thiscpu-&gt;cpu_ts;   <span class="comment">//!!!!!!!!!!!!</span></span><br><span class="line">   <span class="comment">// 一开始写成了struct Taskstate this_ts = thiscpu-&gt;cpu_ts;</span></span><br><span class="line">  <span class="comment">// 导致cpu的值并未改变，然后出现triple fault    ！！！！！！！！！！</span></span><br><span class="line">   <span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">   <span class="comment">// when we trap to the kernel.</span></span><br><span class="line">   ts.ts_esp0 = KSTACKTOP;</span><br><span class="line">   ts.ts_ss0 = GD_KD;</span><br><span class="line">   ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">   gdt[GD_TSS0 &gt;&gt; <span class="number">3</span>] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;ts),</span><br><span class="line">               <span class="keyword">sizeof</span>(struct Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   gdt[GD_TSS0 &gt;&gt; <span class="number">3</span>].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">   <span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">   ltr(GD_TSS0);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Load the IDT</span></span><br><span class="line">   lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>make qemu CPUS=4</code> (or <code>make qemu-nox CPUS=4</code>)</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220705180117691.png" alt="image-20220705180117691"></p>
<h3 id="Exercise5-Locking"><a href="#Exercise5-Locking" class="headerlink" title="Exercise5: Locking"></a>Exercise5: Locking</h3><p>我们现在的代码在初始化 AP 后就会开始自旋。在进一步操作 AP 之前，我们要先处理几个 CPU 同时运行内核代码的竞争情况。最简单的方法是用一个大内核锁 (big kernel lock)。它是一个全局锁，在某个进程进入内核态时锁定，返回用户态时释放。这种模式下，用户进程可以并发地在 CPU 上运行，但是同一时间仅有一个进程可以在内核态，其他需要进入内核态的进程只能等待。<br><code>kern/spinlock.h</code> 声明了一个大内核锁 <code>kernel_lock</code>。它提供了 <code>lock_kernel()</code> 和 <code>unlock_kernel()</code> 方法用于获得和释放锁。<strong>在以下 4 个地方需要使用到大内核锁：</strong></p>
<ul>
<li>在 <code>i386_init()</code>，BSP 唤醒其他 CPU 之前获得内核锁</li>
<li>在 <code>mp_main()</code>，初始化 AP 之后获得内核锁，之后调用 <code>sched_yield()</code> 在 AP 上运行进程。</li>
<li>在 <code>trap()</code>，当从用户态陷入内核态时获得内核锁，通过检查 <code>tf_Cs</code> 的低 2bit 来确定该 trap 是由用户进程还是内核触发。</li>
<li>在 <code>env_run()</code>，在切换回用户模式前释放内核锁。</li>
</ul>
<p>Apply the big kernel lock as described above, by calling <code>lock_kernel()</code> and <code>unlock_kernel()</code> at the proper locations.</p>
<p><strong>kern/init.c/i386_init()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">   lock_kernel();</span><br><span class="line"><span class="comment">// Starting non-boot CPUs</span></span><br><span class="line">boot_aps();</span><br></pre></td></tr></table></figure>

<p><strong>init.c/mp_main()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line"><span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line"><span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">   lock_kernel();</span><br><span class="line">   sched_yield();</span><br></pre></td></tr></table></figure>

<p><strong>trap.c/trap()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">3</span>) &#123;   <span class="comment">// 陷入了内核态</span></span><br><span class="line">   <span class="comment">// Trapped from user mode.</span></span><br><span class="line">   <span class="comment">// Acquire the big kernel lock before doing any</span></span><br><span class="line">   <span class="comment">// serious kernel work.</span></span><br><span class="line">   <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">       lock_kernel();</span><br><span class="line">   assert(curenv);</span><br></pre></td></tr></table></figure>

<p><strong>env.c/env_run()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">unlock_kernel();</span><br><span class="line">env_pop_tf(&amp;e-&gt;env_tf);</span><br></pre></td></tr></table></figure>



<p><strong>为什么要在这几处加大内核锁</strong><br>从根本上来讲，其设计的初衷就是保证独立性。由于分页机制的存在，内核以及每个用户进程都有自己的独立空间。而多进程并发的时候，如果两个进程同时陷入内核态，就无法保证独立性了。例如内核中有某个全局变量 A，cpu1 让 A=1， 而后 cpu2 却让 A=2，显然会互相影响。</p>
<p>BPS 启动 AP 前，获取内核锁，所以 AP 会在 mp_main 执行调度之前阻塞，在启动完 AP 后，BPS 执行调度，运行第一个进程，<code>env_run()</code> 函数中会释放内核锁，这样一来，其中一个 AP 就可以开始执行调度，运行其他进程。</p>
<p><strong>Question 2.</strong><br>It seems that using the big kernel lock guarantees that only one CPU can run the kernel code at a time. Why do we still need separate kernel stacks for each CPU? Describe a scenario in which using a shared kernel stack will go wrong, even with the protection of the big kernel lock</p>
<p>在某进程即将陷入内核态的时候（尚未获得锁），其实在 <code>trap()</code> 函数之前已经在 <code>trapentry.S</code> 中对内核栈进行了操作，压入了寄存器信息。如果共用一个内核栈，那显然会导致信息错误。</p>
<h3 id="Exercise6-Round-Robin-Scheduling-轮询调度"><a href="#Exercise6-Round-Robin-Scheduling-轮询调度" class="headerlink" title="Exercise6: Round-Robin Scheduling 轮询调度"></a>Exercise6: Round-Robin Scheduling 轮询调度</h3><p>下一个任务是让 JOS 内核能够以轮询方式在多个任务之间切换。其原理如下：</p>
<ul>
<li><code>kern/sched.c</code> 中的 <code>sched_yield()</code> 函数用来选择一个新的进程运行。它将从上一个运行的进程开始，按顺序循环搜索 <code>envs[]</code> 数组，选取第一个状态为 <code>ENV_RUNNABLE</code> 的进程执行。</li>
<li><code>sched_yield()</code>不能同时在两个CPU上运行同一个进程。如果一个进程已经在某个 CPU 上运行，其状态会变为 <code>ENV_RUNNING</code>。</li>
<li>程序中已经实现了一个新的系统调用 <code>sys_yield()</code>，进程可以用它来唤起内核的 <code>sched_yield()</code> 函数，从而将 CPU 资源移交给一个其他的进程</li>
</ul>
<p><strong>Exercise 6.</strong><br>Implement round-robin scheduling in <code>sched_yield()</code> as described above. Don’t forget to modify <code>syscall()</code> to dispatch <code>sys_yield()</code>.<br>Make sure to invoke <code>sched_yield()</code> in <code>mp_main</code>.<br>Modify <code>kern/init.c</code> to create three (or more!) environments that all run the program <code>user/yield.c</code>.</p>
<p>首先要找到正在运行的进程在envs[]中的序号。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220706103342874.png" alt="image-20220706103342874"></p>
<p><strong>sched.c/sched_yield()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Choose a user environment to run and run it.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sched_yield</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Implement simple round-robin scheduling.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// Search through &#x27;envs&#x27; for an ENV_RUNNABLE environment in</span></span><br><span class="line">   <span class="comment">// circular fashion starting just after the env this CPU was</span></span><br><span class="line">   <span class="comment">// last running.  Switch to the first such environment found.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// If no envs are runnable, but the environment previously</span></span><br><span class="line">   <span class="comment">// running on this CPU is still ENV_RUNNING, it&#x27;s okay to</span></span><br><span class="line">   <span class="comment">// choose that environment.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// Never choose an environment that&#x27;s currently running on</span></span><br><span class="line">   <span class="comment">// another CPU (env_status == ENV_RUNNING). If there are</span></span><br><span class="line">   <span class="comment">// no runnable environments, simply drop through to the code</span></span><br><span class="line">   <span class="comment">// below to halt the cpu.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    idle = curenv;</span><br><span class="line">    <span class="keyword">size_t</span> running_idx = (idle == <span class="literal">NULL</span>)?:<span class="number">-1</span>:ENVX(idle-&gt;env_id);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i&lt;NENV;++i)&#123;</span><br><span class="line">        running_idx = (running_idx+<span class="number">1</span> == NENV)?<span class="number">0</span>:running_idx+<span class="number">1</span>; <span class="comment">// 0代表从头再搜，因为起始点可能在中间</span></span><br><span class="line">        <span class="keyword">if</span>(envs[running_idx].env_status == RUNNABLE)&#123;  <span class="comment">// 选取第一个状态为RUNNABLE的进程执行</span></span><br><span class="line">            env_run(&amp;envs[running_idx]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有可运行的环境，但是之前在此CPU上运行的环境仍然是ENV_RUNNING，则可以选择该环境</span></span><br><span class="line">    <span class="keyword">if</span>(idle &amp;&amp; envs[idle].env_status == ENV_RUNNING)&#123;</span><br><span class="line">        env_run(idle);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// sched_halt never returns</span></span><br><span class="line">   sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>inc/syscall.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* system call numbers */</span> 在syscall.h中有定义，syscall不是trap！！！</span><br><span class="line"></span><br><span class="line"><span class="comment">/* system call numbers */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	SYS_cputs = <span class="number">0</span>,</span><br><span class="line">	SYS_cgetc,</span><br><span class="line">	SYS_getenvid,</span><br><span class="line">	SYS_env_destroy,</span><br><span class="line">	SYS_page_alloc,</span><br><span class="line">	SYS_page_map,</span><br><span class="line">	SYS_page_unmap,</span><br><span class="line">	SYS_exofork,</span><br><span class="line">	SYS_env_set_status,</span><br><span class="line">	SYS_env_set_pgfault_upcall,</span><br><span class="line">	SYS_yield,</span><br><span class="line">	SYS_ipc_try_send,</span><br><span class="line">	SYS_ipc_recv,</span><br><span class="line">	NSYSCALLS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Question 3.</strong><br>In your implementation of <code>env_run()</code> you should have called <code>lcr3()</code>. Before and after the call to <code>lcr3()</code>, your code makes references (at least it should) to the variable <code>e</code>, the argument to <code>env_run</code>. Upon loading the <code>%cr3</code> register, the addressing context used by the MMU is instantly changed. But a virtual address (namely <code>e</code>) has meaning relative to a given address context–the address context specifies the physical address to which the virtual address maps. Why can the pointer e be dereferenced both before and after the addressing switch?</p>
</blockquote>
<p>大意是问为什么通过 <code>lcr3()</code> 切换了页目录，还能照常对 <code>e</code> 解引用。回想在 lab3 中，曾经写过的函数 <code>env_setup_vm()</code>。它直接以内核的页目录作为模版稍做修改。因此两个页目录的 <code>e</code> 地址映射到同一物理地址。</p>
<blockquote>
<p><strong>Question 4.</strong><br>Whenever the kernel switches from one environment to another, it must ensure the old environment’s registers are saved so they can be restored properly later. Why? Where does this happen?</p>
</blockquote>
<p>在进程陷入内核时，会保存当前的运行信息，这些信息都保存在内核栈上。而当从内核态回到用户态时，会恢复之前保存的运行信息。<br>具体到 JOS 代码中，保存发生在 <code>kern/trapentry.S</code>，恢复发生在 <code>kern/env.c</code>。可以对比两者的代码。<br><strong>保存：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define TRAPHANDLER_NOEC(name, num)</span><br><span class="line">    .globl name;                            </span><br><span class="line">    .type name, @function;                      </span><br><span class="line">    .align 2;                           </span><br><span class="line">    name:                               </span><br><span class="line">    pushl $0;                           </span><br><span class="line">    pushl $(num);                           </span><br><span class="line">    jmp _alltraps</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">_alltraps:</span><br><span class="line">pushl %ds    // 保存当前段寄存器</span><br><span class="line">pushl %es</span><br><span class="line">pushal    // 保存其他寄存器</span><br><span class="line"></span><br><span class="line">movw $GD_KD, %ax</span><br><span class="line">movw %ax, %ds</span><br><span class="line">movw %ax, %es</span><br><span class="line">pushl %esp    //  保存当前栈顶指针</span><br><span class="line">call trap</span><br></pre></td></tr></table></figure>

<p><strong>恢复：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">env_pop_tf(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    // Record the CPU we are running on for user-space debugging</span><br><span class="line">    curenv-&gt;env_cpunum = cpunum();</span><br><span class="line"></span><br><span class="line">    asm volatile(</span><br><span class="line">        &quot;\tmovl %0,%%esp\n&quot;    // 恢复栈顶指针</span><br><span class="line">        &quot;\tpopal\n&quot;    // 恢复其他寄存器</span><br><span class="line">        &quot;\tpopl %%es\n&quot;    // 恢复段寄存器</span><br><span class="line">        &quot;\tpopl %%ds\n&quot;</span><br><span class="line">        &quot;\taddl $0x8,%%esp\n&quot; /* skip tf_trapno and tf_errcode */</span><br><span class="line">        &quot;\tiret\n&quot;</span><br><span class="line">        : : &quot;g&quot; (tf) : &quot;memory&quot;);</span><br><span class="line">    panic(&quot;iret failed&quot;);  /* mostly to placate the compiler */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">➜  lab git:(lab4) ✗ make qemu-nox CPUS=2</span><br><span class="line">***</span><br><span class="line">*** Use Ctrl-a x to exit qemu</span><br><span class="line">***</span><br><span class="line">qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log -smp 2 </span><br><span class="line">6828 decimal is 15254 octal!</span><br><span class="line">Physical memory: 131072K available, base = 640K, extended = 130432K</span><br><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_alloc() succeeded!</span><br><span class="line">check_page() succeeded!</span><br><span class="line">check_kern_pgdir() succeeded!</span><br><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_installed_pgdir() succeeded!</span><br><span class="line">SMP: CPU 0 found 2 CPU(s)</span><br><span class="line">enabled interrupts: 1 2</span><br><span class="line">SMP: CPU 1 starting</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">[00000000] new env 00001001</span><br><span class="line">[00000000] new env 00001002</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Hello, I am environment 00001000.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Hello, I am environment 00001001.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP fIncoming TRAP frame at 0xefffffbc</span><br><span class="line">rame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Hello, I am environment 00001002.</span><br><span class="line">xeffeffbc</span><br><span class="line">Back in environment 00001000, iteration 0.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001001, iteration 0.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001002, iteration 0.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001000, iteration 1.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001001, iteration 1.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001002, iteration 1.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001000, iteration 2.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001001, iteration 2.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001002, iteration 2.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001000, iteration 3.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001001, iteration 3.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001002, iteration 3.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001000, iteration 4.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">All done in environment 00001000.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Back in environment 00001001, iteration 4.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">All done in environment 00001001.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">Back in environment 00001002, iteration 4.</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">[00001001] exiting gracefully</span><br><span class="line">[00001001] free env 00001001</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">All done in environment 00001002.</span><br><span class="line">Incoming TRAP frame at 0xeffeffbc</span><br><span class="line">[00001002] exiting gracefully</span><br><span class="line">[00001002] free env 00001002</span><br><span class="line">No runnable environments in the system!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>cpu=2时，三个进程通过sys_yield切换了5次。</p>
<h3 id="Exercise-7-System-Calls-for-Environment-Creation-系统调用-创建进程"><a href="#Exercise-7-System-Calls-for-Environment-Creation-系统调用-创建进程" class="headerlink" title="Exercise 7: System Calls for Environment Creation(系统调用: 创建进程)"></a>Exercise 7: System Calls for Environment Creation(系统调用: 创建进程)</h3><p>现在我们的内核已经可以运行多个进程，并在其中切换了。不过，现在它仍然只能运行内核最初设定好的程序 (<code>kern/init.c</code>) 。现在我们即将实现一个新的系统调用，它允许进程创建并开始新的进程。<br>Unix 提供了 <code>fork()</code> 这个原始的系统调用来创建进程。<code>fork()</code>将会拷贝父进程的整个地址空间来创建子进程。在用户空间里，父子进程之间的唯一区别就是它们的进程 ID。<code>fork()</code>在父进程中返回其子进程的进程 ID，而在子进程中返回 0。父子进程之间是完全独立的，任意一方修改内存，另一方都不会受到影响。<br>我们将为 JOS 实现一个更原始的系统调用来创建新的进程。涉及到的系统调用如下：</p>
<ul>
<li><code>sys_exofork</code>:<br>这个系统调用将会创建一个空白进程：在其用户空间中没有映射任何物理内存，并且它是不可运行的。刚开始时，它拥有和父进程相同的寄存器状态。<code>sys_exofork</code> 将会在父进程返回其子进程的<code>envid_t</code>，子进程返回 0（当然，由于子进程还无法运行，也无法返回值，直到运行：）</li>
<li><code>sys_env_set_status</code>:<br>设置指定进程的状态。这个系统调用通常用于在新进程的地址空间和寄存器初始化完成后，将其标记为可运行。</li>
<li><code>sys_page_alloc</code>:<br>分配一个物理页并将其映射到指定进程的指定虚拟地址上。</li>
<li><code>sys_page_map</code>:<br>从一个进程中拷贝一个页面映射（而非物理页的内容）到另一个。即共享内存。</li>
<li><code>sys_page_unmap</code>:<br>删除到指定进程的指定虚拟地址的映射。</li>
</ul>
<blockquote>
<p><strong>Exercise 7.</strong><br>Implement the system calls described above in <code>kern/syscall.c</code>. You will need to use various functions in <code>kern/pmap.c</code> and <code>kern/env.c</code>, particularly <code>envid2env()</code>. For now, whenever you call <code>envid2env()</code>, pass 1 in the <code>checkperm</code> parameter. Be sure you check for any invalid system call arguments, returning <code>-E_INVAL</code> in that case. Test your JOS kernel with <code>user/dumbfork</code> and make sure it works before proceeding.</p>
</blockquote>
<p>一个比较冗长的练习。重点应该放在阅读 <code>user/dumbfork.c</code> 上，以便理解各个系统调用的作用。<br>在 <code>user/dumbfork.c</code> 中，核心是 <code>duppage()</code> 函数。它利用 <code>sys_page_alloc()</code> 为子进程分配空闲物理页，再使用<code>sys_page_map()</code> 将该新物理页映射到内核 <strong>(内核的 env_id = 0)</strong> 的交换区 <code>UTEMP</code>，方便在内核态进行 <code>memmove</code> 拷贝操作。在拷贝结束后，利用 <code>sys_page_unmap()</code> 将交换区的映射删除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> dstenv, <span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is NOT what you should do in your fork.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_alloc</span>(dstenv, addr, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_map</span>(dstenv, addr, <span class="number">0</span>, UTEMP, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sys_page_map: %e&quot;</span>, r);</span><br><span class="line">    <span class="built_in">memmove</span>(UTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_unmap</span>(<span class="number">0</span>, UTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sys_page_unmap: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sys_exofork() 函数</strong></p>
<p>该函数主要是分配了一个新的进程，但是没有做内存复制等处理。唯一值得注意的就是如何使子进程返回0。<br><code>sys_exofork()</code>是一个非常特殊的系统调用，它的定义与实现在 <code>inc/lib.h</code> 中，而不是 <code>lib/syscall.c</code> 中。并且，它必须是 inline 的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This must be inlined.  Exercise for reader: why?</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">envid_t</span> __attribute__((always_inline))</span><br><span class="line"><span class="built_in">sys_exofork</span>(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">envid_t</span> ret;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;int %2&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">             : <span class="string">&quot;=a&quot;</span> (ret)</span></span></span><br><span class="line"><span class="params"><span class="function">             : <span class="string">&quot;a&quot;</span> (SYS_exofork), <span class="string">&quot;i&quot;</span> (T_SYSCALL))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，它的返回值是 <code>%eax</code> 寄存器的值。那么，它到底是什么时候返回？这就涉及到对整个 进程-&gt;内核-&gt;进程 的过程的理解。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> envid_t</span><br><span class="line">sys_exofork(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_exofork not implemented&quot;);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span></span> *e;</span><br><span class="line">    int r = env_alloc(&amp;e, curenv-&gt;env_id);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_tf = curenv-&gt;env_tf;</span><br><span class="line">    e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该函数中，子进程复制了父进程的 trapframe，此后把 trapframe 中的 eax 的值设为了0。最后，返回了子进程的 id。注意，根据 <code>kern/trap.c</code> 中的 <code>trap_dispatch()</code> 函数，这个返回值仅仅是存放在了父进程的 trapframe 中，还没有返回。而是在返回用户态的时候，即在 <code>env_run()</code> 中调用 <code>env_pop_tf()</code> 时，才把 trapframe 中的值赋值给各个寄存器。这时候 <code>lib/syscall.c</code> 中的函数 <code>syscall()</code> 才获得真正的返回值。因此，在这里对子进程 trapframe 的修改，可以使得子进程返回0。</p>
<p><strong>sys_page_alloc() 函数</strong><br>在进程 envid 的目标地址 va 分配一个权限为 perm 的页面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_page_alloc</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_page_alloc not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> ((~perm &amp; (PTE_U|PTE_P)) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; (~(PTE_U|PTE_P|PTE_AVAIL|PTE_W))) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || <span class="built_in">PGOFF</span>(va) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL; </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pginfo</span> =</span> <span class="built_in">page_alloc</span>(ALLOC_ZERO);</span><br><span class="line">    <span class="keyword">if</span> (!pginfo) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">envid2env</span>(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    r = <span class="built_in">page_insert</span>(e-&gt;env_pgdir, pginfo, va, perm);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">page_free</span>(pginfo);</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sys_page_map() 函数</strong><br>简单来说，就是建立跨进程的映射。</p>
<p>在srcenvid地址空间的’srcva’映射到dstenvid地址空间的’dstva’，并赋予’perm ‘权限。Perm具有与sys_page_alloc相同的限制，但它也不能授予对只读页面的写访问权。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_page_map</span><span class="params">(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_page_map not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva &gt;= UTOP || <span class="built_in">PGOFF</span>(srcva) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)dstva &gt;= UTOP || <span class="built_in">PGOFF</span>(dstva) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; PTE_U) == <span class="number">0</span> || (perm &amp; PTE_P) == <span class="number">0</span> || (perm &amp; ~PTE_SYSCALL) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">src_e</span>, *<span class="title">dst_e</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">envid2env</span>(srcenvid, &amp;src_e, <span class="number">1</span>)&lt;<span class="number">0</span> || <span class="built_in">envid2env</span>(dstenvid, &amp;dst_e, <span class="number">1</span>)&lt;<span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    <span class="keyword">pte_t</span> *src_ptab;    </span><br><span class="line">    <span class="comment">// page_look_up()   返回映射到虚拟地址 va 的页面</span></span><br><span class="line">    <span class="comment">// page_insert()  建立一个虚拟地址与物理页的映射</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> <span class="built_in">page_lookup</span>(src_e-&gt;env_pgdir, srcva, &amp;src_ptab);   <span class="comment">// 查询srcva的page</span></span><br><span class="line">    <span class="keyword">if</span> ((*src_ptab &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (perm &amp; PTE_W) == <span class="number">1</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">page_insert</span>(dst_e-&gt;env_pgdir, pp, dstva, perm) &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_NO_MEM;   <span class="comment">// srcpage 映射到dstva</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sys_page_unmap() 函数</strong><br>取消映射。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_page_unmap</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span>  <span class="comment">//取消envid的地址空间中地址va的页映射</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_remove().</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">// panic(&quot;sys_page_unmap not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)va &gt;= UTOP || <span class="built_in">PGOFF</span>(va) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">envid2env</span>(envid, &amp;e, <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;    <span class="comment">// 获取envid对应的进程</span></span><br><span class="line">    <span class="built_in">page_remove</span>(e-&gt;env_pgdir, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sys_env_set_status() 函数</strong><br>设置状态，在子进程内存 map 结束后再使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_env_set_status</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_env_set_status not implemented&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) <span class="keyword">return</span> -E_INVAL;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">envid2env</span>(envid, &amp;e, <span class="number">1</span>) &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    e-&gt;env_status = status;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，不要忘记在 <code>kern/syscall.c</code> 中添加新的系统调用类型，注意参数的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> SYS_exofork:</span><br><span class="line">        retVal = (<span class="keyword">int32_t</span>)<span class="built_in">sys_exofork</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_env_set_status:</span><br><span class="line">        retVal = <span class="built_in">sys_env_set_status</span>(a1, a2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_page_alloc:</span><br><span class="line">        retVal = <span class="built_in">sys_page_alloc</span>(a1,(<span class="keyword">void</span> *)a2, (<span class="keyword">int</span>)a3);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_page_map:</span><br><span class="line">        retVal = <span class="built_in">sys_page_map</span>(a1, (<span class="keyword">void</span> *)a2, a3, (<span class="keyword">void</span>*)a4, (<span class="keyword">int</span>)a5);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SYS_page_unmap:</span><br><span class="line">        retVal = <span class="built_in">sys_page_unmap</span>(a1, (<span class="keyword">void</span> *)a2);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>make grade 成功。至此，part A 结束。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/10f822b3deda">https://www.jianshu.com/p/10f822b3deda</a></p>
<h2 id="Part-B-Copy-on-Write-Fork-写时拷贝的Fork"><a href="#Part-B-Copy-on-Write-Fork-写时拷贝的Fork" class="headerlink" title="Part B: Copy-on-Write Fork 写时拷贝的Fork"></a>Part B: Copy-on-Write Fork 写时拷贝的Fork</h2><p>在Part A中，通过把父进程的所有内存数据拷贝到子进程实现了<code>fork()</code>， 这也是 Unix 系统早期的实现。这个拷贝到过程是 <code>fork()</code> 时最昂贵的操作。<br>然而，调用了 <code>fork()</code> 之后往往立即就会在子进程中调用 <code>exec()</code> ，将子进程的内存更换为新的程序，例如 shell 经常干的（<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/64385b80210b">HW:Shell</a>)。这样，复制父进程的内存这个操作就完全浪费了。</p>
<p>因此，后来的 Unix 系统让父、子进程共享同一片物理内存，直到某个进程修改了内存。这被称作 <em>copy-on-write</em>。为了实现它，<code>fork()</code>时内核只拷贝页面的映射关系，而不拷贝其内容，同时将共享的页面标记为只读 (read-only)。当父子进程中任一方向内存中写入数据时，就会触发 page fault。此时，Unix 就知道应该分配一个私有的可写内存给这个进程。这个优化使得 <code>fork()</code> + <code>exec()</code> 连续操作变得非常廉价。在执行 <code>exec()</code> 之前，只需要拷贝一个页面，即当前的栈。</p>
<p>在 Part B 中，我们将实现上述更佳实现方式的 <code>fork()</code>。</p>
<h3 id="User-level-page-fault-handling-用户级别的页错误"><a href="#User-level-page-fault-handling-用户级别的页错误" class="headerlink" title="User-level page fault handling 用户级别的页错误"></a>User-level page fault handling 用户级别的页错误</h3><p>内核必须要记录进程不同区域出现页面错误时的处理方法。例如，一个栈区域的 page fault 会分配并映射一个新的页。一个 BSS 区域（用于存放程序中未初始化的全局变量、静态变量）的页错误会分配一个新的页面，初始化为0，再映射。<br>用户级别的页错误处理流程为：</p>
<ol>
<li>页错误异常，陷入内核</li>
<li>内核修改 <code>%esp</code> 切换到进程的异常栈，修改 <code>%eip</code> 让进程运行 _pgfault_upcall</li>
<li>_pgfault_upcall 将运行 page fault handler，此后不通过内核切换回正常栈</li>
</ol>
<p><strong>EIP为：返回本次调用后，下一条指令的地址。</strong></p>
<p><strong>ESP：存放当前线程的栈顶指针。</strong></p>
<p><strong>EBP：存放当前线程的栈底指针。</strong></p>
<p>在采用段式内存管理的架构中（比如intel的80x86系统），bss段（Block Started by Symbolsegment）通常是指用来存放程序中未初始化的全局变量的一块内存区域，一般在初始化时bss段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。</p>
<h5 id="Exercise-8-设置页错误处理函数"><a href="#Exercise-8-设置页错误处理函数" class="headerlink" title="Exercise 8: 设置页错误处理函数"></a>Exercise 8: 设置页错误处理函数</h5><p>为处理自己的页错误，进程需要在 JOS 注册一个 page fault handler entrypoint。进程通过 <code>sys_env_set_pgfault_upcall</code> 注册自己的 entrypoint，并在 <code>Env</code> 结构体中新增 <code>env_pgfault_upcall</code> 来记录该信息。</p>
<blockquote>
<p><strong>Exercise 8.</strong><br>Implement the <code>sys_env_set_pgfault_upcall</code> system call. Be sure to enable permission checking when looking up the environment ID of the target environment, since this is a “dangerous” system call.</p>
</blockquote>
<p><strong>进程的正常栈和异常栈</strong></p>
<p>正常运行时，JOS 的进程会运行在正常栈上，<code>ESP</code> 从<code>USTACKTOP</code>开始往下生长，栈上的数据存放在 <code>[USTACKTOP-PGSIZE, USTACKTOP-1]</code> 上。当出现页错误时，内核会把进程在一个新的栈（异常栈）上面重启，运行指定的用户级别页错误处理函数。也就是说完成了一次进程内的栈切换。这个过程与 trap 的过程很相似。<br>JOS 的异常栈也只有一个物理页大小，并且它的栈顶定义在虚拟内存 <code>UXSTACKTOP</code> 处。当运行在这个栈上时，用户级别页错误处理函数可以使用 JOS 的系统调用来映射新的页，以修复页错误。<br>每个需要支持用户级页错误处理的函数都需要分配自己的异常栈。可以使用 <code>sys_page_alloc()</code> 这个系统调用来实现。</p>
<p><strong>用户页错误处理函数</strong></p>
<p>现在我们需要修改 <code>kern/trap.c</code> 以支持用户级别的页错误处理。<br>如果没有注册 page fault handler，JOS内核就直接销毁进程。否则，内核就会初始化一个 trap frame 记录寄存器状态，在异常栈上处理页错误，恢复进程的执行。<code>UTrapframe</code> 在异常栈栈上如下所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time eflags</span><br><span class="line">trap-time eip</span><br><span class="line">trap-time eax       start of struct PushRegs</span><br><span class="line">trap-time ecx</span><br><span class="line">trap-time edx</span><br><span class="line">trap-time ebx</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time ebp</span><br><span class="line">trap-time esi</span><br><span class="line">trap-time edi       end of struct PushRegs</span><br><span class="line">tf_err (error code)</span><br><span class="line">fault_va            &lt;-- %esp when handler is run</span><br></pre></td></tr></table></figure>

<p>相比 trap 时使用的 <code>Trapframe</code>，多了记录错误位置的 <code>fault_va</code>，少了段选择器<code>%cs, %ds, %ss</code>。这反映了两者最大的不同：是否发生了进程的切换。<br>如果异常发生时，进程已经在异常栈上运行了，这就说明 page fault handler 本身出现了问题。这时，我们就应该在 <code>tf-&gt;tf_esp</code> 处分配新的栈，而不是在 <code>UXSTACKTOP</code>。首先需要 push 一个空的 32bit word 作为占位符，然后是一个 <code>UTrapframe</code> 结构体。<br>为检查 <code>tf-&gt;tf_esp</code> 是否已经在异常栈上了，只要检查它是否在区间 <code>[UXSTACKTOP-PGSIZE, UXSTACKTOP-1]</code> 上即可。</p>
<p><strong>以下9，10，11三个练习，建议按照调用顺序来看，即 11（设置handler）-&gt;9（切换到异常栈）-&gt;10（运行handler，切换回正常栈）。</strong></p>
<h5 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9."></a><strong>Exercise 9.</strong></h5><blockquote>
<p>Implement the code in <code>page_fault_handler</code> in <code>kern/trap.c</code> required to dispatch page faults to the user-mode handler. Be sure to take appropriate precautions when writing into the exception stack. (What happens if the user environment runs out of space on the exception stack?)</p>
</blockquote>
<p><em>可参考 Exercise 10 的 <code>lib/pfentry.S</code> 中的注释</em><br>较有难度的一个练习。首先需要理解用户级别的页错误处理的步骤是：<br><strong>进程A(正常栈) -&gt; 内核 -&gt; 进程A(异常栈) -&gt; 进程A(正常栈)</strong><br>那么内核的工作就是修改进程 A 的某些寄存器，并初始化异常栈，确保能顺利切换到异常栈运行。需要注意的是，由于修改了eip， <code>env_run()</code> 是不会返回的，因此不会继续运行后面销毁进程的代码。<br>值得注意的是，如果是嵌套的页错误，为了能实现递归处理，栈留出 32bit 的空位，直接向下生长。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">page_fault_handler(<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span></span> *tf)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t fault_va;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">    fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="number">3</span>) == <span class="number">0</span>) panic(<span class="string">&quot;Page fault in kernel-mode&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span>(curenv-&gt;env_pgfault_upcall)&#123;  <span class="comment">// Page fault upcall entry point</span></span><br><span class="line">        <span class="comment">// 建立异常栈</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span></span>* utf;  <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">if</span>(tf-&gt;tf_esp &lt; UXSTACKTOP &amp;&amp; tf-&gt;tf-&gt;esp &gt;=UXSTACKTOP-PGSIZE)&#123;</span><br><span class="line">            utf = (<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span></span> *)(tf-&gt;tf_esp - <span class="number">4</span> - sizeof(<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span></span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            utf = (<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span></span> *)(UXSTACKTOP - sizeof(<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span></span>));</span><br><span class="line">        &#125;</span><br><span class="line">        user_mem_assert(curenv, (void *)utf, sizeof(<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span></span>), PTE_U | PTE_W | PTE_P);</span><br><span class="line">        <span class="comment">// 检查用户是否有权限读取，无权限则摧毁，之后不再进行</span></span><br><span class="line">        <span class="comment">// 转存寄存器信息</span></span><br><span class="line">        utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">        utf-&gt;utf_err = tf-&gt;tf_trapno;</span><br><span class="line">        utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">        utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">        utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">        utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line">        <span class="comment">// 修改 esp 完成栈切换，修改 eip 运行 handler</span></span><br><span class="line">        tf-&gt;tf_eip = (uintptr_t)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">        <span class="comment">// tf-&gt;esp = (uintptr_t)utf - 1; 不需要减1</span></span><br><span class="line">        tf-&gt;tf_esp = (uintptr_t)utf;</span><br><span class="line">        env_run(curenv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">    cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">        curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Question</strong><br>What happens if the user environment runs out of space on the exception stack?</p>
</blockquote>
<p>在 <code>inc/memlayout.h</code> 中可以找到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UXSTACKTOP  UTOP</span></span><br><span class="line"><span class="comment">// Next page left invalid to guard against exception stack overflow;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220707135436275.png" alt="image-20220707135436275"></p>
<p>下面一页是空页，内核和用户访问都会报错。</p>
<p><strong>用户模式页错误入口</strong></p>
<p>在处理完页错误之后，现在我们需要编写汇编语句实现从异常栈到正常栈的切换。</p>
<h5 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10."></a>Exercise 10.</h5><p>Implement the <code>_pgfault_upcall</code> routine in <code>lib/pfentry.S</code>. The interesting part is returning to the original point in the user code that caused the page fault. You’ll return directly there, without going back through the kernel. The hard part is simultaneously switching stacks and re-loading the EIP.</p>
<p>汇编苦手，写的很艰难，最终还是参考了<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.csdn.net/bysui/article/details/51842817">别人的答案</a>。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    <span class="comment">// 调用用户定义的页错误处理函数</span></span><br><span class="line">    <span class="comment">// Call the C page fault handler.</span></span><br><span class="line">    pushl %esp          <span class="comment">// function argument: pointer to UTF</span></span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $<span class="number">4</span>, %esp           <span class="comment">// pop function argument</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    movl <span class="number">48</span>(%esp), %ebp</span><br><span class="line">    subl $<span class="number">4</span>, %ebp</span><br><span class="line">    movl %ebp, <span class="number">48</span>(%esp)</span><br><span class="line">    movl <span class="number">40</span>(%esp), %eax</span><br><span class="line">    movl %eax, (%ebp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore the trap-time registers.  After you do this, you</span></span><br><span class="line">    <span class="comment">// can no longer modify any general-purpose registers.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// 跳过 utf_err 以及 utf_fault_va</span></span><br><span class="line">    addl $<span class="number">8</span>, %esp</span><br><span class="line">    <span class="comment">// popal 同时 esp 会增加，执行结束后 %esp 指向 utf_eip</span></span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore eflags from the stack.  After you do this, you can</span></span><br><span class="line">    <span class="comment">// no longer use arithmetic operations or anything else that</span></span><br><span class="line">    <span class="comment">// modifies eflags.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// 跳过 utf_eip</span></span><br><span class="line">    addl $<span class="number">4</span>, %esp</span><br><span class="line">    <span class="comment">// 恢复 eflags</span></span><br><span class="line">    popfl</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch back to the adjusted trap-time stack.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// 恢复 trap-time 的栈顶</span></span><br><span class="line">    popl %esp</span><br><span class="line">    <span class="comment">// Return to re-execute the instruction that faulted.</span></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// ret 指令相当于 popl %eip</span></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>首先必须要理解异常栈的结构，下图所示的是嵌套异常时的情况。其中左边表示内容，右边表示地址。需要注意的是，上一次异常的栈顶之下间隔 4byte，就是一个新的异常。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4482847-a33e11e5c9c54849.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/496" alt="img"></p>
<p>uxstack.png</p>
<p>最难理解的是这一部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl <span class="number">48</span>(%esp), %ebp  <span class="comment">// 使 %ebp 指向 utf_esp</span></span><br><span class="line">subl $<span class="number">4</span>, %ebp</span><br><span class="line">movl %ebp, <span class="number">48</span>(%esp)  <span class="comment">// 更新 utf_esp 值为 utf_esp-4</span></span><br><span class="line">movl <span class="number">40</span>(%esp), %eax</span><br><span class="line">movl %eax, (%ebp)  <span class="comment">// 将 utf_esp-4 地址的内容改为 utf_eip</span></span><br></pre></td></tr></table></figure>

<p>经过这一部分的修改，异常栈更新为（红字标出）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4482847-210592f47937410a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492" alt="img"></p>
<p>uxstack_new.png</p>
<p>此后就是恢复各寄存器，最后的 <code>ret</code> 指令相当于 <code>popl %eip</code>，指令寄存器的值修改为 <code>utf_eip</code>，达到了返回的效果。</p>
<h5 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11."></a><strong>Exercise 11.</strong></h5><blockquote>
<p>Finish <code>set_pgfault_handler()</code> in <code>lib/pgfault.c</code>.</p>
</blockquote>
<p>该练习是用户用来指定缺页异常处理方式的函数。代码比较简单，但是需要区分清楚 <code>handler</code>，<code>_pgfault_handler</code>，<code>_pgfault_upcall</code> 三个变量。</p>
<ol>
<li><code>handler</code> 是传入的用户自定义页错误处理函数指针。</li>
<li><code>_pgfault_upcall</code> 是一个全局变量，在 <code>lib/pfentry.S</code> 中完成的初始化。它是页错误处理的总入口，页错误除了运行 page fault handler，还需要切换回正常栈。</li>
<li><code>_pgfault_handler</code> 被赋值为handler，会在 <code>_pgfault_upcall</code> 中被调用，是页错误处理的一部分。具体代码是：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _pgfault_upcall</span><br><span class="line">_pgfault_upcall:</span><br><span class="line">    <span class="comment">// Call the C page fault handler.</span></span><br><span class="line">    pushl %esp          <span class="comment">// function argument: pointer to UTF</span></span><br><span class="line">    movl _pgfault_handler, %eax</span><br><span class="line">    call *%eax</span><br><span class="line">    addl $<span class="number">4</span>, %esp</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">set_pgfault_handler</span><span class="params">(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// First time through!</span></span><br><span class="line">        <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">        <span class="comment">// panic(&quot;set_pgfault_handler not implemented&quot;);</span></span><br><span class="line">        <span class="keyword">envid_t</span> e_id = <span class="built_in">sys_getenvid</span>();</span><br><span class="line">        r = <span class="built_in">sys_page_alloc</span>(e_id, (<span class="keyword">void</span> *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;pgfault_handler: %e&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// r = sys_env_set_pgfault_upcall(e_id, handler);</span></span><br><span class="line">        r = <span class="built_in">sys_env_set_pgfault_upcall</span>(e_id, _pgfault_upcall);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;pgfault_handler: %e&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">    _pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若是第一次调用，需要首先分配一个页面作为异常栈，并且将该进程的 upcall 设置为 Exercise 10 中的程序。此后如果需要改变handler，不需要再重复这个工作。<br>最后直接通过 <code>make grade</code> 测试，满足要求。</p>
<blockquote>
<p><strong>Question</strong><br>Why <code>user/faultalloc</code> and <code>user/faultallocbad</code> behave differently?</p>
</blockquote>
<p>两者的 page fault handler 一样，但是一个使用 <code>cprintf()</code> 输出，另一个使用 <code>sys_cput()</code> 输出。<br><code>sys_cput()</code>直接通过 <code>lib/syscall.c</code> 发起系统调用，其实现在 <code>kern/syscall.c</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sys_cputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">    <span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="built_in">user_mem_assert</span>(curenv, s, len, PTE_U);</span><br><span class="line">    <span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">    <span class="built_in">cprintf</span>(<span class="string">&quot;%.*s&quot;</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它检查了内存，因此在这里 panic 了。中途没有触发过页错误。</p>
<p>而 <code>cprintf()</code> 的实现可以在 <code>lib/printf.c</code> 中找到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vcprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">printbuf</span> <span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">    b.idx = <span class="number">0</span>;</span><br><span class="line">    b.cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vprintfmt</span>((<span class="keyword">void</span>*)putch, &amp;b, fmt, ap);</span><br><span class="line">    <span class="built_in">sys_cputs</span>(b.buf, b.idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b.cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">cprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_start</span>(ap, fmt);</span><br><span class="line">    cnt = <span class="built_in">vcprintf</span>(fmt, ap);</span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它在调用 <code>sys_cputs()</code> 之前，首先在用户态执行了 <code>vprintfmt()</code> 将要输出的字符串存入结构体 <code>b</code> 中。在此过程中试图访问 <code>0xdeadbeef</code> 地址，触发并处理了页错误（其处理方式是在错误位置处分配一个字符串，内容是 <code>&quot;this string was faulted in at ...&quot;</code>），因此在继续调用 <code>sys_cputs()</code> 时不会出现 panic。</p>
<h3 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h3><p>如同 <code>dumbfork()</code> 一样，<code>fork()</code> 也要创建一个新进程，并且在新进程中建立与父进程同样的内存映射。关键的不同点是，**<code>dumbfork()</code> 拷贝了物理页的内容，而 <code>fork()</code> 仅拷贝了映射关系，仅在某个进程需要改写某一页的内容时，才拷贝这一页的内容。其基本流程如下：**</p>
<ol>
<li>父进程使用 <code>set_pgfault_handler</code>将 <code>pgfault()</code> 设为 page fault handler</li>
<li>父进程使用 <code>sys_exofork()</code> 建立一个子进程</li>
<li>对每个在 <code>UTOP</code> 之下可写页面以及 COW 页面（用 <code>PTE_COW</code> 标识），父进程调用 <code>duppage</code> 将其“映射”到子进程，同时将其权限改为只读，并用 <code>PTE_COW</code> 位来与一般只读页面区别<br>异常栈的分配方式与此不同，需要在子进程中分配一个新页面。因为 page fault handler 会实实在在地向异常栈写入内容，并在异常栈上运行。如果异常栈页面都用 COW 机制，那就没有能够执行拷贝这个过程的载体了</li>
<li>父进程会为子进程设置 user page fault entrypoint</li>
<li>子进程已经就绪，父进程将其设为 runnable</li>
</ol>
<p>进程第一次往一个 COW page 写入内容时，会发生 page fault，其流程为：</p>
<ol>
<li>内核将 page fault 传递至 <code>_pgfault_upcall</code>，它会调用 <code>pgfault()</code> handler</li>
<li><code>pgfault()</code> 检查错误类型，以及页面是否标记为<code>PTE_COW</code></li>
<li><code>pgfault()</code> 分配一个新的页面并将 fault page 的内容拷贝进去，然后将旧的映射覆盖，使其映射到该新页面。</li>
</ol>
<h5 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12."></a><strong>Exercise 12.</strong></h5><blockquote>
<p>Implement <code>fork</code>, <code>duppage</code> and <code>pgfault</code> in <code>lib/fork.c</code>.<br>Test your code with the <code>forktree</code> program.</p>
</blockquote>
<p>非常难的一个练习。</p>
<ul>
<li><p><strong>fork() 函数</strong></p>
<p>首先从主函数 <code>fork()</code> 入手，其大体结构可以仿造 <code>user/dumbfork.c</code> 写，但是有关键几处不同：</p>
<ul>
<li>设置 page fault handler，即 page fault upcall 调用的函数</li>
<li>duppage 的范围不同，<code>fork()</code> 不需要复制内核区域的映射</li>
<li>为子进程设置 page fault upcall，之所以这么做，是因为 <code>sys_exofork()</code> 并不会复制父进程的 <code>e-&gt;env_pgfault_upcall</code> 给子进程。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">envid_t</span></span></span><br><span class="line"><span class="function"><span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;fork not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_pgfault_handler</span>(pgfault);</span><br><span class="line">    <span class="keyword">envid_t</span> e_id = <span class="built_in">sys_exofork</span>();</span><br><span class="line">    <span class="keyword">if</span> (e_id &lt; <span class="number">0</span>) <span class="built_in">panic</span>(<span class="string">&quot;fork: %e&quot;</span>, e_id);</span><br><span class="line">    <span class="keyword">if</span> (e_id == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        thisenv = &amp;envs[<span class="built_in">ENVX</span>(<span class="built_in">sys_getenvid</span>())];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parent</span></span><br><span class="line">    <span class="comment">// extern unsigned char end[];</span></span><br><span class="line">    <span class="comment">// for ((uint8_t *) addr = UTEXT; addr &lt; end; addr += PGSIZE)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uintptr_t</span> addr = UTEXT; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (uvpd[<span class="built_in">PDX</span>(addr)] &amp; PTE_P) &amp;&amp; (uvpt[<span class="built_in">PGNUM</span>(addr)] &amp; PTE_P) ) &#123;</span><br><span class="line">            <span class="comment">// dup page to child</span></span><br><span class="line">            <span class="built_in">duppage</span>(e_id, <span class="built_in">PGNUM</span>(addr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// alloc page for exception stack</span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">sys_page_alloc</span>(e_id, (<span class="keyword">void</span> *)(UXSTACKTOP-PGSIZE), PTE_U | PTE_W | PTE_P);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="built_in">panic</span>(<span class="string">&quot;fork: %e&quot;</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DO NOT FORGET</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall();</span><br><span class="line">    r = <span class="built_in">sys_env_set_pgfault_upcall</span>(e_id, _pgfault_upcall);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="built_in">panic</span>(<span class="string">&quot;fork: set upcall for child fail, %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mark the child environment runnable</span></span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_env_set_status</span>(e_id, ENV_RUNNABLE)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sys_env_set_status: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>duppage() 函数</strong></p>
<p>该函数的作用是复制父、子进程的页面映射。尤其注意一个权限问题。由于 <code>sys_page_map()</code> 页面的权限有硬性要求，因此必须要修正一下权限。之前没有修正导致一直报错，后来发现页面权限为 <code>0x865</code>，不符合 <code>sys_page_map()</code> 要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">duppage</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;duppage not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">envid_t</span> this_env_id = <span class="built_in">sys_getenvid</span>();</span><br><span class="line">    <span class="keyword">void</span> * va = (<span class="keyword">void</span> *)(pn * PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> perm = uvpt[pn] &amp; <span class="number">0xFFF</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (perm &amp; PTE_W) || (perm &amp; PTE_COW) ) &#123;</span><br><span class="line">        <span class="comment">// marked as COW and read-only</span></span><br><span class="line">        perm |= PTE_COW;</span><br><span class="line">        perm &amp;= ~PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// IMPORTANT: adjust permission to the syscall</span></span><br><span class="line">    perm &amp;= PTE_SYSCALL;</span><br><span class="line">    <span class="comment">// cprintf(&quot;fromenvid = %x, toenvid = %x, dup page %d, addr = %08p, perm = %03x\n&quot;,this_env_id, envid, pn, va, perm);</span></span><br><span class="line">    <span class="keyword">if</span>((r = <span class="built_in">sys_page_map</span>(this_env_id, va, envid, va, perm)) &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;duppage: %e&quot;</span>,r);</span><br><span class="line">    <span class="keyword">if</span>((r = <span class="built_in">sys_page_map</span>(this_env_id, va, this_env_id, va, perm)) &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;duppage: %e&quot;</span>,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>pgfault() 函数</strong></p>
<p>这是 _pgfault_upcall 中调用的页错误处理函数。在调用之前，父子进程的页错误地址都引用同一页物理内存，该函数作用是分配一个物理页面使得两者独立。<br>首先，它分配一个页面，映射到了交换区 <code>PFTEMP</code> 这个虚拟地址，然后通过 <code>memmove()</code> 函数将 <code>addr</code> 所在页面拷贝至 <code>PFTEMP</code>，此时有两个物理页保存了同样的内容。再将 <code>addr</code> 也映射到 <code>PFTEMP</code> 对应的物理页，最后解除了 <code>PFTEMP</code> 的映射，此时就只有 <code>addr</code> 指向新分配的物理页了，如此就完成了错误处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">pgfault</span><span class="params">(struct UTrapframe *utf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">    <span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line">    <span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line">    <span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> ((err &amp; FEC_WR)==<span class="number">0</span> || (uvpt[<span class="built_in">PGNUM</span>(addr)] &amp; PTE_COW)==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;pgfault: invalid user trap frame&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line">    <span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line">    <span class="comment">// page to the old page&#x27;s address.</span></span><br><span class="line">    <span class="comment">// Hint:</span></span><br><span class="line">    <span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;pgfault not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">envid_t</span> envid = <span class="built_in">sys_getenvid</span>();</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_alloc</span>(envid, (<span class="keyword">void</span> *)PFTEMP, PTE_P | PTE_W | PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;pgfault: page allocation failed %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">    addr = <span class="built_in">ROUNDDOWN</span>(addr, PGSIZE);</span><br><span class="line">    <span class="built_in">memmove</span>(PFTEMP, addr, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_unmap</span>(envid, addr)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;pgfault: page unmap failed (%e)&quot;</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_map</span>(envid, PFTEMP, envid, addr, PTE_P | PTE_W |PTE_U)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;pgfault: page map failed (%e)&quot;</span>, r);</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">sys_page_unmap</span>(envid, PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;pgfault: page unmap failed (%e)&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>make run-forktree</code> 验证结果</p>
</li>
</ul>
<p>  ref：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d9b6dcce1c48">https://www.jianshu.com/p/d9b6dcce1c48</a></p>
<h2 id="Part-C-抢占式多进程处理-amp-进程间通信"><a href="#Part-C-抢占式多进程处理-amp-进程间通信" class="headerlink" title="Part C: 抢占式多进程处理 &amp; 进程间通信"></a>Part C: 抢占式多进程处理 &amp; 进程间通信</h2><p>作为 lab4 的最后一步，我们要修改内核使之能抢占一些不配合的进程占用的资源，以及允许进程之间的通信。</p>
<h3 id="Part-I-时钟中断以及抢占"><a href="#Part-I-时钟中断以及抢占" class="headerlink" title="Part I: 时钟中断以及抢占"></a>Part I: 时钟中断以及抢占</h3><p>尝试运行一下 <code>user/spin</code> 测试，该测试建立一个子进程，该子进程获得 CPU 资源后就进入死循环，这样内核以及父进程都无法再次获得 CPU。这显然是操作系统需要避免的。为了允许内核从一个正在运行的进程抢夺 CPU 资源，我们需要支持来自硬件时钟的外部硬件中断。</p>
<p><strong>Interrupt discipline</strong></p>
<p>外部中断用 IRQ(Interrupt Request) 表示。一共有 16 种 IRQ，在 <code>picirq.c</code>中将其增加了 <code>IRQ_OFFSET</code> 的偏移映射到了 IDT。<br>在 <code>inc/trap.h</code> 中， <code>IRQ_OFFSET</code> 被定义为 32。因此，IDT[32] 包含了时钟中断的处理入口地址。<br>联想 Lab3 中的内容：</p>
<blockquote>
<p>x86 的所有异常可以用中断向量 0<del>31 表示，对应 IDT 的第 0</del>31 项。例如，页错误产生一个中断向量为 14 的异常。大于 32 的中断向量表示的都是中断</p>
</blockquote>
<p>相对 xv6，在 JOS 中我们中了一个关键的简化：在内核态时禁用外部设备中断。外部中断使用 <code>%eflag</code> 寄存器的 <code>FL_IF</code> 位控制。当该位置 1 时，开启中断。由于我们的简化，我们只在进入以及离开内核时需要修改这个位。</p>
<p>我们需要确保在用户态时 <code>FL_IF</code> 置 1，使得当有中断发生时，可以被处理。我们在 bootloader 的第一条指令 <code>cli</code>就关闭了中断，然后再也没有开启过。</p>
<h4 id="Exercise-13"><a href="#Exercise-13" class="headerlink" title="Exercise 13."></a>Exercise 13.</h4><p>Modify <code>kern/trapentry.S</code> and <code>kern/trap.c</code> to initialize the appropriate entries in the IDT and provide handlers for IRQs 0 through 15. Then modify the code in <code>env_alloc()</code> in kern/env.c to ensure that user environments are always run with interrupts enabled.</p>
<p>比较简单，跟 Lab3 中的 Exercise 4 大同小异。相关的常数定义在 <code>inc/trap.h</code> 中可以找到。<br>在 <code>kern/trapentry.S</code> 中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// IRQs</span><br><span class="line">TRAPHANDLER(handler32, IRQ_OFFSET + IRQ_TIMER)</span><br><span class="line">TRAPHANDLER(handler33, IRQ_OFFSET + IRQ_KBD)</span><br><span class="line">TRAPHANDLER(handler36, IRQ_OFFSET + IRQ_SERIAL)</span><br><span class="line">TRAPHANDLER(handler39, IRQ_OFFSET + IRQ_SPURIOUS)</span><br><span class="line">TRAPHANDLER(handler46, IRQ_OFFSET + IRQ_IDE)</span><br><span class="line">TRAPHANDLER(handler51, IRQ_OFFSET + IRQ_ERROR)</span><br></pre></td></tr></table></figure>

<p>在 <code>kern/trap.c</code> 的 <code>trap_init()</code> 中加入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// IRQs</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler32</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler33</span><span class="params">()</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler36</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler39</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler46</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handler51</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// IRQs</span></span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], <span class="number">0</span>, GD_KT, handler32, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD], <span class="number">0</span>, GD_KT, handler33, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], <span class="number">0</span>, GD_KT, handler36, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="number">0</span>, GD_KT, handler39, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE], <span class="number">0</span>, GD_KT, handler46, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], <span class="number">0</span>, GD_KT, handler51, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在 <code>kern/env.c</code> 的 <code>env_alloc()</code> 中加入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable interrupts while in user mode.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure>

<p><strong>Handling Clock Interrupts</strong></p>
<p>在 <code>user/spin</code> 程序中，子进程开启后就陷入死循环，此后 kernel 无法再获得控制权。我们需要让硬件周期性地产生时钟中断，强制将控制权交给 kernel，使得我们能够切换到其他进程。</p>
<h4 id="Exercise-14"><a href="#Exercise-14" class="headerlink" title="Exercise 14."></a><strong>Exercise 14.</strong></h4><p>Modify the kernel’s <code>trap_dispatch()</code> function so that it calls <code>sched_yield()</code> to find and run a different environment whenever a clock interrupt takes place.</p>
<p>直接在 <code>trap_dispatch()</code> 中添加时钟中断的分支即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle clock interrupts. Don&#x27;t forget to acknowledge the</span></span><br><span class="line"><span class="comment">// interrupt using lapic_eoi() before calling the scheduler!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">    lapic_eoi();</span><br><span class="line">    sched_yield();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Part-II-进程间通信-Inter-Process-communication-IPC"><a href="#Part-II-进程间通信-Inter-Process-communication-IPC" class="headerlink" title="Part II: 进程间通信(Inter-Process communication)IPC"></a>Part II: 进程间通信(Inter-Process communication)IPC</h3><p><strong>IPC in JOS</strong></p>
<p>我们将实现两个系统调用：<code>sys_ipc_recv</code> 以及 <code>sys_ipc_try_send</code> ，再将他们封装为两个库函数，<code>ipc_recv</code> 和 <code>ipc_send</code> 以支持通信。<br>实际上，进程之间发送的信息是由两个部分组成，一个 <code>int32_t</code>，一个页面映射(可选)。</p>
<p><strong>发送和接收消息</strong></p>
<p>进程使用 <code>sys_ipc_recv</code> 来接收消息。该系统调用会将程序挂起，让出 CPU 资源，直到收到消息。在这个时期，任一进程都能给他发送信息，不限于父子进程。<br>为了发送信息，进程会调用 <code>sys_ipc_try_send</code>，以接收者的进程 id 以及要发送的值为参数。如果接收者已经调用了 <code>sys_ipc_recv</code> ，则成功发送消息并返回0。否则返回 <code>E_IPC_NOT_RECV</code> 表明目标进程并没有接收消息。<br><code>ipc_send</code> 库函数将会反复执行 <code>sys_ipc_try_send</code> 直到成功。</p>
<p><strong>传递页面</strong></p>
<p>当进程调用 <code>sys_ipc_recv</code> 并提供一个虚拟地址 <code>dstva</code> (必须位于用户空间) 时，进程表示它希望能接收一个页面映射。如果发送者发送一个页面，该页面就会被映射到接收者的 <code>dstva</code>。同时，之前位于 <code>dstva</code> 的页面映射会被覆盖。</p>
<p>当进程调用 <code>sys_ipc_try_send</code> 并提供一个虚拟地址 <code>srcva</code> (必须位于用户空间)，表明发送者希望发送位于 <code>srcva</code>的页面给接收者，权限设置为 <code>perm</code>。</p>
<p><strong>在一个成功的 IPC 之后，发送者和接受者将共享一个物理页。</strong></p>
<h4 id="Exercise-15"><a href="#Exercise-15" class="headerlink" title="Exercise 15."></a><strong>Exercise 15.</strong></h4><p>Implement <code>sys_ipc_recv</code> and <code>sys_ipc_try_send</code> in kern/syscall.c. Read the comments on both before implementing them, since they have to work together. When you call <code>envid2env</code> in these routines, you should set the <code>checkperm</code> flag to 0, meaning that any environment is allowed to send IPC messages to any other environment, and the kernel does no special permission checking other than verifying that the target envid is valid.<br>Then implement the <code>ipc_recv</code> and <code>ipc_send</code> functions in <code>lib/ipc.c</code>.</p>
<p>首先需要仔细阅读 <code>inc/env.h</code> 了解用于传递消息的数据结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lab 4 IPC</span></span><br><span class="line"><span class="keyword">bool</span> env_ipc_recving;       <span class="comment">// 当前进程的状态,表明当前进程是否处于接受状态。</span></span><br><span class="line"><span class="keyword">void</span> *env_ipc_dstva;        <span class="comment">// VA at which to map received page</span></span><br><span class="line"><span class="keyword">uint32_t</span> env_ipc_value;     <span class="comment">// 当前进程接收到的数据（如果用页来传递数据）。</span></span><br><span class="line"><span class="keyword">envid_t</span> env_ipc_from;       <span class="comment">// envid of the sender</span></span><br><span class="line"><span class="keyword">int</span> env_ipc_perm;       <span class="comment">// Perm of page mapping received</span></span><br></pre></td></tr></table></figure>

<p>然后需要注意的是通信流程。</p>
<ol>
<li>调用 <code>ipc_recv</code>，设置好 Env 结构体中的相关 field</li>
<li>调用 <code>ipc_send</code>，它会通过 envid 找到接收进程，并读取 Env 中刚才设置好的 field，进行通信。</li>
<li>最后返回实际上是在 <code>ipc_send</code> 中设置好 reg_eax，在调用结束，退出内核态时返回。</li>
</ol>
<p><strong>lib/ipc.c</strong></p>
<p>ipc_recv()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span></span></span><br><span class="line"><span class="function"><span class="title">ipc_recv</span><span class="params">(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">   <span class="comment">// panic(&quot;ipc_recv not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span>(pg!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        r = sys_ipc_recv(pg);  <span class="comment">// pg是个虚拟地址（必须位于用户空间），表示希望能接受一个页面映射到此虚拟地址</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        r = sys_ipc_recv(UTOP);  <span class="comment">// 如果不需要共享界面，则把虚拟地址设置为UTOP</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// fail</span></span><br><span class="line">        <span class="keyword">if</span> (from_env_store != <span class="literal">NULL</span>) *from_env_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (perm_store != <span class="literal">NULL</span>) *perm_store = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (from_env_store != <span class="literal">NULL</span>)</span><br><span class="line">            *from_env_store = thisenv-&gt;env_ipc_from;  <span class="comment">// 存取ipc sender&#x27;s page</span></span><br><span class="line">        <span class="keyword">if</span> (perm_store != <span class="literal">NULL</span>)</span><br><span class="line">            *perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">        <span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ipc_send</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ipc_send</span><span class="params">(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">   <span class="comment">// panic(&quot;ipc_send not implemented&quot;);</span></span><br><span class="line">    <span class="comment">// sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)</span></span><br><span class="line">    <span class="comment">// 发送位于srcva出得界面给接收者</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">if</span>(pg == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pg = (<span class="keyword">void</span>*) UTOP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        r = sys_ipc_try_send(to_env, val, pg, perm);</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span> &amp;&amp; r!=-E_IPC_NOT_RECV)&#123;</span><br><span class="line">            panic(<span class="string">&quot;ipc send failed.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        sys_yield();</span><br><span class="line">    &#125;<span class="keyword">while</span>(r!=<span class="number">0</span>);   <span class="comment">// 一直尝试发送</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>kern/syscall.c</strong></p>
<p>与 <code>sys_page_map()</code> 非常相似，但是其中最大的区别在于，ipc 通信并不限于父子进程之间，而 <code>sys_page_map()</code> 最初设计的作用就是用于 <code>fork()</code>。</p>
<p>sys_ipc_try_send</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_ipc_try_send</span><span class="params">(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva, <span class="keyword">unsigned</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">   <span class="comment">// panic(&quot;sys_ipc_try_send not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">envid_t</span> src_envid = sys_getenvid();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">dst_e</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(envid2env(env_id, &amp;dst_e, <span class="number">0</span>)&lt;<span class="number">0</span>)&#123;  <span class="comment">// Converts an envid to an env pointer.</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dst_e-&gt;env_ipc_recving == <span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pass the value</span></span><br><span class="line">    dst_e-&gt;env_ipc_value = value;</span><br><span class="line">    dst_e-&gt;env_ipc_perm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass the page</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva &lt; UTOP) &#123;</span><br><span class="line">        <span class="comment">// customerize 0x200 as PTE_NO_CHECK</span></span><br><span class="line">        <span class="keyword">unsigned</span> tmp_perm = perm | <span class="number">0x200</span>;</span><br><span class="line">        <span class="comment">// sys_page_map(envid_t srcenvid, void *srcva, envid_t dstenvid, void *dstva, int perm)</span></span><br><span class="line">        <span class="comment">// Map the page of memory at &#x27;srcva&#x27; in srcenvid&#x27;s address space</span></span><br><span class="line">        <span class="comment">// at &#x27;dstva&#x27; in dstenvid&#x27;s address space with permission &#x27;perm&#x27;.</span></span><br><span class="line">        <span class="keyword">int</span> r = sys_page_map(src_envid, srcva, envid, (<span class="keyword">void</span> *)dst_e-&gt;env_ipc_dstva, tmp_perm);  <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">        dst_e-&gt;env_ipc_perm = perm;</span><br><span class="line">    &#125;</span><br><span class="line">    dst_e-&gt;env_ipc_from = src_envid;</span><br><span class="line">    dst_e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    dst_e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    dst_e-&gt;env_ipc_recving = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_page_map</span><span class="params">(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">    <span class="comment">// panic(&quot;sys_page_map not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)srcva &gt;= UTOP || PGOFF(srcva) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uintptr_t</span>)dstva &gt;= UTOP || PGOFF(dstva) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> ((perm &amp; PTE_U) == <span class="number">0</span> || (perm &amp; PTE_P) == <span class="number">0</span> || (perm &amp; ~PTE_SYSCALL) != <span class="number">0</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">src_e</span>, *<span class="title">dst_e</span>;</span></span><br><span class="line">    <span class="comment">// add for lab4 exercise 15 for ipc.</span></span><br><span class="line">    <span class="comment">// customerize 0x200 as PTE_NO_CHECK</span></span><br><span class="line">    <span class="comment">// and we assume 0x200 is not used elsewhere, so we restore perm here.</span></span><br><span class="line">    <span class="keyword">bool</span> check_perm = (perm &amp; <span class="number">0x200</span>);</span><br><span class="line">    perm &amp;= (~<span class="number">0x200</span>);</span><br><span class="line">    <span class="keyword">if</span> (envid2env(srcenvid, &amp;src_e, !check_perm)&lt;<span class="number">0</span> || envid2env(dstenvid, &amp;dst_e, !check_perm)&lt;<span class="number">0</span>) <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    <span class="keyword">pte_t</span> *src_ptab;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_lookup(src_e-&gt;env_pgdir, srcva, &amp;src_ptab);</span><br><span class="line">    <span class="keyword">if</span> ((*src_ptab &amp; PTE_W) == <span class="number">0</span> &amp;&amp; (perm &amp; PTE_W) == <span class="number">1</span>) <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> (page_insert(dst_e-&gt;env_pgdir, pp, dstva, perm) &lt; <span class="number">0</span>) <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/28/6-828Lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/28/6-828Lab3/" class="post-title-link" itemprop="url">6.828Lab3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-28 22:15:45" itemprop="dateCreated datePublished" datetime="2022-06-28T22:15:45+08:00">2022-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-08 14:33:47" itemprop="dateModified" datetime="2022-07-08T14:33:47+08:00">2022-07-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LAB3-User-Environments"><a href="#LAB3-User-Environments" class="headerlink" title="LAB3: User Environments"></a>LAB3: User Environments</h1><p>实验三中，you will implement the basic kernel facilities required to get a protected user-mode environment (i.e., “process”) running. 将实现运行受保护的<strong>用户模式环境（即进程）</strong>所需的基本内核功能。将增强JOS内核以设置数据结构来跟踪 用户环境、创建单个用户环境、将程序映像（program image）加载到其中并开始运行。还需要使得JOS内核能够处理用户环境进行的任何调用和解决它所造成的一切异常情况。</p>
<p> <strong>killall XXX杀掉所有的进程 kill xxx(PID)杀死进程号xxx的进程,查看所有运行进程的命令:ps -aux</strong></p>
<h1 id="Part-A-User-Environment-and-Expection-Handling"><a href="#Part-A-User-Environment-and-Expection-Handling" class="headerlink" title="Part A: User Environment and Expection Handling"></a>Part A: User Environment and Expection Handling</h1><p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220629161158698.png" alt="image-20220629161158698"></p>
<p>inc/env.h 查看最大进程个数NENV为1024</p>
<p>kern/env.c 全局变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env指针指向一个由Env结构体组成的数组，同时，不活动的Env记录在env_free_list 中, 和之前的page_free_list很像</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> =</span> <span class="literal">NULL</span>;      <span class="comment">// All environments</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> =</span> <span class="literal">NULL</span>;    <span class="comment">// The current env    curenv记录着现在正在运行的进程，在第一个进程运行之前为空</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>  <span class="comment">// Free environment list</span></span><br><span class="line">               <span class="comment">// (linked by Env-&gt;env_link)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENVGENSHIFT    12    <span class="comment">// &gt;= LOGNENV</span></span></span><br></pre></td></tr></table></figure>

<p>inc/enc.h 中查看Env结构体的具体信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>   <span class="comment">// Saved registers </span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>     <span class="comment">// Next free Env</span></span><br><span class="line">   <span class="keyword">envid_t</span> env_id;          <span class="comment">// Unique environment identifier</span></span><br><span class="line">   <span class="keyword">envid_t</span> env_parent_id;    <span class="comment">// env_id of this env&#x27;s parent</span></span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span>    <span class="comment">// Indicates special system environments</span></span><br><span class="line">   <span class="keyword">unsigned</span> env_status;      <span class="comment">// Status of the environment</span></span><br><span class="line">   <span class="keyword">uint32_t</span> env_runs;    <span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Address space</span></span><br><span class="line">   <span class="keyword">pde_t</span> *env_pgdir;     <span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>env_id  进程的身份标识。</p>
<p>env_status 进程的运行状态。</p>
<p>env_link 类似于PageInfo中的pp_link，用于创建空闲进程链表，若进程槽已分配，则置为NULL。</p>
<p>env_tf 是一个Trapframe型的结构体（Trapframe是指中断、自陷、异常进入内核后，在堆栈上形成的一种数据结构），用于登记进程运行时的寄存器信息。</p>
<p>env_pgdir 指向进程运行所用的页目录，即描述了进程的用户地址空间。</p>
<p><em><strong>在JOS中，进程的运行实体是线程，而env_tf描述的实际上是所说的之行线程。文档中说明：当进程不在运行状态时，env_tf保存了进程的寄存器信息，内核在硬件控制权由用户转到内核时保存这些信息，使得进程可以在之后恢复到它交出控制权时的状态。</strong></em></p>
<h2 id="Exercise-1-Allocating-the-Environments-Array"><a href="#Exercise-1-Allocating-the-Environments-Array" class="headerlink" title="Exercise 1: Allocating the Environments Array"></a>Exercise 1: Allocating the Environments Array</h2><p>修改 kern/pmap.c 中的 mem_init() 来分配和映射 envs 数组。这个数组完全由 ENEV(1024) 个结构体Env组成，与分配 pages 数组的方式非常相似。同时像 pages 数组一样， 在UENVS(定义在inc/memlayout.h)上的用户，内存也该被映射为只读，这样用户进程就可以从这个数组中读取数据。</p>
<p><strong>You should run your code and make sure <code>check_kern_pgdir()</code> succeeds.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">mem_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> cr0;</span><br><span class="line">   <span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span></span><br><span class="line">   i386_detect_memory();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Remove this line when you&#x27;re ready to test this function.</span></span><br><span class="line">   <span class="comment">//panic(&quot;mem_init: This function is not finished\n&quot;);</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// create initial page directory.</span></span><br><span class="line">   kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">   <span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Recursively insert PD in itself as a page table, to form</span></span><br><span class="line">   <span class="comment">// a virtual page table at virtual address UVPT.</span></span><br><span class="line">   <span class="comment">// (For now, you don&#x27;t have understand the greater purpose of the</span></span><br><span class="line">   <span class="comment">// following line.)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">   kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span></span><br><span class="line">   <span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line">   <span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line">   <span class="comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span></span><br><span class="line">   <span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line">   <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Make &#x27;envs&#x27; point to an array of size &#x27;NENV&#x27; of &#x27;struct Env&#x27;.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Now that we&#x27;ve allocated the initial kernel data structures, we set</span></span><br><span class="line">   <span class="comment">// up the list of free physical pages. Once we&#x27;ve done so, all further</span></span><br><span class="line">   <span class="comment">// memory management will go through the page_* functions. In</span></span><br><span class="line">   <span class="comment">// particular, we can now map memory using boot_map_region</span></span><br><span class="line">   <span class="comment">// or page_insert</span></span><br><span class="line">   page_init();</span><br><span class="line"></span><br><span class="line">   check_page_free_list(<span class="number">1</span>);</span><br><span class="line">   check_page_alloc();</span><br><span class="line">   check_page();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line">   <span class="comment">// Permissions:</span></span><br><span class="line">   <span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line">   <span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">   <span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line">   <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Map the &#x27;envs&#x27; array read-only by the user at linear address UENVS</span></span><br><span class="line">   <span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line">   <span class="comment">// Permissions:</span></span><br><span class="line">   <span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line">   <span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line">   <span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line">   <span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">   <span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line">   <span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line">   <span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line">   <span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line">   <span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line">   <span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">   <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line">   <span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line">   <span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line">   <span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line">   <span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line">   <span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line">   <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check that the initial page directory has been set up correctly.</span></span><br><span class="line">   check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Switch from the minimal entry page directory to the full kern_pgdir</span></span><br><span class="line">   <span class="comment">// page table we just created. Our instruction pointer should be</span></span><br><span class="line">   <span class="comment">// somewhere between KERNBASE and KERNBASE+4MB right now, which is</span></span><br><span class="line">   <span class="comment">// mapped the same way by both page tables.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// If the machine reboots at this point, you&#x27;ve probably set up your</span></span><br><span class="line">   <span class="comment">// kern_pgdir wrong.</span></span><br><span class="line">   lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">   check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// entry.S set the really important flags in cr0 (including enabling</span></span><br><span class="line">   <span class="comment">// paging).  Here we configure the rest of the flags that we care about.</span></span><br><span class="line">   cr0 = rcr0();</span><br><span class="line">   cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;</span><br><span class="line">   cr0 &amp;= ~(CR0_TS|CR0_EM);</span><br><span class="line">   lcr0(cr0);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Some more checks, only possible after kern_pgdir is installed.</span></span><br><span class="line">   check_page_installed_pgdir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span></span><br><span class="line">    i386_detect_memory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove this line when you&#x27;re ready to test this function.</span></span><br><span class="line">    <span class="comment">// panic(&quot;mem_init: This function is not finished\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// create initial page directory.</span></span><br><span class="line">    kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">    <span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Recursively insert PD in itself as a page table, to form</span></span><br><span class="line">    <span class="comment">// a virtual page table at virtual address UVPT.</span></span><br><span class="line">    <span class="comment">// (For now, you don&#x27;t have understand the greater purpose of the</span></span><br><span class="line">    <span class="comment">// following line.)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span></span><br><span class="line">    <span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line">    <span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line">    <span class="comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span></span><br><span class="line">    <span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// 创建一个struct PageInfo 的数组</span></span><br><span class="line">    <span class="comment">// kernel 使用这个数组来耿总每个物理页</span></span><br><span class="line">    <span class="comment">// 对于每一个物理页，都会有一个对应的 struct PageInfo 在数组中</span></span><br><span class="line">    pages = (struct PageInfo *) boot_alloc(npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line">    <span class="comment">// npages 是内存中物理页的数量</span></span><br><span class="line">    <span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Now that we&#x27;ve allocated the initial kernel data structures, we set</span></span><br><span class="line">    <span class="comment">// up the list of free physical pages. Once we&#x27;ve done so, all further</span></span><br><span class="line">    <span class="comment">// memory management will go through the page_* functions. In</span></span><br><span class="line">    <span class="comment">// particular, we can now map memory using boot_map_region</span></span><br><span class="line">    <span class="comment">// or page_insert</span></span><br><span class="line">    page_init();</span><br><span class="line"></span><br><span class="line">    check_page_free_list(<span class="number">1</span>);</span><br><span class="line">    check_page_alloc();</span><br><span class="line">    check_page();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line">    <span class="comment">// Permissions:</span></span><br><span class="line">    <span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line">    <span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">    <span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// UPAGES是JOS记录物理页面使用情况的数据结构，只有kernel能够访问</span></span><br><span class="line">    <span class="comment">// 为了使用户空间能访问这块数据结构，会将PAGES映射到UPAGES的位置</span></span><br><span class="line">    <span class="comment">// 但是现在需要让用户空间能够读取这段线性地址，因此需要建立映射，将用户空间的一块内存映射到存储该数据结构的物理地址上</span></span><br><span class="line">    <span class="comment">// boot_map_region() 建立映射关系</span></span><br><span class="line">    boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)UPAGES, npages*<span class="keyword">sizeof</span>(struct PageInfo), PADDR(pages), PTE_U | PTE_P);</span><br><span class="line">    <span class="comment">// 目前建立了一个页目录，kernel_pgdir</span></span><br><span class="line">    <span class="comment">// pgdir为页目录指针， UPAGES为虚拟地址，npages*sizeof(struct* PageInfo)为映射的内存块大小</span></span><br><span class="line">    <span class="comment">// PADDR(pages) 为物理地址， PTE_U | PTE为权限 (PTE_U 表示用户可读)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line">    <span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line">    <span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">    <span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line">    <span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line">    <span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line">    <span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line">    <span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line">    <span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// kernel  内核栈</span></span><br><span class="line">    <span class="comment">// kernel stack 从虚拟地址 KSTACKTOP 开始，向低地址增长，所以KSTACKTOP实际上是栈顶</span></span><br><span class="line">    <span class="comment">// KSTACKTOP = 0xf0000000，</span></span><br><span class="line">    <span class="comment">// KSTKSIZE = (8*PGSIZE) = 8*4096(bytes) = 32KB</span></span><br><span class="line">    <span class="comment">// 只需要映射 [KSTACKTOP, KSTACKTOP - KSTKSIZE) 范围的虚拟地址</span></span><br><span class="line">    boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)(KSTACKTOP - KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);</span><br><span class="line">    <span class="comment">// PTE_W 开启了写权限，但是并未打开 PTE_U， 因此用户没有权限，只有内核有权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line">    <span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line">    <span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line">    <span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line">    <span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line">    <span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// 内核部分</span></span><br><span class="line">    <span class="comment">// KERNBASE    = 0xF0000000， VA大小为 2^32 - KERNBASE</span></span><br><span class="line">    <span class="comment">// ROUNDUP(a,n) 将a四舍五入到最接近n的倍数</span></span><br><span class="line">    boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)KERNBASE, ROUNDUP(<span class="number">0xffffffff</span> - KERNBASE + <span class="number">1</span>, PGSIZE), <span class="number">0</span>, PTE_W | PTE_P);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the initial page directory has been set up correctly.</span></span><br><span class="line">    check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch from the minimal entry page directory to the full kern_pgdir</span></span><br><span class="line">    <span class="comment">// page table we just created. Our instruction pointer should be</span></span><br><span class="line">    <span class="comment">// somewhere between KERNBASE and KERNBASE+4MB right now, which is</span></span><br><span class="line">    <span class="comment">// mapped the same way by both page tables.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the machine reboots at this point, you&#x27;ve probably set up your</span></span><br><span class="line">    <span class="comment">// kern_pgdir wrong.</span></span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">    check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// entry.S set the really important flags in cr0 (including enabling</span></span><br><span class="line">    <span class="comment">// paging).  Here we configure the rest of the flags that we care about.</span></span><br><span class="line">    cr0 = rcr0();</span><br><span class="line">    cr0 |= CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_MP;</span><br><span class="line">    cr0 &amp;= ~(CR0_TS | CR0_EM);</span><br><span class="line">    lcr0(cr0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some more checks, only possible after kern_pgdir is installed.</span></span><br><span class="line">    check_page_installed_pgdir();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="Exercise-2-Creating-and-Running-Environments"><a href="#Exercise-2-Creating-and-Running-Environments" class="headerlink" title="Exercise 2: Creating and Running Environments"></a>Exercise 2: Creating and Running Environments</h2><p>You will now write the code in <code>kern/env.c</code> necessary to run a user environment. Because we do not yet have a filesystem, we will set up the kernel to load a static binary image that is <em>embedded within the kernel itself</em>. <strong>JOS embeds this binary in the kernel as a ELF executable image.</strong></p>
<p>In <code>i386_init()</code> in <code>kern/init.c</code> you’ll see code to run one of these binary images in an environment. However, the critical functions to set up user environments are not complete; you will need to fill them in.</p>
<p><strong>在kern/env.c中，补充完成以下函数</strong></p>
<p><strong>env_init()</strong></p>
<p>​    初始化 envs 数组中所有的结构体 Env，并把它们添加到env_free_list。</p>
<p>​    调用 env_init_percpu，它为 privilege level 0(kernel)  和  privilege level 3(user) 配置特定的段。</p>
<p><strong>env_steup_vm()</strong></p>
<p>​    为新环境分配一个页目录，并且初始化新环境地址空间的内核部分。</p>
<p><strong>region_alloc()</strong></p>
<p>​    为环境分配和映射物理内存。</p>
<p><strong>load_icode()</strong></p>
<p>​    您需要解析ELF二进制映像，就像引导加载程序已经做的那样，并将其内容加载到新环境的用户地址空间中。</p>
<p><strong>env_create()</strong></p>
<p>​    使用env_alloc分配一个环境，并调用load_icode将ELF二进制文件加载到其中。</p>
<p><strong>env_run()</strong></p>
<p>​    启动以用户模式运行的给定环境。</p>
<p>As you write these functions, you might find the new cprintf verb <code>%e</code> useful – it prints a description corresponding to an error code. For example,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = -E_NO_MEM;</span><br><span class="line">panic(&quot;env_alloc: %e&quot;, r);</span><br></pre></td></tr></table></figure>

<p>will panic with the message “env_alloc: out of memory”.</p>
<p>Below is a call graph of the code up to the point where the user code is invoked. Make sure you understand the purpose of each step.</p>
<ul>
<li>start (kern/entry.S)</li>
<li>i386_init (kern/init.c)<ul>
<li>cons_init</li>
<li>mem_initenv_init</li>
<li>trap_init (still incomplete at this point)</li>
<li>env_create</li>
<li>env_run<ul>
<li>env_pop_tf</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>boot.S中通过ljmp跳转指令使cs的索引值指向代码段描述符，并将选择子ds、es、fs、gs和ss的索引值均设置为指向数据段描述符，至此这些段选择子均不曾被更改过。现在我们要创建进程，而原先的GDT中并没有特权级为3的数据段和代码段描述符，所以我们必须加载一个新的GDT。env_init_percpu重新加载了GDT，并设置了各个段选择子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">truct Segdesc gdt[] =</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 0x0 - unused (always faults -- for trapping NULL far pointers)</span></span><br><span class="line">   SEG_NULL,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x8 - kernel code segment</span></span><br><span class="line">   [GD_KT &gt;&gt; <span class="number">3</span>] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x10 - kernel data segment</span></span><br><span class="line">   [GD_KD &gt;&gt; <span class="number">3</span>] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x18 - user code segment</span></span><br><span class="line">   [GD_UT &gt;&gt; <span class="number">3</span>] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>, <span class="number">3</span>),</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x20 - user data segment</span></span><br><span class="line">   [GD_UD &gt;&gt; <span class="number">3</span>] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>, <span class="number">3</span>),</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x28 - tss, initialized in trap_init_percpu()</span></span><br><span class="line">   [GD_TSS0 &gt;&gt; <span class="number">3</span>] = SEG_NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pseudodesc</span> <span class="title">gdt_pd</span> =</span> &#123;</span><br><span class="line">   <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) gdt</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220701172502082.png" alt="image-20220701172502082"></p>
<p><strong>env_init()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up envs array</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// 初始化 envs 数组中所有的结构体 Env，添加到env_free_list</span></span><br><span class="line">    <span class="keyword">int</span> i = NENV;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        i--;</span><br><span class="line">        envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">        envs[i].env_link = env_free_list;</span><br><span class="line">        env_free_list = &amp;envs[i];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();  <span class="comment">// 重新加载</span></span><br></pre></td></tr></table></figure>

<p><strong>env_steup_vm()</strong></p>
<p>为新环境分配一个页目录，并且初始化新环境地址空间的内核部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">env_setup_vm</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))  <span class="comment">// 给p分配个 页目录</span></span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//    - The VA space of all envs is identical above UTOP</span></span><br><span class="line">	<span class="comment">//	(except at UVPT, which we&#x27;ve set below).</span></span><br><span class="line">	<span class="comment">//	See inc/memlayout.h for permissions and layout.</span></span><br><span class="line">	<span class="comment">//	Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line">	<span class="comment">//	(Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line">	<span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line">	<span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line">	<span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line">	<span class="comment">//	physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line">	<span class="comment">//	is an exception -- you need to increment env_pgdir&#x27;s</span></span><br><span class="line">	<span class="comment">//	pp_ref for env_free to work correctly.</span></span><br><span class="line">	<span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// env_setup_vm负责创建进程自己的页目录，并初始化内核地址空间。</span></span><br><span class="line">    <span class="comment">// 它不需要为内核地址空间另外创建页表，只要先将内核页目录kern_pgdir的所有目录项复制过来即可，以后再设置用户地址空间。</span></span><br><span class="line">    <span class="comment">// // pde_t *env_pgdir;		// Kernel virtual address of page dir</span></span><br><span class="line">    e-&gt;env_pgdir = page2kva(p);</span><br><span class="line">    <span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line">    p-&gt;pp_ref++;  <span class="comment">// p此时指向了页目录</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// UVPT maps the env&#x27;s own page table read-only.</span></span><br><span class="line">	<span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line">    <span class="comment">// PDX()   page directory index   NPDENTRIES	1024</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>region_alloc()</strong></p>
<p>为环境env分配 len 字节的物理内存，并将其映射到环境地址空间中的虚拟地址va。不以任何方式将映射页归零或初始化。页面应该是用户和内核可写的。Panic if any allocation attempt fails.</p>
<p>region_alloc为一个进程分配指定长度的内存空间，并按指定的起始线性地址映射到分配的物理内存上。该函数只在加载用户程序到内存中时（目前通过load_icode）才被用到，分配用户栈的工作将交给load_icode完成。我们会用到lab2中实现的page_alloc和page_insert分别完成物理页的分配与映射。我们不需要对被分配的物理页进行初始化，物理页的权限将被设置为内核和用户都可读写，va和va+len需要设置为页对齐（corner-case应该是当分配的地址超过UTOP时，这里直接panic）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">region_alloc</span><span class="params">(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line">    <span class="comment">//   &#x27;va&#x27; and &#x27;len&#x27; values that are not page-aligned.</span></span><br><span class="line">    <span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line">    <span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> va_start = ROUNDDOWN((<span class="keyword">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">    <span class="keyword">uintptr_t</span> va_end = ROUNDUP((<span class="keyword">uintptr_t</span>)va + len, PGSIZE);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pginfo</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cur_va = va_start;cur_va&lt;va_end;cur_va+=PGSIZE)&#123;</span><br><span class="line">        pginfo = page_alloc(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!pginfo)&#123;</span><br><span class="line">            panic(<span class="string">&quot;region_alloc: pageinfo failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;insert page at %08x\n.&quot;</span>, cur_va);</span><br><span class="line">        page_insert(e-&gt;env_pgdir, pginfo, (<span class="keyword">void</span>*)cur_va, PTE_U | PTE_W | PTE_P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>load_icode()</strong></p>
<p>由于我们还没有实现文件系统，甚至连磁盘都没有，所以当然不可能从磁盘上加载一个用户程序到内存中。因此，我们暂时将ELF可执行文件嵌入内核，并从内存中加载这样的ELF文件，以此模拟从磁盘加载用户程序的过程。lab3 GNUmakefile负责设置将这样的ELF可执行文件直接嵌入内核</p>
<p><u>Hint:</u></p>
<p>在ELF段头指定的地址处把每个程序段加载到虚拟内存中。</p>
<p>你应该只加载 <code>ph-&gt;p_type == ELF_PROG_LOAD</code> 的段。</p>
<p>每个段的虚拟地址可以使用 <code>ph-&gt;p_va</code> 得到，同时它在内存中的大小可通过<code>ph-&gt;memsz</code>得到。</p>
<p>The <code>ph-&gt;p_filesz</code> bytes from the ELF binary, starting at <code>binary + ph-&gt;p_offset</code>, should be copied to virtual address  <code>ph-&gt;p_va</code>. </p>
<p>ELF头应该有 <code>ph-&gt;p_filesz &lt;= ph-&gt;p_memsz</code>.</p>
<p>所有的页面是用户可读/写的。</p>
<p>ELF段不一定是页面对齐的，但是你可以假设这个函数中没有两个段会接触同一个虚拟页面。</p>
<p>您还必须对程序的入口点做一些操作，以确保环境从那里开始执行。</p>
<p>怎么切换页目录？<br>lcr3([页目录物理地址]) 将地址加载到 cr3 寄存器。</p>
<p>怎么更改函数入口？<br>将 <code>env-&gt;env_tf.tf_eip</code> 设置为 <code>elf-&gt;e_entry</code>，等待之后的 <code>env_pop_tf()</code> 调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">load_icode</span><span class="params">(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//  Load each program segment into virtual memory</span></span><br><span class="line">	<span class="comment">//  at the address specified in the ELF segment header.</span></span><br><span class="line">	<span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></span><br><span class="line">	<span class="comment">//  Each segment&#x27;s virtual address can be found in ph-&gt;p_va</span></span><br><span class="line">	<span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></span><br><span class="line">	<span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></span><br><span class="line">	<span class="comment">//  &#x27;binary + ph-&gt;p_offset&#x27;, should be copied to virtual address</span></span><br><span class="line">	<span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span></span><br><span class="line">	<span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></span><br><span class="line">	<span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  All page protection bits should be user read/write for now.</span></span><br><span class="line">	<span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></span><br><span class="line">	<span class="comment">//  assume for this function that no two segments will touch</span></span><br><span class="line">	<span class="comment">//  the same virtual page.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You may find a function like region_alloc useful.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  Loading the segments is much simpler if you can move data</span></span><br><span class="line">	<span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></span><br><span class="line">	<span class="comment">//  So which page directory should be in force during</span></span><br><span class="line">	<span class="comment">//  this function?</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You must also do something with the program&#x27;s entry point,</span></span><br><span class="line">	<span class="comment">//  to make sure that the environment starts executing there.</span></span><br><span class="line">	<span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf_hdr</span> =</span> (struct Elf *)binary;   <span class="comment">// ELF头// 准备对二进制ELF文件进行操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span>   <span class="comment">// 程序头</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(elf_hdr-&gt;e_magic != ELF_MAGIC)&#123;</span><br><span class="line">        panic(<span class="string">&quot;load_icode: invalid ELF binary.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ph = (struct Proghdr*)(binary + elf_hdr-&gt;e_phoff);  <span class="comment">// 加上偏移量</span></span><br><span class="line">    eph = ph+elf_hdr-&gt;e_phnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换页目录</span></span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));  <span class="comment">// lcr3() to switch to its address space.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;ph&lt;eph;ph++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;  <span class="comment">// 满足ELF的条件</span></span><br><span class="line">            <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">                panic(<span class="string">&quot;load_icode: file size is greater than memory size&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            region_alloc(e, (<span class="keyword">void</span>*)ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)ph-&gt;p_va, binary+ph-&gt;p_offset, ph-&gt;p_filesz);    <span class="comment">// 拷贝文件内容</span></span><br><span class="line">            <span class="built_in">memset</span>((<span class="keyword">void</span>*)ph-&gt;p_va + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;env_tf.tf_eip = elf_hdr-&gt;e_entry; <span class="comment">// 切换入口</span></span><br><span class="line">	<span class="comment">// Now map one page for the program&#x27;s initial stack</span></span><br><span class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line">    <span class="comment">// 现在映射一个页面为程序的初始堆栈在虚拟地址USTACKTOP - PGSIZE.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    region_alloc(e,(<span class="keyword">void</span>*)USTACKTOP - PGSIZE, PGSIZE);</span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>env_create()</strong><br>作用是新建一个进程。调用已经写好的 env_alloc() 函数即可，之后更改类型并且利用 load_icode() 读取 ELF。</p>
<p>这里的进程即环境.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用是新建一个进程。</span></span><br><span class="line"><span class="comment">// 调用已经写好的 env_alloc() 函数即可，之后更改类型并且利用 load_icode() 读取 ELF。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">env_create</span><span class="params">(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span>   <span class="comment">// 新建一个进程</span></span><br><span class="line">    <span class="keyword">int</span> r = env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;env_create: env alloc error.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配成功</span></span><br><span class="line">    e-&gt;env_type = ENV_TYPE_USER;</span><br><span class="line">    load_icode(e, binary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>env_run()</strong></p>
<p>​    启动以用户模式运行的给定环境。</p>
<p>//步骤1:如果这是一个上下文切换(一个新的环境正在运行):</p>
<p>/ / 1。设置当前环境(如果有的话)回ENV_RUNNABLE如果它是ENV_RUNNING(想想它可以处于什么其他状态)，</p>
<p>/ / 2。将’curenv’设置为新环境，</p>
<p>/ / 3。设置它的状态为ENV_RUNNING，更新env_status</p>
<p>/ / 4。更新它的’env_runs’计数器，</p>
<p>/ / 5。使用lcr3()切换到它的地址空间。</p>
<p>//步骤2:使用env_pop_tf()恢复环境的寄存器，并在环境中进入用户模式。</p>
<p>//Hint: 这个函数从<code>e-&gt;env_tf</code>加载新环境的状态。返回前面编写的代码，确保将e-&gt;env_tf的相关部分设置为合理的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">env_run</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Hint: This function loads the new environment&#x27;s state from</span></span><br><span class="line">   <span class="comment">// e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line">   <span class="comment">// and make sure you have set the relevant parts of</span></span><br><span class="line">   <span class="comment">// e-&gt;env_tf to sensible values.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// struct Env *curenv 记录着当前正在运行的进程</span></span><br><span class="line">    <span class="keyword">if</span>(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    curenv = e;</span><br><span class="line">    e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">    e-&gt;env_runs++;</span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// panic(&quot;env_run not yet implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Exercise-3-Handling-Interrupts-and-Exceptions"><a href="#Exercise-3-Handling-Interrupts-and-Exceptions" class="headerlink" title="Exercise 3: Handling Interrupts and Exceptions"></a>Exercise 3: Handling Interrupts and Exceptions</h2><p>用户空间中的第一个<code>int $0x30</code>系统调用指令是一个死胡同:一旦处理器进入用户模式，就没有办法返回。现在需要实现基本的异常和系统调用处理，以便内核能够从用户模式代码中恢复对处理器的控制。您应该做的第一件事是彻底熟悉x86中断和异常机制。</p>
<p>Read <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/c09.htm">Chapter 9, Exceptions and Interrupts</a> in the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm">80386 Programmer’s Manual</a> (or Chapter 5 of the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf">IA-32 Developer’s Manual</a>), if you haven’t already.</p>
<p>根据xv6讲义，一共有三种必须<strong>将控制由用户程序转移到内核</strong>的情形：系统调用、异常和中断。</p>
<p><strong>系统调用</strong>发生在用户程序请求一项操作系统的服务时。</p>
<p><strong>异常</strong>发生在用户程序想要执行某种非法的操作时，如除以零或者访问不存在的页表项。</p>
<p><strong>中断</strong>发生在某个外部设备需要操作系统的留意时，比如时钟芯片会定时产生一个中断提醒操作系统可以将硬件资源切换给下一个进程使用一会儿了。</p>
<p>在大多数处理器上，这三种情形都是由同一种硬件机制来处理的。对于x86，系统调用和异常本质上也是生成一个中断，因此操作系统只需要提供一套针对中断的处理策略就可以了。</p>
<p>操作系统处理中断时要用到<strong>中断描述符表IDT</strong>和<strong>程序状态段TSS</strong></p>
<ol>
<li><strong>中断描述符表IDT (interrupt descriptor table)</strong></li>
</ol>
<p>​        x86最多支持256个不同中断和异常的条目，每个包含一个中断向量，是一个0～255之间的数字，代表中断来源：不同的设备及类型错误。</p>
<p>​        IDT使得系统调用、异常和中断都只能经由被内核定义的入口进入正确的中断处理程序。每一个中断处理程序都对应一个中断向量或中断号，处理器接收中断号后，会以它作为索引值从IDT中找到对应的中断描述符。接着，处理器从描述符中取出定位中断处理程序要用到的 <strong>eip(指令指针寄存器)</strong> 和 <strong>cs(代码段寄存器)</strong> 的值。</p>
<p>EIP中的值指向内核中处理这类异常的代码。 Extend Instruction Pointer</p>
<p>CS中的最低两位表示优先级，因此寻址空间少两位 . </p>
<p>在JOS中，所有异常都在内核模式处理，优先级为0(用户模式为3)</p>
<ol start="2">
<li><strong>任务状态段 (Task State Segment, TSS)</strong></li>
</ol>
<p>​    处理器需要保存中断和异常出现时的自身状态，例如EIP和CS，以便处理完后能返回原函数继续执行。但是存储区域必须禁止用户访问，避免恶意代码或bug的破坏。</p>
<p>​    因此，当x86处理器处理从用户态到内核态的模式转换时，也会切换到内核栈。而<strong>TSS</strong>指明段选择器和栈地址，处理器将SS, ESP, EFLAGS, CS, EIP压入新栈，然后从IDT读取EIP和CS，根据新栈设置ESP和SS。</p>
<p><strong>SS是堆栈段寄存器。它指向将用于堆栈的内存的一般区域。</strong> </p>
<p><strong>ESP是堆栈指针寄存器。它指向在存储器的“堆栈段”区域内的堆栈“顶部”的任何给定点处的精确位置。</strong></p>
<p><strong>EFLAGS标志寄存器。</strong></p>
<p>JOS仅利用TSS来定义需要切换的内核栈。由于内核模式在JOS优先级是0，因此处理器用TSS的ESP0和SS0来定义内核栈，无需TSS结构体中的其他内容。其中，SS0中存储的是GD_KD</p>
<p>  <code>#define GD_KD     0x10     // kernel data</code> </p>
<p>ESP0中存储的是KSTACKTOP </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define KSTACKTOP   KERNBASE</span><br><span class="line">#define KERNBASE   0xF0000000</span><br></pre></td></tr></table></figure>



<p>在x86体系中，中断向量范围为0-255（vector number），最多表示256个异常或者中断，用一个8位的无符号整数表示，前32个vector为处理器保留用作异常处理。</p>
<p>32-255被指定为用户定义的中断，并且不由处理器保留。这些vector通常分配给外部I/O设备，以便这些设备能够向处理器发送中断。</p>
<p><strong>一个例子</strong></p>
<p>通过一个例子来理解上面的知识。假设处理器正在执行用户环境的代码，遇到了”除0”异常。</p>
<ol>
<li><p>处理器切换到内核栈，利用了上文 TSS 中的 ESP0 和 SS0。</p>
</li>
<li><p>处理器将异常参数 push 到了内核栈。一般情况下，按顺序 push <code>SS, ESP, EFLAGS, CS, EIP</code><br>+——————–+ KSTACKTOP<br>| 0x00000 | old SS | “ - 4<br>| old ESP | “ - 8<br>| old EFLAGS | “ - 12<br>| 0x00000 | old CS | “ - 16<br>| old EIP | “ - 20 &lt;—- ESP<br>+——————–+<br>存储这些寄存器状态的意义是：SS(堆栈选择器) 的低 16 位与 ESP 共同确定当前栈状态；EFLAGS(标志寄存器)存储当前FLAG；CS(代码段寄存器) 和 EIP(指令指针寄存器) 确定了当前即将执行的代码地址，E 代表”扩展”至32位。根据这些信息，就能保证处理中断结束后能够恢复到中断前的状态。</p>
</li>
<li><p>因为我们将处理一个”除0”异常，其对应中断向量是0，因此，处理器读取 IDT 的条目0，设置 <code>CS:EIP</code> 指向该条目对应的处理函数。</p>
</li>
<li><p>处理函数获得程序控制权并且处理该异常。例如，终止进程的运行。</p>
</li>
</ol>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220703163747621.png" alt="image-20220703163747621"></p>
<p>ref：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f67034d0c3f2">https://www.jianshu.com/p/f67034d0c3f2</a></p>
<p><strong>嵌套的异常和中断</strong></p>
<p>内核和用户进程都会引起异常和中断。然而，仅在从用户环境进入内核时才会切换栈。如果中断发生时已经在内核态了(此时， <code>CS</code> 寄存器的低 2bit 为 <code>00</code>) ，那么 CPU 就直接将状态压入内核栈，不再需要切换栈。这样，内核就能处理内核自身引起的”嵌套异常”，这是实现保护的重要工具。<br>如果处理器已经处于内核态，然后发生了嵌套异常，由于它并不进行栈切换，所以无须存储 <code>SS</code> 和 <code>ESP</code> 寄存器状态。对于不包含 error code 的异常，在进入处理函数前内核栈状态如下所示：</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220703163920093.png" alt="image-20220703163920093"></p>
<p>对于包含了 error code 的异常，则将 error code 继续 push 到 <code>EIP</code>之后。<br>警告：如果 CPU 处理嵌套异常的时候，无法将状态 push 到内核栈（由于栈空间不足等原因），则 CPU 无法恢复当前状态，只能重启。当然，这是内核设计中必须避免的。</p>
<p>头文件 <code>inc/trap.h</code> 和 <code>kern/trap.h</code> 包含了与中断和异常相关的定义，需要仔细阅读。其中 <code>kern/trap.h</code> 包含内核私有定义，而 <code>inc/trap.h</code> 包含对内核以及用户进程和库都有用的定义。<br>每个异常和中断都应该在 <code>trapentry.S</code> 和 <code>trap_init()</code> 有自己的处理函数，并在 IDT 中将这些处理函数的地址初始化。每个处理函数都需要在栈上新建一个 <code>struct Trapframe</code>（见 <code>inc/trap.h</code>)，以其地址为参数调用 <code>trap()</code> 函数，然后进行异常处理。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220703165253213.png" alt="image-20220703165253213"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0xf0103734 &lt;env_pop_tf+15&gt;:  iret   </span><br><span class="line">0xf0103734      486             asm volatile(</span><br><span class="line">(gdb) info registers</span><br><span class="line">eax            0x0      0</span><br><span class="line">ecx            0x0      0</span><br><span class="line">edx            0x0      0</span><br><span class="line">ebx            0x0      0</span><br><span class="line">esp            0xf0224030       0xf0224030</span><br><span class="line">ebp            0x0      0x0</span><br><span class="line">esi            0x0      0</span><br><span class="line">edi            0x0      0</span><br><span class="line">eip            0xf0103734       0xf0103734 &lt;env_pop_tf+15&gt;</span><br><span class="line">eflags         0x96     [ PF AF SF ]</span><br><span class="line">cs             0x8      8</span><br><span class="line">ss             0x10     16</span><br><span class="line">ds             0x23     35</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">es             0x23     35</span><br><span class="line">fs             0x23     35</span><br><span class="line">gs             0x23     35</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x800020:    cmp    $0xeebfe000,%esp</span><br><span class="line">0x00800020 in ?? ()</span><br><span class="line">(gdb) info registers</span><br><span class="line">eax            0x0      0</span><br><span class="line">ecx            0x0      0</span><br><span class="line">edx            0x0      0</span><br><span class="line">ebx            0x0      0</span><br><span class="line">esp            0xeebfe000       0xeebfe000</span><br><span class="line">ebp            0x0      0x0</span><br><span class="line">esi            0x0      0</span><br><span class="line">edi            0x0      0</span><br><span class="line">eip            0x800020 0x800020</span><br><span class="line">eflags         0x2      [ ]</span><br><span class="line">cs             0x1b     27</span><br><span class="line">ss             0x23     35</span><br><span class="line">ds             0x23     35</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">es             0x23     35</span><br><span class="line">fs             0x23     35</span><br><span class="line">gs             0x23     35</span><br></pre></td></tr></table></figure>

<p>可以看到<code>=&gt; 0x800020:    cmp    $0xeebfe000,%esp</code>时，进入了用户态，因为cs的值变为了<code>GD_UT | 0X3 = 0x1b</code>，esp的值为USTACKTOP的值<code>0xeebfe000</code></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704103409165.png" alt="image-20220704103409165"></p>
<h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a>Exercise 4.</h2><p><strong>Exercise 4.</strong> Edit <code>trapentry.S</code> and <code>trap.c</code> and implement the features described above. The macros <code>TRAPHANDLER</code> and <code>TRAPHANDLER_NOEC</code> in <code>trapentry.S</code> should help you, as well as the T_* defines in <code>inc/trap.h</code>. You will need to add an entry point in <code>trapentry.S</code> (using those macros) for each trap defined in <code>inc/trap.h</code>, and you’ll have to provide <code>_alltraps</code> which the <code>TRAPHANDLER</code> macros refer to. You will also need to modify <code>trap_init()</code> to initialize the <code>idt</code> to point to each of these entry points defined in <code>trapentry.S</code>; the <code>SETGATE</code> macro will be helpful here.</p>
<p>Your <code>_alltraps</code> should:</p>
<ol>
<li>push values to make the stack look like a struct Trapframe</li>
<li>load <code>GD_KD</code> into <code>%ds</code> and <code>%es</code></li>
<li><code>pushl %esp</code> to pass a pointer to the Trapframe as an argument to trap()</li>
<li><code>call trap</code> (can <code>trap</code> ever return?)</li>
</ol>
<p>Consider using the <code>pushal</code> instruction; it fits nicely with the layout of the <code>struct Trapframe</code>.</p>
<p>Test your trap handling code using some of the test programs in the <code>user</code> directory that cause exceptions before making any system calls, such as <code>user/divzero</code>. You should be able to get make grade to succeed on the <code>divzero</code>, <code>softint</code>, and <code>badsegment</code> tests at this point.</p>
<p>查看<code>trapentry.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="line"> * It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="line"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="line"> *</span><br><span class="line"> * You shouldn&#x27;t call a TRAPHANDLER function from C, but you may</span><br><span class="line"> * need to _declare_ one in C (for instance, to get a function pointer</span><br><span class="line"> * during IDT setup).  You can declare the function with</span><br><span class="line"> *   void NAME();</span><br><span class="line"> * where NAME is the argument passed to TRAPHANDLER.</span><br><span class="line"> */</span><br><span class="line">#define TRAPHANDLER(name, num)                \</span><br><span class="line">   .globl name;      /* define global symbol for &#x27;name&#x27; */  \</span><br><span class="line">   .type name, @function; /* symbol type is function */     \</span><br><span class="line">   .align 2;     /* align function definition */       \</span><br><span class="line">   name:        /* function starts here */    \</span><br><span class="line">   pushl $(num);                    \</span><br><span class="line">   jmp _alltraps</span><br></pre></td></tr></table></figure>

<p>.global  定义了全局符号。</p>
<p>​       汇编函数如果需要在其他文件内调用，需要把函数声明为全局，此时就会使用.global这个伪操作。</p>
<p>.type  用来制定一个符号类型是函数类型或者是对象类型，对象类型一般是数据</p>
<p>​        <code>.type symbol, @object</code></p>
<p>​        <code>.type symbol, @function</code></p>
<p>.align  用来指定内存对齐方式</p>
<p>​        <code>.align size</code></p>
<p>​        表示按size字节对齐内存</p>
<p>这一步做了什么？光看这里很难理解，提示说是构造一个 <code>Trapframe</code> 结构体来保存现场，但是这里怎么直接就 push 中断向量了？实际上，在上文已经指出， cpu 自身会先 push 一部分寄存器（见例子所述），而其他则由用户和操作系统决定。由于中断向量是操作系统定义的，所以从这部分开始就已经不属于 cpu 的工作范畴了。</p>
<p>在 <code>trapentry.S</code> 中：</p>
<p>根据inc/trap.h 绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="line">// It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="line"></span><br><span class="line">// Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="line">// Use TRAPHANDLER_NOEC for traps where the CPU doesn&#x27;t push an error code.</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="line"> */</span><br><span class="line">// 绑定异常到自定义处理器</span><br><span class="line">TRAPHANDLER_NOEC(handler0, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(handler1, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(handler2, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(handler3, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(handler4, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(handler5, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(handler6, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(handler7, T_DEVICE)</span><br><span class="line">TRAPHANDLER(handler8, T_DBLFLT)</span><br><span class="line">// 9 deprecated since 386</span><br><span class="line">TRAPHANDLER(handler10, T_TSS)</span><br><span class="line">TRAPHANDLER(handler11, T_SEGNP)</span><br><span class="line">TRAPHANDLER(handler12, T_STACK)</span><br><span class="line">TRAPHANDLER(handler13, T_GPFLT)</span><br><span class="line">TRAPHANDLER(handler14, T_PGFLT)</span><br><span class="line">// 15 reserved by intel</span><br><span class="line">TRAPHANDLER_NOEC(handler16, T_FPERR)</span><br><span class="line">TRAPHANDLER(handler17, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(handler18, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(handler19, T_SIMDERR)</span><br><span class="line">// system call (interrupt)</span><br><span class="line">TRAPHANDLER_NOEC(handler48, T_SYSCALL)</span><br><span class="line"></span><br><span class="line">// 该函数是全局的，但是在 C 文件中使用的时候需要使用 void name(); 再声明一下。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 你不应该从C调用TRAPHANDLER函数，但你可能需要在C中_declare_(例如，在IDT设置期间获得一个函数指针)。您可以使用声明函数</span><br><span class="line">    void NAME();</span><br><span class="line">    其中NAME是传递给TRAPHANDLER的参数。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for _alltraps</span><br><span class="line"> */</span><br><span class="line">_alltraps:</span><br><span class="line">pushl %es</span><br><span class="line">pushl %ds</span><br><span class="line">pushal</span><br><span class="line"></span><br><span class="line">movw $GD_KD, %ax</span><br><span class="line">movw %ax, %ds</span><br><span class="line">movw %ax, %es</span><br><span class="line"></span><br><span class="line">pushl %esp</span><br><span class="line">call trap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 不能用立即数直接给段寄存器赋值。因此不能直接写movw $GD_KD, %ds。</span><br></pre></td></tr></table></figure>



<p><strong>SETGATE MACRO</strong></p>
<p>Set up a normal interrupt/trap gate descriptor.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up a normal interrupt/trap gate descriptor.</span></span><br><span class="line"><span class="comment">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span></span><br><span class="line">    <span class="comment">//   see section 9.6.1.3 of the i386 reference: &quot;The difference between</span></span><br><span class="line">    <span class="comment">//   an interrupt gate and a trap gate is in the effect on IF (the</span></span><br><span class="line">    <span class="comment">//   interrupt-enable flag). An interrupt that vectors through an</span></span><br><span class="line">    <span class="comment">//   interrupt gate resets IF, thereby preventing other interrupts from</span></span><br><span class="line">    <span class="comment">//   interfering with the current interrupt handler. A subsequent IRET</span></span><br><span class="line">    <span class="comment">//   instruction restores IF to the value in the EFLAGS image on the</span></span><br><span class="line">    <span class="comment">//   stack. An interrupt through a trap gate does not change IF.&quot;</span></span><br><span class="line"><span class="comment">// - sel: 代码段选择器 for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - off: 代码段的偏移量 for interrupt/trap handler</span></span><br><span class="line"><span class="comment">// - dpl: Descriptor Privilege Level -</span></span><br><span class="line"><span class="comment">//   the privilege level required for software to invoke</span></span><br><span class="line"><span class="comment">//   this interrupt/trap gate explicitly using an int instruction.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gate</span></span><br><span class="line"><span class="comment">这是一个 struct Gatedesc。</span></span><br><span class="line"><span class="comment">istrap</span></span><br><span class="line"><span class="comment">该中断是 trap(exception) 则为1，是 interrupt 则为0。</span></span><br><span class="line"><span class="comment">sel</span></span><br><span class="line"><span class="comment">代码段选择器。进入内核的话是 GD_KT。</span></span><br><span class="line"><span class="comment">off</span></span><br><span class="line"><span class="comment">相对于段的偏移，简单来说就是函数地址。</span></span><br><span class="line"><span class="comment">dpl(Descriptor Privileged Level)</span></span><br><span class="line"><span class="comment">权限描述符。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)         \</span></span><br><span class="line"><span class="meta">&#123;                       \</span></span><br><span class="line"><span class="meta">   (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff;       \</span></span><br><span class="line"><span class="meta">   (gate).gd_sel = (sel);             \</span></span><br><span class="line"><span class="meta">   (gate).gd_args = 0;                \</span></span><br><span class="line"><span class="meta">   (gate).gd_rsv1 = 0;                \</span></span><br><span class="line"><span class="meta">   (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;   \</span></span><br><span class="line"><span class="meta">   (gate).gd_s = 0;               \</span></span><br><span class="line"><span class="meta">   (gate).gd_dpl = (dpl);             \</span></span><br><span class="line"><span class="meta">   (gate).gd_p = 1;               \</span></span><br><span class="line"><span class="meta">   (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16;     \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p><em>Challenge!</em> You probably have a lot of very similar code right now, between the lists of <code>TRAPHANDLER</code> in <code>trapentry.S</code> and their installations in <code>trap.c</code>. Clean this up. Change the macros in <code>trapentry.S</code> to <strong>automatically generate a table</strong> for <code>trap.c</code> to use. Note that you can switch between laying down code and data in the assembler by using the directives <code>.text</code> and <code>.data</code>.</p>
<p><strong>Questions</strong></p>
<p>Answer the following questions in your <code>answers-lab3.txt</code>:</p>
<ol>
<li><p>What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)</p>
<p>为每个异常/中断提供单独的处理函数的目的是什么?(也就是说，如果所有异常/中断都被交付给同一个处理程序，当前实现中存在的哪些特性不能提供?)</p>
<p>答：因为每个异常和中断的处理方式不同，例如除0异常不会继续返回程序执行，而I/O操作中断后会继续返回程序处理。一个handler难以处理多种情况。</p>
</li>
<li><p>Did you have to do anything to make the <code>user/softint</code> program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but <code>softint</code>‘s code says <code>int $14</code>. <em>Why</em> should this produce interrupt vector 13? What happens if the kernel actually allows <code>softint</code>‘s <code>int $14</code>instruction to invoke the kernel’s page fault handler (which is interrupt vector 14)?</p>
</li>
</ol>
<h1 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h1><h2 id="Exercise5-Handling-Page-Faults"><a href="#Exercise5-Handling-Page-Faults" class="headerlink" title="Exercise5: Handling Page Faults"></a>Exercise5: Handling Page Faults</h2><p>缺页错误异常，中断向量 14 (<code>T_PGFLT</code>)，是一个非常重要的异常类型，lab3 以及 lab4 都强烈依赖于这个异常处理。当程序遇到缺页异常时，它将引起异常的虚拟地址存入 <code>CR2</code> 控制寄存器( control register)。在 <code>trap.c</code> 中，我们已经提供了<code>page_fault_handler()</code> 函数用来处理缺页异常。</p>
<p>修改trap_dispatch()，将页面故障异常分派到page_fault_handler()。现在，您应该能够在faultread、faultreadkernel、faultwrite和faultwritekernel测试中获得成功。如果其中任何一个不工作，找出原因并解决它们。记住，您可以使用make run-x或make run-x-nox将JOS引导到特定的用户程序中。例如，make run-hello-nox运行hello用户程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Handle processor exceptions.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">switch</span>(tf-&gt;tf_trapno)&#123;</span><br><span class="line">        <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">            page_fault_handler();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">                panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                env_destroy(curenv);  <span class="comment">// 销毁</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Exercise-6-The-Breakpoint-Exception"><a href="#Exercise-6-The-Breakpoint-Exception" class="headerlink" title="Exercise 6: The Breakpoint Exception"></a>Exercise 6: The Breakpoint Exception</h2><p>断点异常，中断向量 3 (<code>T_BRKPT</code>) 允许调试器给程序加上断点。原理是暂时把程序中的某个指令替换为一个 1 字节大小的 <code>int3</code>软件中断指令。在 JOS 中，我们将它实现为一个伪系统调用。这样，任何程序（不限于调试器）都能使用断点功能。</p>
<p>Modify <code>trap_dispatch()</code> to make breakpoint exceptions invoke the kernel monitor. You should now be able to get make grade to succeed on the <code>breakpoint</code> test.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct Trapframe *tf)</span>    <span class="comment">// dispatch 调度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Handle processor exceptions.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">switch</span>(tf-&gt;tf_trapno)&#123;</span><br><span class="line">        <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">            page_fault_handler(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_BRKPT:</span><br><span class="line">            monitor(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">                panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                env_destroy(curenv);  <span class="comment">// 销毁</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em>Challenge!</em> Modify the JOS kernel monitor so that you can ‘continue’ execution from the current location (e.g., after the <code>int3</code>, if the kernel monitor was invoked via the breakpoint exception), and so that you can single-step one instruction at a time. You will need to understand certain bits of the <code>EFLAGS</code> register in order to implement single-stepping.</p>
<p><em>Optional:</em> If you’re feeling really adventurous, find some x86 disassembler source code - e.g., by ripping it out of QEMU, or out of GNU binutils, or just write it yourself - and extend the JOS kernel monitor to be able to disassemble and display instructions as you are stepping through them. Combined with the symbol table loading from lab 1, this is the stuff of which real kernel debuggers are made.</p>
<p><strong>Questions</strong></p>
<ol>
<li><p>The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to <code>SETGATE</code> from <code>trap_init</code>). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?</p>
<p>断点测试用例将生成断点异常或一般保护故障，这取决于您在IDT中初始化断点条目的方式(即，从trap_init调用SETGATE)。为什么?您需要如何设置它才能使断点异常像上面指定的那样工作?哪些不正确的设置会导致它触发一般的保护故障?</p>
<p><strong>答：</strong>权限问题。特权级别是个很重要的点。每个IDT的entries内的中断描述符都为中断处理程序设定了一个DPL(Descriptor Privilege Level)。用户程序的特权级别是3，内核的特权级别是0(可知<strong>0级别更高</strong>)。如果用户产生的中断/异常需要级别0，那么用户就无权请内核调用这个处理程序，就会产生一个general protection fault，如果是内核发生中断/异常的话，特权级别总是够的</p>
<p><code>SETGATE(idt[T_BRKPT], 1, GD_KT, brkpt_handler, 3);</code>中如果最后一个参数dpl设为3就会产生一个breakpoint exception，如果设为0就会产生一个general protection fault。这也是由于特权级别影响的。breakpoint test程序的特权级别是3，如果断点异常处理程序特权设为3那就可以是断点异常，如果设为0就产生保护错误。</p>
</li>
<li><p>What do you think is the point of these mechanisms, particularly in light of what the <code>user/softint</code> test program does?</p>
<p>里面是这条代码<code>asm volatile(&quot;int $14&quot;);</code>本来想中断调用页面错误处理，结果因为特权级别不够而产生一个保护异常，所以重点应该是要分清特权级别吧。要区分<code>$14</code> 与 <code>$0x30</code>。</p>
<p>优先级别低的代码无法访问优先级高的代码，优先级高低由gd_dpl判断。数字越小越高。</p>
</li>
</ol>
<h2 id="Exercise-7-System-calls"><a href="#Exercise-7-System-calls" class="headerlink" title="Exercise 7: System calls"></a>Exercise 7: System calls</h2><p>用户进程通过调用系统调用请求内核为它们做一些事情。当用户进程调用一个系统调用时，处理器进入内核模式，处理器和内核合作保存用户进程的状态，内核执行相应的代码来执行系统调用，然后恢复用户进程。用户进程如何获得内核的注意，以及用户进程如何指定要执行的调用，这些具体细节在不同的系统中有所不同。</p>
<p>在JOS内核中，我们将使用int指令，它会导致处理器中断。特别地，我们将使用int $0x30作为系统调用中断。我们已经为您定义了常量T_SYSCALL到48 (0x30)。您必须设置中断描述符，以允许用户进程引起中断。注意，中断0x30不能由硬件生成，所以不会因为允许用户代码生成它而产生歧义。</p>
<p>应用程序将在寄存器中传递系统调用号和系统调用参数。这样，内核就不需要在用户环境的堆栈或指令流中到处寻找了。系统调用号将进入%eax，参数(最多5个)将分别进入%edx、%ecx、%ebx、%edi和%esi。内核将返回值返回到%eax中。调用系统调用的汇编代码已经为您编写，在lib/syscall.c中的syscall()中。你应该通读一遍，确保你明白发生了什么.</p>
<p>exercise: 在内核中为中断向量T_SYSCALL添加一个处理程序。你必须编辑kern/trapentry。S和kern/trap.c的trap_init()。您还需要更改trap_dispatch()来处理系统调用中断，方法是使用适当的参数调用sycall(在kern/syscall.c中定义)，然后将返回值传递回%eax中的用户进程。最后，你需要在kern/syscall.c中实现syscall()。确保如果系统调用号无效，syscall()返回-E_INVAL。您应该阅读并理解lib/syscall.c(特别是内联汇编例程)，以确认您对系统调用接口的理解。通过为每个调用调用相应的内核函数来处理inc/syscall.h中列出的所有系统调用。</p>
<p>Run the user/hello program under your kernel (make run-hello). It should print “hello, world” on the console and then cause a page fault in user mode. If this does not happen, it probably means your system call handler isn’t quite right. You should also now be able to get make grade to succeed on the testbss test.</p>
<p><strong>inc/syscall.h</strong></p>
<p>定义了系统调用号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JOS_INC_SYSCALL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JOS_INC_SYSCALL_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* system call numbers */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   SYS_cputs = <span class="number">0</span>,</span><br><span class="line">   SYS_cgetc,</span><br><span class="line">   SYS_getenvid,</span><br><span class="line">   SYS_env_destroy,</span><br><span class="line">   NSYSCALLS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !JOS_INC_SYSCALL_H */</span></span></span><br></pre></td></tr></table></figure>



<p>lib/syscall.c</p>
<p>这是系统调用的通用模板，不同的系统调用都会以不同参数调用syscall函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call stubs.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int32_t</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> check, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int32_t</span> ret;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Generic system call: 在AX中传递系统呼叫号，在DX、CX、BX、DI、SI中最多传递5个参数。</span></span><br><span class="line">   <span class="comment">// 使用t_sycall中断内核。</span></span><br><span class="line">	 <span class="comment">// “volatile”告诉汇编器不要因为没有使用返回值而对该指令进行优化。</span></span><br><span class="line">	 <span class="comment">// 最后一个子句告诉汇编器，这可能会改变条件代码和任意内存位置。</span></span><br><span class="line">   <span class="comment">// 可以看到，该段汇编的output为 ret</span></span><br><span class="line">   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;int %1\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">           : <span class="string">&quot;=a&quot;</span> (ret)</span></span></span><br><span class="line"><span class="params"><span class="function">           : <span class="string">&quot;i&quot;</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;a&quot;</span> (num),    </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;d&quot;</span> (a1),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;c&quot;</span> (a2),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;b&quot;</span> (a3),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;D&quot;</span> (a4),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;S&quot;</span> (a5)</span></span></span><br><span class="line"><span class="params"><span class="function">           : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(check &amp;&amp; ret &gt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;syscall %d returned %d (&gt; 0)&quot;</span>, num, ret);</span><br><span class="line">		<span class="comment">// 函数的返回为ret</span></span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sys_cputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   syscall(SYS_cputs, <span class="number">0</span>, (<span class="keyword">uint32_t</span>)s, len, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_cgetc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> syscall(SYS_cgetc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_env_destroy</span><span class="params">(<span class="keyword">envid_t</span> envid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> syscall(SYS_env_destroy, <span class="number">1</span>, envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">envid_t</span></span></span><br><span class="line"><span class="function"><span class="title">sys_getenvid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_getenvid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>补充知识：GCC内联汇编</strong><br>其语法固定为：<br><code>asm volatile (“asm code”：output：input：changed);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;int %1\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">         : <span class="string">&quot;=a&quot;</span> (ret)</span></span></span><br><span class="line"><span class="params"><span class="function">         : <span class="string">&quot;i&quot;</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;a&quot;</span> (num),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;d&quot;</span> (a1),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;c&quot;</span> (a2),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;b&quot;</span> (a3),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;D&quot;</span> (a4),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;S&quot;</span> (a5)</span></span></span><br><span class="line"><span class="params"><span class="function">         : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">限定符</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“m”、”v”、”o”</td>
<td align="center">内存单元</td>
</tr>
<tr>
<td align="center">“r”</td>
<td align="center">任何寄存器</td>
</tr>
<tr>
<td align="center">“q”</td>
<td align="center">寄存器eax、ebx、ecx、edx之一</td>
</tr>
<tr>
<td align="center">“i”、”h”</td>
<td align="center">直接操作数</td>
</tr>
<tr>
<td align="center">“E”、”F”</td>
<td align="center">浮点数</td>
</tr>
<tr>
<td align="center">“g”</td>
<td align="center">任意</td>
</tr>
<tr>
<td align="center">“a”、”b”、”c”、”d”</td>
<td align="center">分别表示寄存器eax、ebx、ecx和edx</td>
</tr>
<tr>
<td align="center">“S”、”D”</td>
<td align="center">寄存器esi、edi</td>
</tr>
<tr>
<td align="center">“I”</td>
<td align="center">常数 (0至31)</td>
</tr>
</tbody></table>
<p>除了这些约束之外, 输出值还包含一个约束修饰符:</p>
<table>
<thead>
<tr>
<th align="center">输出修饰符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">可以读取和写入操作数</td>
</tr>
<tr>
<td align="center">=</td>
<td align="center">只能写入操作数</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">如果有必要操作数可以和下一个操作数切换</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">在内联函数完成之前, 可以删除和重新使用操作数</td>
</tr>
</tbody></table>
<p>根据表格内容，可以看出该内联汇编作用就是引发一个<code>int</code>中断，中断向量为立即数 <code>T_SYSCALL</code>，同时，对寄存器进行操作。看懂这，就清楚了，这一部分应该不需要我们改动，因为我们处理的是中断已经产生后的部分。<strong>当然，还有另一种更简单的思路，</strong><code>inc/</code> <strong>目录下的，其实都是操作系统留给用户的接口</strong>，所以才会在里面看到 <code>stdio.h</code>，<code>assert.h</code> 等文件。那么，要进行系统调用肯定也是先调用 <code>inc/</code> 中的那个，具体处理应该是在 <code>kern/</code> 中实现。</p>
<p>ref：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f67034d0c3f2">https://www.jianshu.com/p/f67034d0c3f2</a></p>
<p><strong>kern/trap.c</strong></p>
<p>trap_init()添加</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704144047847.png" alt="image-20220704144047847" style="zoom: 50%;" />

<p>权限更改为3，以便用户进程可以触发该中断</p>
<p>修改<strong>trap_dispatch()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">    tf-tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_edx,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_edi,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_esi);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p><strong>kern/syscall.c</strong></p>
<p>我们在 <code>kern/trap.c</code> 中调用的实际上就是这里的 syscall 函数，而不是 <code>lib/syscall.c</code> 中的那个。想明白这一点，设置参数也就很简单了，注意返回值的处理。</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704154830887.png" alt="image-20220704154830887" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line">   <span class="comment">// Return any appropriate return value.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//panic(&quot;syscall not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">        <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">            sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, a2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">            retVal = sys_cgetc();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">            retVal = sys_getenvid()&gt;=<span class="number">0</span>;  <span class="comment">// // Returns the current environment&#x27;s envid.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">            retVal = sys_env_destroy(a1);  <span class="comment">// env_id</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>make grade</code> 可以通过 testbss，运行 <code>make run-hello</code> 可以打印出 <code>hello world</code>，紧接着提示了页错误。</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704163653390.png" alt="image-20220704163653390" style="zoom:50%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704163812230.png" alt="image-20220704163812230" style="zoom:50%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704163804732.png" alt="image-20220704163804732" style="zoom:50%;" />

<p>通过 exercise 7，可以看出 JOS系 统调用的步骤为：</p>
<ol>
<li>用户进程使用 <code>inc/</code> 目录下暴露的接口</li>
<li><code>lib/syscall.c</code> 中的函数将系统调用号及必要参数传给寄存器，并引起一次 <code>int $0x30</code> 中断</li>
<li><code>kern/trap.c</code> 捕捉到这个中断，并将 TrapFrame 记录的寄存器状态作为参数，调用处理中断的函数</li>
<li><code>kern/syscall.c</code> 处理中断</li>
</ol>
<h2 id="Exercise-8-User-mode-startup"><a href="#Exercise-8-User-mode-startup" class="headerlink" title="Exercise 8: User-mode startup"></a>Exercise 8: User-mode startup</h2><p>一个用户程序开始运行在<code>lib/entry.S</code>的顶部。在一些设置之后，这段代码调用<code>lib/libmain.c中</code>的<code>libmain()</code>。你应该修改<code>libmain()</code>来初始化全局指针<code>thisenv</code>，使其指向envs[]数组中的环境结构体Env。(Note that <code>lib/entry.S</code> has already defined <code>envs</code> to point at the <code>UENVS</code> mapping you set up in Part A.) </p>
<p>Hint: look in <code>inc/env.h</code> and use <code>sys_getenvid</code>.</p>
<p><code>libmain()</code> then calls umain, which, in the case of the hello program, is in <code>user/hello.c</code>. Note that after printing “hello, world”, it tries to access <code>thisenv-&gt;env_id.</code> This is why it faulted earlier.</p>
<p>Now that you’ve initialized <code>thisenv</code> properly, it should not fault. If it still faults, you probably haven’t mapped the <code>UENVS</code> area user-readable (back in Part A in <code>pmap.c</code>; this is the first time we’ve actually used the <code>UENVS</code> area).</p>
<p>Add the required code to the user library, then boot your kernel. You should see <code>user/hello</code> print “<code>hello, world</code>“ and then print “<code>i am environment 00001000</code>“. <code>user/hello</code> then attempts to “exit” by calling <code>sys_env_destroy()</code> (see <code>lib/libmain.c</code> and <code>lib/exit.c</code>). Since the kernel currently only supports one user environment, it should report that it has destroyed the only environment and then drop into the kernel monitor. You should be able to get make grade to succeed on the <code>hello</code> test.</p>
<p><strong>umain.c</strong></p>
<p>user/hello.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">umain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cprintf(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">   cprintf(<span class="string">&quot;i am environment %08x\n&quot;</span>, thisenv-&gt;env_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">libmain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// set thisenv to point at our Env structure in envs[].</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">   thisenv = &amp;envs[ENVX(sys_getenvid())];  <span class="comment">// &amp;envs[ENVX(envid)]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// save the name of the program so that panic() can use it</span></span><br><span class="line">   <span class="keyword">if</span> (argc &gt; <span class="number">0</span>)</span><br><span class="line">      binaryname = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// call user main routine</span></span><br><span class="line">   umain(argc, argv);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// exit gracefully</span></span><br><span class="line">   <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704172003993.png" alt="image-20220704172003993"></p>
<p>hello 完成</p>
<h2 id="Exercise-9-Page-faults-and-memory-protection"><a href="#Exercise-9-Page-faults-and-memory-protection" class="headerlink" title="Exercise 9: Page faults and memory protection"></a>Exercise 9: Page faults and memory protection</h2><p>内存保护是操作系统的关键功能，它确保了一个程序中的错误不会导致其他程序或是操作系统自身的崩溃。<br>操作系统通常依赖硬件的支持来实现内存保护。操作系统会告诉硬件哪些虚拟地址可用哪些不可用。当某个程序想访问不可用的内存地址或不具备权限时，处理器将在出错指令处停止程序，然后陷入内核。如果错误可以处理，内核就处理并恢复程序运行，否则无法恢复。<br>作为可以修复的错误，设想某个自动生长的栈。在许多系统中内核首先分配一个页面给栈，如果某个程序访问了页面外的空间，内核会自动分配更多页面以让程序继续。这样，内核只用分配程序需要的栈内存给它，然而程序感觉仿佛可以拥有任意大的栈内存。<br>系统调用也为内存保护带来了有趣的问题。许多系统调用接口允许用户传递指针给内核，这些指针指向待读写的用户缓冲区。内核处理系统调用的时候会对这些指针解引用。这样就带来了两个问题：</p>
<ol>
<li>内核的页错误通常比用户进程的页错误严重得多，如果内核在操作自己的数据结构时发生页错误，这就是一个内核bug，会引起系统崩溃。<strong>因此，内核需要记住这个错误是来自用户进程。</strong></li>
<li>内核比用户进程拥有更高的内存权限，<strong>用户进程给内核传递的指针可能指向一个只有内核能够读写的区域，内核必须谨慎避免解引用这类指针</strong>，因为这样可能导致内核的私有信息泄露或破坏内核完整性。</li>
</ol>
<p>我们将<strong>对用户进程传给内核的指针做一个检查来解决这两个问题</strong>。内核将检查指针指向的是内存中用户空间部分，页表也允许内存操作。</p>
<p>Change <code>kern/trap.c</code> to <strong>panic</strong> if a page fault happens <strong>in kernel mode</strong>.</p>
<p><strong>Hint:</strong> to determine whether a fault happened in user mode or in kernel mode, check the <strong>low bits</strong> of the <code>tf_cs</code>. (<strong>tf_cs是0x18还是0x1b， 0x18｜0x03 = 0x1b此时是用户模式，0x18是内核模式，检查&amp;3后的低2位</strong>)</p>
<p>Read <code>user_mem_assert</code> in <code>kern/pmap.c</code> and implement <code>user_mem_check</code> in that same file.</p>
<p>Change <code>kern/syscall.c</code> to sanity check arguments to system calls.</p>
<p>Boot your kernel, running <code>user/buggyhello</code>. The environment should be destroyed, and the kernel should <em>not</em> panic. You should see:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[00001000] user_mem_check assertion failure for va 00000001</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Destroyed the only environment - nothing more to do!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Finally, change <code>debuginfo_eip</code> in <code>kern/kdebug.c</code> to call <code>user_mem_check</code> on <code>usd</code>, <code>stabs</code>, and <code>stabstr</code>. If you now run <code>user/breakpoint</code>, you should be able to run <code>backtrace</code> from the kernel monitor and see the backtrace traverse into <code>lib/libmain.c</code> before the kernel panics with a page fault. What causes this page fault? You don’t need to fix it, but you should understand why it happens.</p>
<p><strong>kern/trap.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_fault_handler</span><span class="params">(struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">   fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span>(!(tf-&gt;tf_cs &amp; <span class="number">3</span>))&#123;</span><br><span class="line">        panic(<span class="string">&quot;page fault in kernel mode.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">   <span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">   cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">      curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">   print_trapframe(tf);</span><br><span class="line">   env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>kern/pmap.c</strong></p>
<p>user_mem_check</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查一个环境是否允许访问权限为&#x27;perm | PTE_P&#x27;的内存范围[va, va+len]。</span></span><br><span class="line"><span class="comment">// 通常&#x27;perm&#x27;至少包含PTE_U，但这不是必需的。&#x27;va&#x27;和&#x27;len&#x27;不需要按页面对齐;必须测试包含任何该范围的每个页面。</span></span><br><span class="line"><span class="comment">// 你可以测试&#x27;len/PGSIZE&#x27;， &#x27;len/PGSIZE + 1&#x27;，或者&#x27;len/PGSIZE + 2&#x27;页面。</span></span><br><span class="line"><span class="comment">// 用户程序可以访问一个虚拟地址，如果</span></span><br><span class="line"><span class="comment">// (1)该地址在ULIM之下</span></span><br><span class="line"><span class="comment">// (2)页表给了它权限。这些正是您应该在这里实现的测试。</span></span><br><span class="line"><span class="comment">// 这些正是您应该在这里实现的测试。</span></span><br><span class="line"><span class="comment">// 如果有错误，设置&#x27;user_mem_check_addr&#x27;变量为第一个错误的虚拟地址。</span></span><br><span class="line"><span class="comment">// 如果用户程序可以访问这个地址范围，返回0，否则返回-E_FAULT。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">user_mem_check</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// 内存范围[va, va+len]</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> start_va = ROUNDDOWN((<span class="keyword">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = ROUNDUP((<span class="keyword">uintptr_t</span>)va + len, PGSIZE);</span><br><span class="line">    <span class="comment">// 访问内存，通过页表，那么直接看page table entry</span></span><br><span class="line">    <span class="comment">// 遍历查看是否有权限</span></span><br><span class="line">    <span class="comment">// pgdir_walk returns a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line">    <span class="comment">// pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)</span></span><br><span class="line">    <span class="keyword">for</span>((<span class="keyword">uintptr_t</span>)cur_va = start_va;cur_va&lt;end_va;cur_va+=PGSIZE)&#123;</span><br><span class="line">        <span class="comment">// env-&gt;env_pgdir 取进程对应的页表</span></span><br><span class="line">        <span class="keyword">pte_t</span>* cur_pte = pgdir_walk(env-&gt;env_pgdir, (<span class="keyword">void</span>*)cur_va, <span class="number">0</span>);  <span class="comment">// 只查询不建立</span></span><br><span class="line">        <span class="keyword">if</span>(cur_pte == <span class="literal">NULL</span> || (*cur_pte &amp; (perm | PTE_P))!=(perm | PTE_P) || cur_va&gt;=ULIM)&#123;  <span class="comment">// 不满足要求</span></span><br><span class="line">            <span class="keyword">if</span>(cur_va == start_va)&#123;  <span class="comment">// 因为va做了近似，所以第一个页面地址要做处理</span></span><br><span class="line">                user_mem_check_addr = va;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                user_mem_check_addr = cur_va;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 程序不能访问这个地址，返回-E_FAULT</span></span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以访问</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704223729337.png" alt="image-20220704223729337" style="zoom:50%;" />

<p>不能写为cur_va&lt;=end_va。会内存越界</p>
<p>user_mem_assert</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Checks that environment &#x27;env&#x27; is allowed to access the range</span></span><br><span class="line"><span class="comment">// of memory [va, va+len) with permissions &#x27;perm | PTE_U | PTE_P&#x27;.</span></span><br><span class="line"><span class="comment">// If it can, then the function simply returns.</span></span><br><span class="line"><span class="comment">// If it cannot, &#x27;env&#x27; is destroyed and, if env is the current</span></span><br><span class="line"><span class="comment">// environment, this function will not return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">user_mem_assert</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (user_mem_check(env, va, len, perm | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      cprintf(<span class="string">&quot;[%08x] user_mem_check assertion failure for &quot;</span></span><br><span class="line">         <span class="string">&quot;va %08x\n&quot;</span>, env-&gt;env_id, user_mem_check_addr);</span><br><span class="line">      env_destroy(env);  <span class="comment">// may not return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了user_mem_check()，不满足则摧毁页面</p>
<p>运行 <code>make run-buggyhello-nox</code></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704213103991.png" alt="image-20220704213103991"></p>
<pre><code>[00001000] user_mem_check assertion failure for va 00000001
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!
</code></pre>
<p>最后，change <code>debuginfo_eip</code> in <code>kern/kdebug.c</code> to call <code>user_mem_check</code> on <code>usd</code>, <code>stabs</code>, and <code>stabstr</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">      <span class="comment">// 就是查看能否访问 UserStabData</span></span><br><span class="line">      <span class="comment">// int user_mem_check(struct Env *env, const void *va, size_t len, int perm)</span></span><br><span class="line">      <span class="keyword">if</span>(user_mem_check(curenv, (<span class="keyword">void</span>*) usd, <span class="keyword">sizeof</span>(struct UserStabData), PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">stabs = usd-&gt;stabs;</span><br><span class="line">stab_end = usd-&gt;stab_end;</span><br><span class="line">stabstr = usd-&gt;stabstr;</span><br><span class="line">stabstr_end = usd-&gt;stabstr_end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure the STABS and string table memory is valid.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">      <span class="keyword">if</span>(user_mem_check(curenv, (<span class="keyword">void</span>*) stabs, stab_end - stabs, PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(user_mem_check(curenv, (<span class="keyword">void</span>*) stabstr, stabstr_end - stabstr, PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><code>make run-breakpoint-nox</code> 然后 使用 <code>backtrace</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">K&gt; backtrace</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp efffff10  eip f0100a39  args <span class="number">00000001</span> efffff28 f0226000 <span class="number">00000000</span> f01e4a40</span><br><span class="line">    kern/monitor.c:<span class="number">222</span>: monitor+<span class="number">260</span></span><br><span class="line">  ebp efffff80  eip f0103f80  args f0226000 efffffbc <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">    kern/trap.c:<span class="number">200</span>: trap+<span class="number">187</span></span><br><span class="line">  ebp efffffb0  eip f010409d  args efffffbc <span class="number">00000000</span> <span class="number">00000000</span> eebfdfd0 efffffdc</span><br><span class="line">    kern/trapentry.S:<span class="number">93</span>: &lt;unknown&gt;+<span class="number">0</span></span><br><span class="line">  ebp eebfdfd0  eip <span class="number">0080007b</span>  args <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">    lib/libmain.c:<span class="number">26</span>: libmain+<span class="number">63</span></span><br><span class="line">Incoming TRAP frame at <span class="number">0xeffffe8c</span></span><br><span class="line">kernel panic at kern/trap.c:<span class="number">272</span>: page fault in kernel mode.</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> a <span class="built_in">list</span> of commands.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到遍历到了：<code>lib/libmain.c:26: libmain+63</code></p>
<p>ebp(基址指针寄存器)寄存器的内容，efffff10，efffff80，efffffb0都位于内核栈，eebfdfd0位于用户栈。</p>
<p>输入<code>make run-breakpoint-nox-gdb       make gdb</code></p>
<p>把断点打在 monitor()函数处(kern/monitor.c)</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704220321417.png" alt="image-20220704220321417"></p>
<p>查看ebp的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用者ebp   返回地址eip  参数1  参数2</span><br><span class="line">参数3       参数4        参数5  ...</span><br></pre></td></tr></table></figure>

<p>在查看0xeebfdfd0到用户栈栈顶0xeebfdff0的内容</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704221209942.png" alt="image-20220704221209942"></p>
<p>试图越界访问，可得到</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704221230450.png" alt="image-20220704221230450"></p>
<p>可以看到，最后就只剩了12个字符</p>
<p>这一次，backtrace的打印内容为</p>
<p><code>ebp eebfdfd0  eip 0080007b  args 00000000 00000000 00000000 00000000 00000000</code></p>
<p>那么下一次为</p>
<p><code>ebp eebfdff0  eip 00800031  args 00000000 00000000 之后的三个参数全部超过内存访问界限了</code></p>
<p>现在修改backtrace的函数，输出两个args，backtrace位于kern/monitor.c</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704221854670.png" alt="image-20220704221854670" style="zoom:50%;" />

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220704223813288.png" alt="image-20220704223813288"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/03/6-828Lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/03/6-828Lab2/" class="post-title-link" itemprop="url">6.828Lab2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-03 17:02:07" itemprop="dateCreated datePublished" datetime="2022-06-03T17:02:07+08:00">2022-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-08 14:33:35" itemprop="dateModified" datetime="2022-07-08T14:33:35+08:00">2022-07-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Lab2-Memory-Management"><a href="#Lab2-Memory-Management" class="headerlink" title="Lab2: Memory Management"></a>Lab2: Memory Management</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro:"></a><strong>Intro:</strong></h2><p>在本实验中，您将为您的操作系统编写内存管理代码。内存管理有两个组件。</p>
<p>第一个组件是内核的物理内存分配器，以便内核可以分配内存并在以后释放它。您的分配器将以 4096 字节为单位运行，称为 <em>pages</em>。您的任务是维护数据结构，记录哪些物理页面是空闲的，哪些是已分配的，以及有多少进程共享每个分配的页面。您还将编写例程来分配和释放内存页面。</p>
<p>内存管理的第二个组成部分是<em>虚拟内存</em>，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。x86 硬件的内存管理单元 (MMU) 在指令使用内存时执行映射，并参考一组页表。您将根据我们提供的规范修改 JOS 以设置 MMU 的页表。</p>
<p><strong>boot_map_region映射的物理页不改变对应的pp_ref，一个物理页被这个函数映射与它是否被使用没有任何关系；而通过page_insert映射的物理页，同时就表示了该物理页被使用了一次，要给pp_ref加1。</strong></p>
<p><strong>切换到lab2</strong></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/cMWvLOmap3qKoRQ.png" alt="image-20220603213654097"></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/OvA5ZRXUjzwGI39.png" alt="image-20220603213707953"></p>
<p><code>memlayout.h</code>描述了您必须通过修改<code>pmap.c</code>来实现的虚拟地址空间的布局。</p>
<p><code>memlayout.h</code>和<code>pmap.h</code>定义了<code>PageInfo</code> 用于跟踪哪些物理内存页面空闲的结构。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220623205319533.png" alt="image-20220623205319533"></p>
<p><code>kclock.c</code> and <code>kclock.h</code> manipulate the PC’s battery-backed clock and CMOS RAM hardware, in which the BIOS records the amount of physical memory the PC contains, among other things. </p>
<p><code>pmap.c</code>中的代码需要读取这个设备硬件，以便计算出有多少物理内存，但是这部分代码是为您完成的：您不需要了解 CMOS 硬件如何工作的细节。</p>
<p>请特别注意<code>memlayout.h</code>和<code>pmap.h</code>，因为本实验要求您使用并理解它们包含的许多定义。您可能还想查看<code>inc/mmu.h</code>，因为它还包含许多对本实验有用的定义。</p>
<p>在开始实验之前，不要忘记add -f 6.828获取 6.828 版本的 QEMU。</p>
<h1 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h1><p>您现在将编写物理页分配器。它通过对象的链接列表跟踪哪些页面是空闲的<code>struct PageInfo</code>（与 xv6 不同，这些对象<em>不</em>嵌入空闲页面本身），每个对象对应一个物理页面。您需要先编写物理页面分配器，然后才能编写其余的虚拟内存实现，因为您的页表管理代码将需要分配物理内存来存储页表。</p>
<h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><p>在文件<code>kern/pmap.c</code>中，您必须实现以下函数的代码（可能按照给定的顺序）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boot_alloc()</span><br><span class="line">mem_init()（仅限于调用check_page_free_list(<span class="number">1</span>)）</span><br><span class="line">page_init()</span><br><span class="line">page_alloc()</span><br><span class="line">page_free()</span><br></pre></td></tr></table></figure>

<p><code>check_page_free_list() 和 check_page_alloc()</code>测试您的物理页面分配器。</p>
<p>您应该启动 JOS 并查看是否<code>check_page_alloc()</code> 报告成功。</p>
<p>Fix您的代码以使其通过。You may find it helpful to add your own <code>assert()</code>s to verify that your assumptions are correct.</p>
<p><strong>boot_alloc()</strong> 是一个内存分配器</p>
<p>函数的核心是维护一个静态变量<strong>nextfree</strong>，代表下一个可以使用的空闲内存空间的<strong>虚拟地址</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">boot_alloc</span><span class="params">(<span class="keyword">uint32_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nextfree;    <span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line">    <span class="keyword">char</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line">    <span class="comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span></span><br><span class="line">    <span class="comment">// which points to the end of the kernel&#x27;s bss segment:</span></span><br><span class="line">    <span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line">    <span class="comment">// to any kernel code or global variables.</span></span><br><span class="line">    <span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">        <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line">        nextfree = ROUNDUP((<span class="keyword">char</span> *) end, PGSIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span></span><br><span class="line">    <span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">    <span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// LAB 2: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;  <span class="comment">// if n == 0, returns the address of the next free page without allocating anything.</span></span><br><span class="line">        <span class="keyword">return</span> nextfree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n &gt; 0 分配足够的连续物理内存页以容纳〞n”个字节。returns a kernel virtual address.</span></span><br><span class="line">    result = nextfree;</span><br><span class="line">    nextfree += ROUNDUP(n, PGSIZE); <span class="comment">// Round up to the nearest multiple of PGSIZE</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>mem_init()</strong> 需要我们设置一个两层的页表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">mem_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cr0;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span></span><br><span class="line">    i386_detect_memory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove this line when you&#x27;re ready to test this function.</span></span><br><span class="line">    <span class="comment">// panic(&quot;mem_init: This function is not finished\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// create initial page directory.</span></span><br><span class="line">    kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">    <span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Recursively insert PD in itself as a page table, to form</span></span><br><span class="line">    <span class="comment">// a virtual page table at virtual address UVPT.</span></span><br><span class="line">    <span class="comment">// (For now, you don&#x27;t have understand the greater purpose of the</span></span><br><span class="line">    <span class="comment">// following line.)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span></span><br><span class="line">    <span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line">    <span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line">    <span class="comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span></span><br><span class="line">    <span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// 创建一个struct PageInfo 的数组</span></span><br><span class="line">    <span class="comment">// kernel 使用这个数组来耿总每个物理页</span></span><br><span class="line">    <span class="comment">// 对于每一个物理页，都会有一个对应的 struct PageInfo 在数组中</span></span><br><span class="line">    pages = (struct PageInfo *) boot_alloc(npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line">    <span class="comment">// npages 是内存中物理页的数量</span></span><br><span class="line">    <span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Now that we&#x27;ve allocated the initial kernel data structures, we set</span></span><br><span class="line">    <span class="comment">// up the list of free physical pages. Once we&#x27;ve done so, all further</span></span><br><span class="line">    <span class="comment">// memory management will go through the page_* functions. In</span></span><br><span class="line">    <span class="comment">// particular, we can now map memory using boot_map_region</span></span><br><span class="line">    <span class="comment">// or page_insert</span></span><br><span class="line">    page_init();</span><br><span class="line"></span><br><span class="line">    check_page_free_list(<span class="number">1</span>);</span><br><span class="line">    check_page_alloc();</span><br><span class="line">    check_page();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line">    <span class="comment">// Permissions:</span></span><br><span class="line">    <span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line">    <span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">    <span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line">    <span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line">    <span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">    <span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line">    <span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line">    <span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line">    <span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line">    <span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line">    <span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line">    <span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line">    <span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line">    <span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line">    <span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line">    <span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the initial page directory has been set up correctly.</span></span><br><span class="line">    check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch from the minimal entry page directory to the full kern_pgdir</span></span><br><span class="line">    <span class="comment">// page table we just created. Our instruction pointer should be</span></span><br><span class="line">    <span class="comment">// somewhere between KERNBASE and KERNBASE+4MB right now, which is</span></span><br><span class="line">    <span class="comment">// mapped the same way by both page tables.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the machine reboots at this point, you&#x27;ve probably set up your</span></span><br><span class="line">    <span class="comment">// kern_pgdir wrong.</span></span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">    check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// entry.S set the really important flags in cr0 (including enabling</span></span><br><span class="line">    <span class="comment">// paging).  Here we configure the rest of the flags that we care about.</span></span><br><span class="line">    cr0 = rcr0();</span><br><span class="line">    cr0 |= CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_MP;</span><br><span class="line">    cr0 &amp;= ~(CR0_TS | CR0_EM);</span><br><span class="line">    lcr0(cr0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some more checks, only possible after kern_pgdir is installed.</span></span><br><span class="line">    check_page_installed_pgdir();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>page_init()</strong> 初始化页面结构和内存空闲列表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line">    <span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line">    <span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line">    <span class="comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span></span><br><span class="line">    <span class="comment">// 将页 0 标记为使用状态</span></span><br><span class="line">    pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line">    <span class="comment">//     is free.</span></span><br><span class="line">    <span class="comment">// 剩下的标为空闲状态</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;npages_basemem;++i)&#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line">    <span class="comment">//     never be allocated.</span></span><br><span class="line">    <span class="comment">// io端口, 不能被分配</span></span><br><span class="line">    <span class="keyword">for</span>(i = IOPHYSMEM/PGSIZE;i&lt;EXTPHYSMEM/PGSIZE;++i)&#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">    <span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line">    <span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line">    <span class="comment">//     page tables and other data structures?</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Change the code to reflect this.</span></span><br><span class="line">    <span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line">    <span class="comment">// free pages!</span></span><br><span class="line">    <span class="comment">// 找到第一个能分配的页面</span></span><br><span class="line">    <span class="comment">// boot_alloc有个 nextfree指针，但是是虚拟地址，我们要将其转换为物理地址 physical address</span></span><br><span class="line">    <span class="comment">// PADDR 可以实现地址的转换</span></span><br><span class="line">    <span class="keyword">size_t</span> first_free_address = PADDR(boot_alloc(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 看看extend physical memory 是不是free</span></span><br><span class="line">    <span class="keyword">for</span>(i = EXTPHYSMEM/PGSIZE;i&lt;first_free_address/PGSIZE;++i)&#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把页面设为空闲，插入链表头部</span></span><br><span class="line">    <span class="keyword">for</span> (i = first_free_address/PGSIZE; i &lt; npages; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>page_alloc()</strong> 完成页面的分配。</p>
<p>分配是基于PageInfo的，只是把页面标记为使用，并未真正的分配页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page2kva: page to kernel virtual address</span></span><br><span class="line"><span class="function">struct PageInfo *</span></span><br><span class="line"><span class="function"><span class="title">page_alloc</span><span class="params">(<span class="keyword">int</span> alloc_flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// 超过空闲内存的范围，则返回NULL</span></span><br><span class="line">    <span class="comment">// 所分配界面的 pp_link 设置为空, 以便page_free可以检查double-free bug。</span></span><br><span class="line">    <span class="comment">// 分配物理页面。如果(alloc_flags &amp; ALLOC_ZERO)，用&#x27;\0&#x27;字节填充整个返回的物理页面。</span></span><br><span class="line">    <span class="keyword">if</span>(page_free_list == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">allocated_page</span> =</span> page_free_list;</span><br><span class="line">    page_free_list = page_free_list-&gt;pp_link;</span><br><span class="line">    allocated_page-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(alloc_flags &amp; ALLOC_ZERO)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(page2kva(allocated_page),<span class="string">&#x27;\0&#x27;</span>,PGSIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allocated_page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>page_free()</strong></p>
<p>释放一个页面，到page_free_list中</p>
<p>(This function should only be called when pp-&gt;pp_ref reaches 0.)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a page to the free list.</span></span><br><span class="line"><span class="comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_free</span><span class="params">(struct PageInfo *pp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">    <span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line">    <span class="keyword">if</span>(pp-&gt;pp_ref&gt;<span class="number">0</span> || pp-&gt;pp_link!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;Double check failed when dealloc page&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pp-&gt;pp_link = page_free_list;  <span class="comment">// 头插</span></span><br><span class="line">    page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 <code>make qemu-nox</code> 运行，发现报了个panic， 需要把panic注释掉。看漏了</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220626094749150.png" alt="image-20220626094749150"></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220626094809597.png" alt="image-20220626094809597"></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220626104146086.png" alt="image-20220626104146086"></p>
<h1 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h1><p><strong>虚拟内存</strong><br>当 cpu 拿到一个地址并根据地址访问内存时，在 x86架构下药经过至少两级的地址变换：段式变换和页式变换。分段机制的主要目的是将代码段、数据段以及堆栈段分开，保证互不干扰。分页机制则是为了实现虚拟内存。<br>虚拟内存主要的好处是：</p>
<p>让每个程序都以为自己独占计算机内存空间，概念清晰，方便程序的编译和装载。<br>通过将部分内存暂存在磁盘上，可以让程序使用比物理内存大得多的虚拟内存，突破物理内存的限制。<br>通过对不同进程设置不同页表，可以防止进程访问其他进程的地址空间。通过在不同进程之间映射相同的物理页，又可以提供进程间的共享。</p>
<p><strong>虚拟、线性和物理地址</strong></p>
<p><strong>虚拟地址</strong><br>最原始的地址，也是 C/C++ 指针使用的地址。由前 16bit 段 (segment) 选择器和后 32bit 段内的偏移 (offset) 组成，显然一个段大小为 4GB。通过虚拟地址可以获得线性地址。<br><strong>线性地址</strong><br>前 10bit 为页目录项(page directory entry, PDE)，即该地址在页目录中的索引。中间 10bit 为页表项(page table entry, PTE)，代表在页表中的索引，最后 12bit 为偏移，也就是每页 4kB。通过线性地址可以获得物理地址。</p>
<p>页目录偏移DIR ｜页表偏移Table｜页内偏移Offset</p>
<p><strong>物理地址</strong><br>经过段转换以及页面转换，最终在 RAM 的硬件总线上的地址。</p>
<p><em><strong>JOS只有一个段，因此虚拟地址在数值上等于线性地址。</strong></em></p>
<h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h2><p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220626152236756.png" alt="image-20220626152236756"></p>
<p>pgdir 是指向页目录的指针。</p>
<p><strong>pgdir_walk()</strong>  returns a pointer to page table entry(PTE) for linear address(va)。查找一个虚拟地址对应的页表项地址。</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/1200.png" alt="img" style="zoom: 50%;" />

<p>在页目录项、页表项中存储的是页表项的<strong>物理地址</strong>前 20bit 外加 12bit 的 flag。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given &#x27;pgdir&#x27;, a pointer to a page directory, pgdir_walk returns</span></span><br><span class="line"><span class="comment">// a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// This requires walking the two-level page table structure.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The relevant page table page might not exist yet.</span></span><br><span class="line"><span class="comment">// If this is true, and create == false, then pgdir_walk returns NULL.</span></span><br><span class="line"><span class="comment">// Otherwise, pgdir_walk allocates a new page table page with page_alloc.</span></span><br><span class="line"><span class="comment">//    - If the allocation fails, pgdir_walk returns NULL.</span></span><br><span class="line"><span class="comment">//    - Otherwise, the new page&#x27;s reference count is incremented,</span></span><br><span class="line"><span class="comment">//	the page is cleared,</span></span><br><span class="line"><span class="comment">//	and pgdir_walk returns a pointer into the new page table page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 1: you can turn a PageInfo * into the physical address of the</span></span><br><span class="line"><span class="comment">// page it refers to with page2pa() from kern/pmap.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 2: the x86 MMU checks permission bits in both the page directory</span></span><br><span class="line"><span class="comment">// and the page table, so it&#x27;s safe to leave permissions in the page</span></span><br><span class="line"><span class="comment">// directory more permissive than strictly necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 3: look at inc/mmu.h for useful macros that manipulate page</span></span><br><span class="line"><span class="comment">// table and page directory entries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// typedef uint32_t pte_t;</span></span><br><span class="line"><span class="comment">// pgdir_walk returns a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line"><span class="function"><span class="keyword">pte_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">pgdir_walk</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// pgdir 页目录项地址</span></span><br><span class="line">    <span class="comment">// va 虚拟地址，jos只有一个段，因此虚拟地址等于线性地址</span></span><br><span class="line">    <span class="comment">// create 若页目录项不存在是否创建</span></span><br><span class="line">    <span class="comment">// return  页表项指针</span></span><br><span class="line">    <span class="keyword">uint32_t</span> page_dir_index = PDX(va);</span><br><span class="line">    <span class="keyword">uint32_t</span> page_table_index = PTX(va);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pte_t</span>* pgtab;</span><br><span class="line">    <span class="keyword">if</span>(pgdir[page_dir_index] &amp;&amp; PTE_P)&#123;  <span class="comment">// 存在且可写</span></span><br><span class="line">        pgtab = KADDR(PTE_ADDR(pgdir[page_dir_index]));  <span class="comment">// KADDR-&gt;virtual address</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 不存在</span></span><br><span class="line">        <span class="keyword">if</span>(create)&#123;</span><br><span class="line">            <span class="comment">// 创建新的页表项</span></span><br><span class="line">            <span class="comment">// For page_alloc, zero the returned physical page.</span></span><br><span class="line">            <span class="comment">// ALLOC_ZERO = 1&lt;&lt;0,</span></span><br><span class="line">            struct PageInfo* new_pageInfo = page_alloc(ALLOC_ZERO);</span><br><span class="line">            <span class="keyword">if</span>(new_pageInfo)&#123;</span><br><span class="line">                new_pageInfo-&gt;pp_ref+=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 存入数组</span></span><br><span class="line">                <span class="comment">// 依次获取 table_index 和 dir_index</span></span><br><span class="line">                <span class="comment">// page2kva() page to kernel virtual address</span></span><br><span class="line">                pgtab = (<span class="keyword">pte_t</span>*)page2kva(new_pageInfo);</span><br><span class="line">                pgdir[page_dir_index] = PADDR(pgtab) | PTE_P | PTE_W | PTE_U; <span class="comment">// PADDR 虚拟到物理</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;pgtab[page_table_index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>page_lookup()</strong></p>
<p>// 返回映射到虚拟地址 va 的页面<br>// pgdir_walk 只查询，不创建，create为0<br>// pa2page 由物理地址 返回对应的页面描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map [va, va+size) of virtual address space to physical [pa, pa+size) in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and va and pa are both page-aligned.</span><br><span class="line">This function is only intended to set up the ``static&#x27;&#x27; mappings above UTOP. As such, it should *not* change the pp_ref field on the mapped pages.</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the page mapped at virtual address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// If pte_store is not zero, then we store in it the address</span></span><br><span class="line"><span class="comment">// of the pte for this page.  This is used by page_remove and</span></span><br><span class="line"><span class="comment">// can be used to verify page permissions for syscall arguments,</span></span><br><span class="line"><span class="comment">// but should not be used by most callers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return NULL if there is no page mapped at va.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk and pa2page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回映射到虚拟地址 va 的页面</span></span><br><span class="line"><span class="comment">// pgdir_walk 只查询，不创建，create为0</span></span><br><span class="line"><span class="comment">// pa2page 由物理地址 返回对应的页面描述</span></span><br><span class="line"><span class="function">struct PageInfo *</span></span><br><span class="line"><span class="function"><span class="title">page_lookup</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, <span class="keyword">pte_t</span> **pte_store)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// pdgir 页目录地址</span></span><br><span class="line">    <span class="comment">// va 虚拟地址</span></span><br><span class="line">    <span class="comment">// pte_store 指向页表指针的指针 the address of the pte for this page</span></span><br><span class="line">    <span class="comment">// If pte_store is not zero, then we store in it the address of the pte for this page.</span></span><br><span class="line">    <span class="keyword">pde_t</span>* find_pgtab = pgdir_walk(pgdir, va, <span class="number">0</span>);  <span class="comment">// 根据va，返回一个指向page table entry的指针</span></span><br><span class="line">    <span class="keyword">if</span>(!find_pgtab)&#123;  <span class="comment">// 没找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    <span class="comment">// 再找page table的虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(pte_store)&#123;</span><br><span class="line">        *pte_store = find_pgtab;  <span class="comment">// 保存下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回页面描述 struct PageInfo *</span></span><br><span class="line">	<span class="keyword">return</span> pa2page(PTE_ADDR(*find_pgtab));  <span class="comment">// PTE_ADDR 将页表指针指向的内容转为物理地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>page_remove()</strong> </p>
<p> 移除一个虚拟地址与对应物理地址的映射关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unmaps the physical page at virtual address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// If there is no physical page at that address, silently does nothing.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Details:</span></span><br><span class="line"><span class="comment">//   - The ref count on the physical page should decrement.</span></span><br><span class="line"><span class="comment">//   - The physical page should be freed if the refcount reaches 0.</span></span><br><span class="line"><span class="comment">//   - The pg table entry corresponding to &#x27;va&#x27; should be set to 0.</span></span><br><span class="line"><span class="comment">//     (if such a PTE exists)</span></span><br><span class="line"><span class="comment">//   - The TLB must be invalidated if you remove an entry from</span></span><br><span class="line"><span class="comment">//     the page table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The TA solution is implemented using page_lookup,</span></span><br><span class="line"><span class="comment">//     tlb_invalidate, and page_decref.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 移除一个虚拟地址与对应物理地址的映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_remove</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// pgdir 页目录地址</span></span><br><span class="line">    <span class="comment">// va 虚拟地址</span></span><br><span class="line">    <span class="comment">// 首先要找到 va对应的物理地址, 使用 page_lookup</span></span><br><span class="line">    <span class="comment">// page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)</span></span><br><span class="line">    <span class="keyword">pte_t</span>* pgtab;</span><br><span class="line">    <span class="keyword">pte_t</span>** pte_store = &amp;pgtab;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pInfo</span> =</span> page_lookup(pgdir, va, pte_store);</span><br><span class="line">    <span class="keyword">if</span>(!pInfo)&#123; <span class="comment">// 空的</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    page_decref(pInfo);  <span class="comment">// 减少页上的引用计数，如果没有引用则释放该计数。</span></span><br><span class="line">    *pgtab = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// tlb_invalidate(pde_t *pgdir, void *va)</span></span><br><span class="line">    tlb_invalidate(pgdir, va); <span class="comment">// 使TLB条目无效，但前提是正在编辑的页表是当前处理器正在使用的页表。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>page_insert()</strong></p>
<p>建立一个虚拟地址与物理页的映射，与page_remove() 对应。</p>
<p>The permissions (the low 12 bits) of the page table entry should be set to ‘perm|PTE_P’.</p>
<p><strong>requirement：</strong></p>
<p>// 如果已经有一个页面映射到’va’，it should be page_remove()d.</p>
<p>// 如果有必要，应按需分配一个页表，并插入到’pgdir’。</p>
<p>// 如果插入成功，pp-&gt;pp_ref应该加1。</p>
<p>// TLB必须无效，如果 ‘va’ 对应的一个页面已经存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立一个虚拟地址与物理页的映射，与page_remove() 对应</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// pgdir 页目录指针</span></span><br><span class="line">    <span class="comment">// pp 页描述结构体 指针</span></span><br><span class="line">    <span class="comment">// va  虚拟地址</span></span><br><span class="line">    <span class="comment">// perm  权限</span></span><br><span class="line">    <span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir, va, <span class="number">1</span>); <span class="comment">// 查询该虚拟地址对应的页表项(struct PageInfo)，不存在则建立</span></span><br><span class="line">    <span class="keyword">if</span>(!pgtab)&#123;  <span class="comment">// 建立失败</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立成功</span></span><br><span class="line">    <span class="keyword">if</span>(*pgtab &amp;&amp; PTE_P)&#123;  <span class="comment">// 可以写入</span></span><br><span class="line">        <span class="comment">// 若该虚拟地址va已经映射到了其他物理页</span></span><br><span class="line">        <span class="keyword">if</span>(page2pa(pp) == PTE_ADDR(*pgtab))&#123;  <span class="comment">// PTE_ADDR Address in page table or page directory entry</span></span><br><span class="line">            <span class="comment">// 更改权限，不增加引用</span></span><br><span class="line">            *pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 更新映射的物理页，则需要删除之前的映射关系</span></span><br><span class="line">            page_remove(pgdir, va);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除后建立新的物理页</span></span><br><span class="line">    *pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">    pp-&gt;pp_ref++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>boot_map_region()</strong></p>
<p>映射一片虚拟页到制定物理页，大小为size， size是PGSIZE的倍数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map [va, va+size) of virtual address space to physical [pa, pa+size)</span></span><br><span class="line"><span class="comment">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and</span></span><br><span class="line"><span class="comment">// va and pa are both page-aligned.</span></span><br><span class="line"><span class="comment">// Use permission bits perm|PTE_P for the entries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function is only intended to set up the ``static&#x27;&#x27; mappings</span></span><br><span class="line"><span class="comment">// above UTOP. As such, it should *not* change the pp_ref field on the</span></span><br><span class="line"><span class="comment">// mapped pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk</span></span><br><span class="line"><span class="comment">// 映射一片虚拟页到指定物理页，大小为size， size是PGSIZE的倍数</span></span><br><span class="line"><span class="comment">// va -&gt; pa</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">boot_map_region</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// *pgdir 页目录指针</span></span><br><span class="line">    <span class="comment">// va 虚拟地址</span></span><br><span class="line">    <span class="comment">// size size是PGSIZE的倍数，</span></span><br><span class="line">    <span class="comment">// pa 物理地址</span></span><br><span class="line">    <span class="comment">// perm 权限</span></span><br><span class="line">    <span class="comment">// 直接使用页数来分配，避免溢出</span></span><br><span class="line">    <span class="keyword">pte_t</span>* pgtab;</span><br><span class="line">    <span class="keyword">size_t</span> pg_count = PGNUM(size);  <span class="comment">// size能分成多少页</span></span><br><span class="line">    <span class="comment">// pte_t* pgdir_walk(pde_t *pgdir, const void *va, int create)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i&lt;pg_count;++i)&#123;</span><br><span class="line">        pgtab = pgdir_walk(pgdir, (<span class="keyword">void</span>*)va, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// pgdir_walk returns a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line">        *pgtab = pa | perm | PTE_P; <span class="comment">// 权限</span></span><br><span class="line">        va+=PGSIZE;</span><br><span class="line">        pa+=PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220627153213219.png" alt="image-20220627153213219"></p>
<h1 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h1><p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220627204004274.png" alt="image-20220627204004274"></p>
<p>JOS将处理器的32位线性地址划分为 用户地址()  和  内核地址()，二者以ULIM划分。</p>
<p>计算可得出一个物理页大小是4MB</p>
<p>ULIM = (MMIOLIM - PTSIZE) = (KSTACKTOP - PTSIZE - PTSIZE) = 0xF0000000 - 0x00400000 - 0x00400000 = 0xef800000</p>
<p>查看memlayout.h 可以看到，的确为0xef800000</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220627204422272.png" alt="image-20220627204422272"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line"><span class="comment">// UPAGES是JOS记录物理页面使用情况的数据结构，只有kernel能够访问</span></span><br><span class="line"><span class="comment">// 但是现在需要让用户空间能够读取这段线性地址，因此需要建立映射，将用户空间的一块内存映射到存储该数据结构的物理地址上</span></span><br><span class="line"><span class="comment">// boot_map_region() 建立映射关系</span></span><br><span class="line">boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)UPAGES, npages*<span class="keyword">sizeof</span>(struct PageInfo), PADDR(pages), PTE_U | PTE_P);</span><br><span class="line"><span class="comment">// 目前建立了一个页目录，kernel_pgdir</span></span><br><span class="line"><span class="comment">// pgdir为页目录指针， UPAGES为虚拟地址，npages*sizeof(struct* PageInfo)为映射的内存块大小</span></span><br><span class="line"><span class="comment">// PADDR(pages) 为物理地址， PTE_U | PTE为权限 (PTE_U 表示用户可读)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line"><span class="comment">// kernel  内核栈</span></span><br><span class="line"><span class="comment">// kernel stack 从虚拟地址 KSTACKTOP 开始，向低地址增长，所以KSTACKTOP实际上是栈顶</span></span><br><span class="line"><span class="comment">// KSTACKTOP = 0xf0000000，</span></span><br><span class="line"><span class="comment">// KSTKSIZE = (8*PGSIZE) = 8*4096(bytes) = 32KB</span></span><br><span class="line"><span class="comment">// 只需要映射 [KSTACKTOP, KSTACKTOP - KSTKSIZE) 范围的虚拟地址</span></span><br><span class="line">boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)(KSTACKTOP - KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);</span><br><span class="line"><span class="comment">// PTE_W 开启了写权限，但是并未打开 PTE_U， 因此用户没有权限，只有内核有权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line"><span class="comment">// 内核部分</span></span><br><span class="line"><span class="comment">// KERNBASE    = 0xF0000000， VA大小为 2^32 - KERNBASE</span></span><br><span class="line"><span class="comment">// ROUNDUP(a,n) 将a四舍五入到最接近n的倍数</span></span><br><span class="line">boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)KERNBASE, ROUNDUP(<span class="number">0xffffffff</span> - KERNBASE + <span class="number">1</span>, PGSIZE), <span class="number">0</span>, PTE_W | PTE_P);</span><br></pre></td></tr></table></figure>





<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220628111506229.png" alt="image-20220628111506229"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><ol>
<li><p><strong>此时，页面目录中填写了哪些条目（行）？他们映射什么地址，指向哪里？换句话说，尽可能多地填写这张表格：</strong></p>
<table>
<thead>
<tr>
<th>入口</th>
<th>基本虚拟地址</th>
<th>指向（逻辑上）：</th>
</tr>
</thead>
<tbody><tr>
<td>1023</td>
<td>0xffc00000</td>
<td>page table for [252,256)MB of physical address</td>
</tr>
<tr>
<td>1022</td>
<td>0xff900000</td>
<td>page table for [248,252)MB of physical address</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>960</td>
<td>0xf0000000</td>
<td>page table for [0,4)MB of physical address</td>
</tr>
<tr>
<td>959</td>
<td>0xefc00000</td>
<td></td>
</tr>
<tr>
<td>958</td>
<td>0xef800000</td>
<td>ULIM</td>
</tr>
<tr>
<td>957</td>
<td>0xef400000</td>
<td>State register (UVPT)</td>
</tr>
<tr>
<td>956</td>
<td>0xef000000</td>
<td>UPAGES, array of PageInfo</td>
</tr>
<tr>
<td>955</td>
<td>0xeec00000</td>
<td>UPAGES, array of PageInfo</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>NULL</td>
</tr>
<tr>
<td>1</td>
<td>0x00400000</td>
<td>NULL</td>
</tr>
<tr>
<td>0</td>
<td>0x00000000</td>
<td><strong>same as 960</strong></td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User read-only virtual page table (see &#x27;uvpt&#x27; below)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UVPT      (ULIM - PTSIZE)</span></span><br><span class="line"><span class="comment">// Read-only copies of the Page structures</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UPAGES    (UVPT - PTSIZE)</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>我们已将内核和用户环境放置在同一地址空间中。为什么用户程序无法读取或写入内核的内存？哪些特定机制可以保护内核内存？</strong></p>
<p>页表内的标记位可以设置权限，PTE_U设置为1，用户才有权利读写。</p>
</li>
<li><p><strong>这个操作系统可以支持的最大物理内存量是多少？为什么？</strong></p>
<p>UPAGES 大小是4096bytes，即4MB，每个结构体 PageInfo 占8bytes。指针占4字节，uint16_t占两字节，对齐后8字节。</p>
<p>那么共有 4MB / 8B = 2^19 页，</p>
<p>每页的大小PGSIZE = 4096 bytes</p>
<p>那么最多使用 2^19 * 4096 = 2^31 = 2GB 的物理内存</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220628152236712.png" alt="image-20220628152236712"></p>
</li>
<li><p><strong>如果我们真的有最大数量的物理内存，有多少空间来管理内存？这个开销是怎么分解的？</strong></p>
<p>为2GB的最大内存时，UPAGES的大小为4MB，page table directory 的大小为4MB, 一共8MB。 </p>
</li>
<li><p><strong>重新访问<code>kern/entry.S</code>和<code>kern/entrypgdir.c</code>中的页面表设置。在我们打开分页后，EIP仍然是一个低数字（略高于1MB）。我们什么时候过渡到KERNBASE上方的EIP运行？when we enable paging and  when we begin running at an EIP above KERNBASE，是什么使我们能够继续以低EIP执行？为什么需要这种过渡？</strong></p>
<p>EIP寄存器存储着CPU读取的下一条指令的地址，相当于PC计数器。在8086中，EIP=PC。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220628163341015.png" alt="image-20220628163341015"></p>
</li>
</ol>
<p>在jmp处打上断点，向后执行一步，产生了映射，分页机制启动</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220628163655193.png" alt="image-20220628163655193"></p>
<p>把虚拟地址的[0,4M) [KERNBASE, KERNBASE+4M)两个区间都映射到同一个物理地址区间[0,4M)的原因在于不要让指令的寻址受到地址空间变化的影响。</p>
<ul>
<li>Display in a useful and easy-to-read format all of the physical page mappings (or lack thereof) that apply to a particular range of virtual/linear addresses in the currently active address space. For example, you might enter <code>&#39;showmappings 0x3000 0x5000&#39;</code> to display the physical page mappings and corresponding permission bits that apply to the pages at virtual addresses 0x3000, 0x4000, and 0x5000.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加lab2 中的映射函数，以显示pa和va的对应关系</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mon_showmappings</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数个数</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;invalid arguments num. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数个数符合，那么依次提取pa和va</span></span><br><span class="line">    <span class="keyword">char</span> *errChar;</span><br><span class="line">    <span class="keyword">uintptr_t</span> start_addr = strtol(argv[<span class="number">1</span>], &amp;errChar, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// typedef uint32_t uintptr_t;   uintptr_t represents the numerical value of virtual address.</span></span><br><span class="line">    <span class="keyword">if</span>(*errChar)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;invalid virtual address. \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_addr = strtol(argv[<span class="number">2</span>], &amp;errChar, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">if</span>(*errChar)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;invalid virtual address. \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start_addr &gt; end_addr)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;address 1 should be lower than address 2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按页对齐</span></span><br><span class="line">    start_addr = ROUNDDOWN(start_addr, PGSIZE);</span><br><span class="line">    end_addr = ROUNDUP(end_addr, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次访问</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cur_addr = start_addr;</span><br><span class="line">    <span class="keyword">while</span>(cur_addr &lt;= end_addr)&#123;</span><br><span class="line">        <span class="comment">// 查询当前地址，没有则创建</span></span><br><span class="line">        <span class="keyword">pte_t</span> *cur_pte = pgdir_walk(kern_pgdir, (<span class="keyword">void</span>*)cur_addr, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// pgdir_walk() returns a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line">        <span class="keyword">if</span>(!cur_pte || !(cur_pte &amp;&amp; PTE_P))&#123;</span><br><span class="line">            cprintf(<span class="string">&quot;virtual address [%08x] - not mapped\n&quot;</span>, cur_addr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cprintf(<span class="string">&quot;virtual address [%08x] - physical address [%08x], permission&quot;</span>, cur_addr, PTE_ADDR(*cur_pte));</span><br><span class="line">            <span class="comment">// 查询三种权限</span></span><br><span class="line">            <span class="keyword">char</span> perm_PS = (*cur_pte &amp; PTE_PS)?<span class="string">&#x27;S&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">char</span> perm_W = (*cur_pte &amp; PTE_W)?<span class="string">&#x27;W&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">char</span> perm_U = (*cur_pte &amp; PTE_U)?<span class="string">&#x27;U&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            cprintf(<span class="string">&quot;=%c===%c%cP\n&quot;</span>, perm_PS, perm_W, perm_U);</span><br><span class="line">        &#125;</span><br><span class="line">        cur_addr += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/image-20220628213911940.png" alt="image-20220628213911940"></p>
<p>参考ref：<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/6913c26d8b2c">https://www.jianshu.com/u/6913c26d8b2c</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/25/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%AD%90%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/25/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%AD%90%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">前缀和与子数组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-25 10:48:09" itemprop="dateCreated datePublished" datetime="2022-05-25T10:48:09+08:00">2022-05-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-26 17:20:40" itemprop="dateModified" datetime="2022-05-26T17:20:40+08:00">2022-05-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>相似题目</strong></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/">467. 环绕字符串中唯一的子字符串</a>(中等)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/">795.区间子数组个数</a>(中等)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮</a>(中等)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组</a>（困难）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a>（中等）</p>
</li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-immutable/description/">303. 区域和检索 - 数组不可变</a></li>
<li><a href="https://leetcode.cn/link/?target=https://lucifer.ren/blog/2019/12/11/leetcode-1186/">1186.删除一次得到子数组最大和</a></li>
<li><a href="https://leetcode.cn/link/?target=https://lucifer.ren/blog/2020/01/09/1310.xor-queries-of-a-subarray/">1310. 子数组异或查询</a></li>
<li><a href="https://leetcode.cn/link/?target=https://github.com/azl397985856/leetcode/blob/master/problems/1371.find-the-longest-substring-containing-vowels-in-even-counts.md">1371. 每个元音包含偶数次的最长子字符串</a></li>
</ul>
<p>ref : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-substrings-in-wraparound-string/solution/xi-fa-dai-ni-xue-suan-fa-yi-ci-gao-ding-qian-zhui-/">https://leetcode.cn/problems/unique-substrings-in-wraparound-string/solution/xi-fa-dai-ni-xue-suan-fa-yi-ci-gao-ding-qian-zhui-/</a></p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="例题1-presum"><a href="#例题1-presum" class="headerlink" title="例题1 (presum)"></a>例题1 (presum)</h2><p>有 N 个的正整数放到数组 A 里，现在要求一个新的数组 B，新数组的第 i 个数 B[i]是原数组 A 第 0 到第 i 个数的和。</p>
<p>求解：正常前缀和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; sum;</span><br><span class="line"><span class="keyword">int</span> n = sum.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">psum</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">psum1</span><span class="params">(n)</span></span>;</span><br><span class="line">psum[i] = psum[i<span class="number">-1</span>]+sum[i];   <span class="comment">// [l,r] -&gt;  psum[r] - psum[l-1]</span></span><br><span class="line">psum1[i] = psum[i<span class="number">-1</span>]+sum[i<span class="number">-1</span>]; <span class="comment">// [l, r] -&gt; psum[r+1] - psum[l];</span></span><br></pre></td></tr></table></figure>

<h2 id="例题2-countArray"><a href="#例题2-countArray" class="headerlink" title="例题2 (countArray)"></a>例题2 (countArray)</h2><p>求一个数组的连续子数组总个数。比如 [1,3,4]，其连续子数组有：<code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，需要返回 6。</p>
<p>总的连续子数组个数等于：<strong>以索引为 0 结尾的子数组个数 + 以索引为 1 结尾的子数组个数 + … + 以索引为 n - 1 结尾的子数组个数</strong>。</p>
<p><strong>利用 例题1 的前缀和思路， 边遍历边求和。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a: nums)&#123;</span><br><span class="line">        temp+=<span class="number">1</span>;</span><br><span class="line">        ans+=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：<em>O</em>(N)，其中 N 为数组长度。</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="例题3-countArrayGapK"><a href="#例题3-countArrayGapK" class="headerlink" title="例题3 (countArrayGapK)"></a>例题3 (countArrayGapK)</h2><p>求一个数组相邻差为 1 连续子数组的总个数，就是<strong>索引差 1 的同时，值也差 1。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArrayGap1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] = nums[i<span class="number">-1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">            temp+=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="例题4-countArrayLessEqualK"><a href="#例题4-countArrayLessEqualK" class="headerlink" title="例题4 (countArrayLessEqualK)"></a>例题4 (countArrayLessEqualK)</h2><p>求出不大于 k 的子数组的个数。不大于 k 指的是子数组的全部元素都不大于 k。 比如 [1,3,4] 子数组有 [1], [3], [4], [1,3], [3,4] , [1,3,4]，不大于 3 的子数组有 [1], [3], [1,3] ，那么 [1,3,4] 不大于 3 的子数组个数就是 3。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArrayLessK</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt;= k)&#123;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="例题5-countArraMostEqualK"><a href="#例题5-countArraMostEqualK" class="headerlink" title="例题5(countArraMostEqualK)"></a>例题5(countArraMostEqualK)</h2><p>求出子数组最大值刚好是 k 的子数组的个数。 比如 [1,3,4] 子数组有 [1], [3], [4], [1,3], [3,4] , [1,3,4]，子数组最大值刚好是 3 的子数组有 [3], [1,3] ，那么 [1,3,4] 子数组最大值刚好是 3 的子数组个数就是 2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArraMostEqualK</span><span class="params">(<span class="keyword">int</span> k1, <span class="keyword">int</span> k2, vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子数组最大值刚好是k的子数组</strong>的个数 countArraMostEqualK可以使用<strong>求不大于k的子数组</strong>的方法countArrayLessEqualK 来求解，即 </p>
<p><code>countArraMostEqualK(k) = countArrayLessK (k) - countArrayLessK (k-1)</code></p>
<h2 id="例题6-countArraBetween"><a href="#例题6-countArraBetween" class="headerlink" title="例题6 (countArraBetween)"></a>例题6 (countArraBetween)</h2><p>求出子数组最大值刚好是 介于 k1 和 k2 的子数组的个数。</p>
<p><code>countArraBetween(k1, k2, nums)</code> 等价于 </p>
<p><code>countArrayLessK(k2, nums) - countArrayLessK(k1 - 1, nums), k2&gt;k1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArraBetween</span><span class="params">(<span class="keyword">int</span> k1, <span class="keyword">int</span> k2, vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小于等于 k2 的区域</strong> 减去  <strong>小于 k1 的区域</strong> 就是 <strong>大于等于 k1 且小于等于 k2 的区域</strong>。</p>
<h1 id="467-环绕字符串中唯一的子字符串"><a href="#467-环绕字符串中唯一的子字符串" class="headerlink" title="467. 环绕字符串中唯一的子字符串"></a>467. 环绕字符串中唯一的子字符串</h1><p>把字符串 s 看作是 “abcdefghijklmnopqrstuvwxyz” 的无限环绕字符串，所以 s 看起来是这样的：</p>
<p>“…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….” .<br>现在给定另一个字符串 p 。返回 s 中 唯一 的 p 的 非空子串 的数量 。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: p = &quot;a&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 字符串 s 中只有一个&quot;a&quot;子字符。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: p = &quot;cac&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 字符串 s 中的字符串“cac”只有两个子串“a”、“c”。.</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: p = &quot;zab&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在字符串 s 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">1 &lt;= p.length &lt;= 10^5</span><br><span class="line">p 由小写英文字母构成</span><br></pre></td></tr></table></figure>

<p>套模板3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case467</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((p[i] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; p[i<span class="number">-1</span>] ==<span class="string">&#x27;z&#x27;</span>) || (p[i]-<span class="string">&#x27;a&#x27;</span>) == (p[i<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">26</span> + <span class="number">1</span>)%<span class="number">26</span>)&#123;</span><br><span class="line">            <span class="comment">// 连续</span></span><br><span class="line">            temp++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不连续</span></span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接套模板是错误的，因为对于<strong>cac</strong>这种情况，返回值是3， 但实际上是2，因为c被计算了两次，这就意味着需要去重，如果对于输入<code>abcd</code>使用set去重可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">ab (a, b)</span><br><span class="line">cd  (c, d)</span><br><span class="line">abc (a,b,c,ab,bc,abc)</span><br><span class="line">bcd (b,c,d,bc,cd,bcd)</span><br><span class="line">abcd (....)</span><br></pre></td></tr></table></figure>

<p>发现set中的元素是连续的，那么只用记录以某个字母为结束点的最大长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case467</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((p[i] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; p[i<span class="number">-1</span>] ==<span class="string">&#x27;z&#x27;</span>) || (p[i]-<span class="string">&#x27;a&#x27;</span>) == (p[i<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">26</span> + <span class="number">1</span>)%<span class="number">26</span>)&#123;</span><br><span class="line">            <span class="comment">// 连续</span></span><br><span class="line">            temp++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不连续</span></span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[p[i]-<span class="string">&#x27;a&#x27;</span>] = <span class="built_in">max</span>(dp[p[i]-<span class="string">&#x27;a&#x27;</span>], temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="795-区间子数组个数"><a href="#795-区间子数组个数" class="headerlink" title="795. 区间子数组个数"></a>795. 区间子数组个数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。</span><br><span class="line"></span><br><span class="line">生成的测试用例保证结果符合 32-bit 整数范围。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,1,4,3], left = 2, right = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：满足条件的三个子数组：[2], [2, 1], [3]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,9,2,5,6], left = 2, right = 8</span><br><span class="line">输出：7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= nums.length &lt;= 10^5</span><br><span class="line">0 &lt;= nums[i] &lt;= 10^9</span><br><span class="line">0 &lt;= left &lt;= right &lt;= 10^9</span><br></pre></td></tr></table></figure>

<p>可以看到满足例题6， countArrayBetween， 可以使用 <code>mostK(right) - mostK(left - 1)</code>来解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(vector&lt;<span class="keyword">int</span>&gt;&amp;, <span class="keyword">int</span>)&gt; atMostK = [&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= k)&#123;</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans+=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atMostK</span>(nums, right) - <span class="built_in">atMostK</span>(nums, left - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a>904. 水果成篮</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</span><br><span class="line"></span><br><span class="line">你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</span><br><span class="line"></span><br><span class="line">你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</span><br><span class="line">你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</span><br><span class="line">一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</span><br><span class="line">给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：fruits = [1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= fruits.length &lt;= 10^5</span><br><span class="line">0 &lt;= fruits[i] &lt; fruits.length</span><br></pre></td></tr></table></figure>

<p>就是给你一个数组， 让你<strong>选定一个子数组， 这个子数组最多只有两种数字</strong>，这个选定的子数组最大可以是多少。</p>
<p>和例题四一个样，只不过lessEqual判断为辨别可使用篮子的个数。采摘要连续</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = fruits.<span class="built_in">size</span>();</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 记录需要删除水果的起始下标</span></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mp[fruits[i]] == <span class="number">0</span>) &#123; <span class="comment">// 没使用过</span></span><br><span class="line">			--k;</span><br><span class="line">		&#125;</span><br><span class="line">		mp[fruits[i]]++;</span><br><span class="line">		<span class="keyword">while</span> (k &lt; <span class="number">0</span>) &#123;  <span class="comment">// 有新水果进来，篮子已超出了两个</span></span><br><span class="line">			<span class="comment">// 直至删除空了一种水果，画图好理解</span></span><br><span class="line">			mp[fruits[j]]--;</span><br><span class="line">			<span class="keyword">if</span> (mp[fruits[j]] == <span class="number">0</span>) &#123;</span><br><span class="line">				++k;</span><br><span class="line">			&#125;</span><br><span class="line">			j++; </span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, i - j + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="992-K-个不同整数的子数组"><a href="#992-K-个不同整数的子数组" class="headerlink" title="992. K 个不同整数的子数组"></a>992. K 个不同整数的子数组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数数组 nums和一个整数 k ，返回 num 中 「好子数组」 的数目。</span><br><span class="line"></span><br><span class="line">如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。</span><br><span class="line"></span><br><span class="line">例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。</span><br><span class="line">子数组 是数组的 连续 部分。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,1,2,3], k = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,2,1,3,4], k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= nums.length &lt;= 2 * 10^4</span><br><span class="line">1 &lt;= nums[i], k &lt;= nums.length</span><br></pre></td></tr></table></figure>

<p>条件为不同数字的个数。用个set，不断剔除掉最早出现的数字。</p>
<p>由例题 6，知：<code>equalK = MostEqualK(k) - MostEqualK(k - 1)</code>， 因此答案便呼之欲出了。其他部分和上面的题目 <strong>904. 水果成篮</strong> 一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> mostEqualK = [&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 保存最早出现的数字</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[nums[i]] == <span class="number">0</span>)&#123;  <span class="comment">// 没出现过，加进去</span></span><br><span class="line">                --k; <span class="comment">// 剩余的不同数目减一</span></span><br><span class="line">            &#125;</span><br><span class="line">            mp[nums[i]]++;</span><br><span class="line">            <span class="comment">// 没出现过的数字加进去后发现超出了不同数字的要求值</span></span><br><span class="line">            <span class="keyword">while</span>(k&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                mp[nums[j]]--;</span><br><span class="line">                <span class="keyword">if</span>(mp[nums[j]] == <span class="number">0</span>)&#123;  <span class="comment">// 直至清空前面任何一个数字</span></span><br><span class="line">                    <span class="comment">// 因为删除空的数字之前的那部分也是不能使用的，因为不连续</span></span><br><span class="line">                    ++k; <span class="comment">// k从-1归0， 此时正好用完</span></span><br><span class="line">                &#125;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (i - j + <span class="number">1</span>);  <span class="comment">// 按照之前求countArray的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mostEqualK</span>(nums, k) - <span class="built_in">mostEqualK</span>(nums, k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a>1109. 航班预订统计</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">这里有 n 个航班，它们分别从 1 到 n 进行编号。</span><br><span class="line"></span><br><span class="line">有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</span><br><span class="line">请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2   3   4   5</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       20  20</span><br><span class="line">预订记录 3 ：       25  25  25  25</span><br><span class="line">总座位数：      10  55  45  25  25</span><br><span class="line">因此，answer = [10,55,45,25,25]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：bookings = [[1,2,10],[2,2,15]], n = 2</span><br><span class="line">输出：[10,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       15</span><br><span class="line">总座位数：      10  25</span><br><span class="line">因此，answer = [10,25]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= n &lt;= 2 * 10^4</span><br><span class="line">1 &lt;= bookings.length &lt;= 2 * 10^4</span><br><span class="line">bookings[i].length == 3</span><br><span class="line">1 &lt;= firsti &lt;= lasti &lt;= n</span><br><span class="line">1 &lt;= seatsi &lt;= 10^4</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 差分数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;bookings.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            nums[bookings[i][<span class="number">0</span>]<span class="number">-1</span>] += bookings[i][<span class="number">2</span>];</span><br><span class="line">            nums[bookings[i][<span class="number">1</span>]] -= bookings[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            nums[i]+=nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/6-828Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/17/6-828Lab1/" class="post-title-link" itemprop="url">6.828Lab1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-17 12:00:23" itemprop="dateCreated datePublished" datetime="2022-05-17T12:00:23+08:00">2022-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-08 14:33:34" itemprop="dateModified" datetime="2022-07-08T14:33:34+08:00">2022-07-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="PC-Bootstrap"><a href="#PC-Bootstrap" class="headerlink" title="PC Bootstrap"></a>PC Bootstrap</h1><h2 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h2><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/apzkU1cGI5YCqgR.png" alt="image-20220517122025755" style="zoom: 67%;" />

<ul>
<li>早期PC，16位，只有可用物理地址只有1M(0x00000000~0x000FFFFF)</li>
<li>最重要的部分是**Basic Input/Output System (BIOS)**，它占据从0x000F0000到0x000FFFFF的64KB区域。在早期的pc机中，BIOS保存在read-only memory (ROM)中，现在pc机将BIOS存储在updateable flash memory(可更新的闪存)中。</li>
<li>BIOS负责执行基本的系统初始化，如激活显卡和检查已安装的内存数量。在执行此初始化之后，BIOS从某些适当的位置(如 floppy disk(软盘), hard disk, CD-ROM, or the network)加载操作系统，并将机器的控制权传递给操作系统。</li>
<li>虽然现在可以处理器支持4GB的物理地址空间了，但还是保留那1MB的物理地址的设定来向后兼容</li>
</ul>
<h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><p>学习boot.s,main.c,boot.asm，了解在GDB中执行the boot loader时发生了什么？</p>
<p>在地址 0x7c00 处设置断点，它是加载后的引导扇区的位置。继续运行，直到那个断点。在 <code>boot/boot.S</code> 中跟踪代码，使用源代码和反汇编文件 <code>obj/boot/boot.asm</code> 去保持跟踪。</p>
<p>在 <code>boot/main.c</code> 文件中跟踪进入 <code>bootmain()</code> ，然后进入 <code>readsect()</code>。识别 <code>readsect()</code> 中相关的每一个语句的准确汇编指令。跟踪 <code>readsect()</code> 中剩余的指令，然后返回到 <code>bootmain()</code> 中，识别 <code>for</code> 循环的开始和结束位置，这个循环从磁盘上读取内核的剩余扇区。找出循环结束后运行了什么代码，在这里设置一个断点，然后继续。接下来再走完引导加载器的剩余工作。</p>
<p>完成之后，就能够回答下列的问题了：</p>
<ul>
<li><strong>处理器开始运行 32 代码时指向到什么地方？从 16 位模式切换到 32 位模式的真实原因是什么？</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Jump to next instruction, but in 32-bit code segment.</span><br><span class="line"># Switches processor into 32-bit mode.</span><br><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line">  7c2d:    ea 32 7c 08 00 66 b8   ljmp   $0xb866,$0x87c32</span><br></pre></td></tr></table></figure>

<p>在boot.asm 这里切换到32位代码。应该是经过64与60端口的控制，加载完<strong>GDT</strong>表后，<strong>CRO的bit0位为1</strong>，此时机器已处于保护模式，故处理器从16位模式转为32位模式。</p>
<p>全局描述表(GDT Global Descriptor Table):在保护模式下一个重要的数据结构。用来存储内存的分段信息。</p>
<p>GDT可以被放在内存的任何位置，那么当程序员通过段寄存器来引用一个段描述符时，CPU必须知道GDT的入口，也就是基地址放在哪里，所以Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。</p>
<ul>
<li><strong>引导加载器执行的最后一个指令是什么，内核加载之后的第一个指令是什么？</strong></li>
</ul>
<p>引导加载程序的最后一条指令是boot/main.c中bootmain函数最后的<code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code> 这个第一条指令位于/kern/entry.S文件中，第一句 movw $0x1234, 0x472</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/PDW1a34oZVg8Ytd.png" alt="image-20220517140436330" style="zoom:67%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/5mKUDGAswoZbuIt.png" alt="image-20220517140447848" style="zoom:67%;" />



<ul>
<li><strong>内核的第一个指令在哪里？</strong></li>
</ul>
<p>位于<code>/kern/entry.S</code>文件中</p>
<ul>
<li><strong>为从硬盘上获取完整的内核，引导加载器如何决定有多少扇区必须被读入？在哪里能找到这些信息？</strong></li>
</ul>
<p>通过<code>ELF program headers</code>决定，他在操作系统内核映像文件的ELF头部信息里找到。</p>
<p>Examine the full list of the names, sizes, and link addresses of all the sections in the kernel executable by typing:</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/ZRyWbj38usFvmN9.png" alt="image-20220517155248619"></p>
<ul>
<li><code>.text</code>：程序的可运行指令。</li>
<li><code>.rodata</code>：只读数据，比如，由 C 编译器生成的 ASCII 字符串常量。（然而我们并不需要操心设置硬件去禁止写入它）</li>
<li><code>.data</code>：保持在程序的初始化数据中的数据节，比如，初始化声明所需要的全局变量，比如，像 <code>int x = 5;</code>。</li>
</ul>
<p>look at the <code>.text</code> section of the boot loader:</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/3fRjomwzLVUyE6h.png" alt="image-20220517155417627"></p>
<h3 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h3><p>下载 <a target="_blank" rel="noopener" href="https://sipb.mit.edu/iap/6.828/files/pointers.c">pointers.c</a> 的源代码，运行它，然后确保你理解了输出值的来源的所有内容。尤其是，确保你理解了第 1 行和第 6 行的指针地址的来源、第 2 行到第 4 行的值是如何得到的、以及为什么第 5 行指向的值表面上看像是错误的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">16</span>);  <span class="comment">//一个int四个字节，共16个字节</span></span><br><span class="line">    <span class="keyword">int</span> *c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	a[i] = <span class="number">100</span> + i;</span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">200</span>;  <span class="comment">// c指向a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c[<span class="number">1</span>] = <span class="number">300</span>;</span><br><span class="line">    *(c + <span class="number">2</span>) = <span class="number">301</span>;</span><br><span class="line">    <span class="number">3</span>[c] = <span class="number">302</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = c + <span class="number">1</span>;  <span class="comment">// c指向a[1]。由于a中存int，一个int占四个字节，所以c的地址会+4，而不是+1</span></span><br><span class="line">    *c = <span class="number">400</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = (<span class="keyword">int</span> *) ((<span class="keyword">char</span> *) c + <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">//如果先将c转化为字符串，再直接对字符串+1，这样导致c实际地址就是+1</span></span><br><span class="line">    *c = <span class="number">500</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    b = (<span class="keyword">int</span> *) a + <span class="number">1</span>;</span><br><span class="line">    c = (<span class="keyword">int</span> *) ((<span class="keyword">char</span> *) a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;6: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> ac, <span class="keyword">char</span> **av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/t9ayFTDzYM75lJw.png" alt="img" style="zoom:67%;" />

<p><strong>如果先将c转化为字符串，再直接对字符串+1，这样导致c实际地址就是+1，从<code>0x7fffd33e72c4</code>到<code>0x7fffd33e72c5</code></strong></p>
<h5 id="c-int-char-c-1-与c-c-1的区别"><a href="#c-int-char-c-1-与c-c-1的区别" class="headerlink" title="c = (int *) ((char *) c + 1) 与c=c+1的区别"></a>c = (int *) ((char *) c + 1) 与c=c+1的区别</h5><p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/8CJDEayGtXoR3wp.png" alt="image-20220517161940295"></p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/lh1UiAVvbOWjLay.png" alt="image-20220517162003852" style="zoom:67%;" />

<p>转换为char后，c只向前移动了1位，即八个bit。</p>
<p>*c=500，将灰色框内的值变为500.</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/4WlqerkMhyTUCsc.png" alt="image-20220517162103314" style="zoom:67%;" />

<p><strong>其他</strong><br>如果int *p=(int*)100,则(int)p+1和(int)(p+1)不同，前者是101，但后者是104。当指针加整数时，向第二个例子，整数隐式乘以指针所指向的对象的大小。<br>p[i]定义为和*(p+i)相同，代表p指向的内存的第i个对象，当对象大于1字节时，这条规则起作用<br>&amp;p[i]和(p+i)相同，代表p指向的内存的第i个对象的地址<br>在对内存地址进行加法时，要确定他是<strong>integer addition or pointer addition</strong></p>
<p>ref: <a target="_blank" rel="noopener" href="https://blog.csdn.net/han_hhh/article/details/121701438">https://blog.csdn.net/han_hhh/article/details/121701438</a></p>
<h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p>内核的文件头:</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/FfUZ5AkPBcNlCJV.png" alt="image-20220518152817746" style="zoom:67%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/myS4R9jDwvfcAJp.png" alt="image-20220518152831699" style="zoom:67%;" />

<p>得到了<code>Program Header</code>文件头，上面省略了余下的一些输出内容。每个<code>LOAD</code>都是一个<code>ELF</code>对象，里面包含了相对本文件的索引<code>off</code>、虚拟内址<code>vaddr</code>、物理地址<code>paddr</code>、对齐<code>align</code>、对象在文件和内存中的大小<code>filesz, memsz</code>。</p>
<p>这个<code>header</code>在<code>bootmain</code>函数中通过<code>readseg</code>函数加载到了内存中，位置在<code>0x10000</code>，并通过一个宏<code>ELFHDR</code>索引。<code>header</code>中存放的数据采用的是默认的对齐方式，所以可以直接通过一个<code>struct Elf</code>指针访问各个属性。</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/UxAbKhYMcvPr9Wl.png" alt="image-20220518153305171" style="zoom: 50%;" />

<p>在文件头<code>struct Elf</code>中，我们拿到了关于结构体<code>struct Proghdr</code>数组的信息<code>e_phoff</code>。从这个数组的成员中，我们拿到了关于每个<code>segment</code>的信息，也就可以把它们正式从硬盘中拷贝到内存中的指定位置。</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/3eNXsKyhPwFnWx9.png" alt="image-20220518153337802" style="zoom:50%;" />

<p>第一个<code>segment</code>对象的地址存放在<code>ELFHDR-&gt;e_phoff</code>中，是从硬盘中读入的原始数据。转化为指针如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br></pre></td></tr></table></figure>

<p>也就是加上了一个偏置。同样利用<code>elf</code>文件的数据，查出这个“对象数组”的长度，也就可以遍历这个<code>Proghdr</code>数组了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure>

<p><code>ph</code>是个<code>struct Proghdr</code>类型的指针，直接<code>++</code>让地址的值前进相应地址长度，非常方便。</p>
<p>至此，内核完全加载完毕。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/WKgHeMSYBt3UV8O.png" alt="image-20220518154931248"></p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/bziYmGwcqngRQoB.png" alt="image-20220518170934792" style="zoom: 67%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/rNBvldLZ7WUufDe.png" alt="image-20220518170900480" style="zoom: 67%;" />

<p>获取kernel ELF文件的相关信息：</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/j4RoMerFKCsSQVd.png" alt="image-20220518173511422" style="zoom:67%;" />

<p>可看到程序入口的虚拟地址是0x10000c，程序头表偏移为52B，程序头表条目是2.</p>
<p><strong>如果你得到一个错误的引导加载器链接地址，通过再次跟踪引导加载器的前几个指令，你将会发现第一个指令会 “中断” 或者出错。然后在 <code>boot/Makefrag</code> 修改链接地址来修复错误，运行 <code>make clean</code>，使用 <code>make</code> 重新编译，然后再次跟踪引导加载器去查看会发生什么事情。不要忘了改回正确的链接地址，然后再次 <code>make clean</code>！</strong></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/vPznfE9bwAKSF4N.png" alt="image-20220518181251389"></p>
<p>修改0x7C00为0x7d00，使得bootloader无法正确加载。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/roiDh2v3TskuRAx.png" alt="image-20220518181451276"></p>
<p><strong>可能</strong>就是GDT表加载错误才导致后面加载失败，因为加载信息都错掉了。</p>
<h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><p>在BIOS进入 the boot loader时检查内存0x00100000处的8个字，然后在 the boot loader进入内核时再检查一次。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/D2cVRnXdpaiI5eP.png" alt="image-20220518185538199"></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/CXgSuAbDTMUPWNm.png" alt="image-20220518185555496"></p>
<p>0x00100000往后8个字前后不一样应该是由于bootmain将内核的某个section存入了该地址处。由于要在进入内核时再看一次，故第二个断点应该设置在call entry处，<br>即 *<em>b <em>0x7d69</em></em></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/ylz7Vrp5APt4Roh.png" alt="image-20220518185643002"></p>
<p><strong>内核的入口地址是0x0010000c，也在此范围中，可能是.text段的内容，因为内核最先加载的就是.text</strong></p>
<p>➜  lab git:(lab1) objdump -x obj/kern/kernel </p>
<p>obj/kern/kernel:     file format elf32-i386<br>obj/kern/kernel<br>architecture: i386, flags 0x00000112:<br>EXEC_P, HAS_SYMS, D_PAGED<br>start address 0x0010000c</p>
<p>Program Header:<br>    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 212<br>         filesz 0x0000ee68 memsz 0x0000ee68 flags r-x<br>    LOAD off    0x00010000 vaddr 0xf010f000 paddr 0x0010f000 align 212<br>         filesz 0x0000a948 memsz 0x0000a948 flags rw-</p>
<p>Sections:<br>Idx Name          Size      VMA       LMA       File off  Algn<br>  0 .text         0000178e  f0100000  00100000  00001000  22<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br>  1 .rodata       00000704  f01017a0  001017a0  000027a0  25<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  2 .stab         000044d1  f0101ea4  00101ea4  00002ea4  22<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  3 .stabstr      00008af3  f0106375  00106375  00007375  20<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  4 .data         0000a300  f010f000  0010f000  00010000  212<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  5 .bss          00000648  f0119300  00119300  0001a300  25<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  6 .comment      00000011  00000000  00000000  0001a948  20<br>                  CONTENTS, READONLY</p>
<h1 id="The-kernel"><a href="#The-kernel" class="headerlink" title="The kernel"></a>The kernel</h1><h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><p>在0x0010000c处打上断点，si单步执行，直到 movl %eax, %cr0 前一步</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/JjV2Gl3Uy1RQ8Np.png" alt="image-20220522172810387" style="zoom:67%;" />

<p>查看0x00100000 和 0xf0100000 的内容</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/PBqscTj9QwiO4ed.png" alt="image-20220522172955485" style="zoom:67%;" />

<p>执行movl %eax, %cr0 ， 再次查看内容</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/B3xzQXu8ldivrNK.png" alt="image-20220522173104250"></p>
<p>发现VMA和LMA有相同的内容，这是因为分页后，0x00100000 被映射到了 0xf0100000 处，完成了分页操作。</p>
<p>make clean 后，注释掉movl %eax, %cr0  （kern/entry.S）</p>
<p>重新运行</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/46IQNuzcP17HJ8C.png" alt="image-20220522194929977" style="zoom:67%;" />

<p>qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log  -S<br><strong>qemu: fatal: Trying to execute code outside RAM or ROM at 0xf010002c</strong></p>
<p>EAX=f010002c EBX=00010074 ECX=00000000 EDX=000000d5<br>ESI=00010074 EDI=00000000 EBP=00007bf8 ESP=00007bec<br>EIP=f010002c EFL=00000086 [–S–P-] CPL=0 II=0 A20=1 SMM=0 HLT=0<br>ES =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>CS =0008 00000000 ffffffff 00cf9a00 DPL=0 CS32 [-R-]<br>SS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>DS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>FS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>GS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>LDT=0000 00000000 0000ffff 00008200 DPL=0 LDT<br>TR =0000 00000000 0000ffff 00008b00 DPL=0 TSS32-busy<br>GDT=     00007c4c 00000017<br>IDT=     00000000 000003ff<br>CR0=00000011 CR2=00000000 CR3=00117000 CR4=00000000<br>DR0=00000000 DR1=00000000 DR2=00000000 DR3=00000000<br>DR6=ffff0ff0 DR7=00000400<br>CCS=00000084 CCD=80010011 CCO=EFLAGS<br>EFER=0000000000000000<br>FCW=037f FSW=0000 [ST=0] FTW=00 MXCSR=00001f80<br>FPR0=0000000000000000 0000 FPR1=0000000000000000 0000<br>FPR2=0000000000000000 0000 FPR3=0000000000000000 0000<br>FPR4=0000000000000000 0000 FPR5=0000000000000000 0000<br>FPR6=0000000000000000 0000 FPR7=0000000000000000 0000<br>XMM00=00000000000000000000000000000000 XMM01=00000000000000000000000000000000<br>XMM02=00000000000000000000000000000000 XMM03=00000000000000000000000000000000<br>XMM04=00000000000000000000000000000000 XMM05=00000000000000000000000000000000<br>XMM06=00000000000000000000000000000000 XMM07=00000000000000000000000000000000<br>make: *** [qemu-nox-gdb] Aborted (core dumped)</p>
<p><strong>由于未开启分页机制，虚拟地址还未映射到物理地址。</strong></p>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><p>补全”%o”</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/bMnKRuqGXZOvY2l.png" alt="image-20220522213815891" style="zoom:67%;" />

<h4 id="problem-1"><a href="#problem-1" class="headerlink" title="problem 1"></a>problem 1</h4><p>解释<code>printf.c</code>和 <code>console.c</code>之间的接口。<code>具体来说， console.c</code>导出什么函数 ？<code>printf.c</code>如何使用这个函数 ？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// printf.c</span></span><br><span class="line"><span class="comment">// Simple implementation of cprintf console output for the kernel,</span></span><br><span class="line"><span class="comment">// based on printfmt() and the kernel console&#x27;s cputchar().</span></span><br><span class="line"><span class="comment">//为内核简单实现cprintf控制台输出，</span></span><br><span class="line"><span class="comment">//基于printfmt（）和内核控制台的cputchar（）。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">putch</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> *cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cputchar(ch);</span><br><span class="line">   *cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vcprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   vprintfmt((<span class="keyword">void</span>*)putch, &amp;cnt, fmt, ap);</span><br><span class="line">   <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">cprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   va_list ap;</span><br><span class="line">   <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">   va_start(ap, fmt);</span><br><span class="line">   cnt = vcprintf(fmt, ap);</span><br><span class="line">   va_end(ap);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/sLTgyRwqYd8EJcI.png" alt="image-20220522214112303" style="zoom:67%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/dJMHKFrN9vZ5t4a.png" alt="image-20220522214134785" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 03FD    r  line status register</span></span><br><span class="line"><span class="comment">       bit 7 = 0  reserved</span></span><br><span class="line"><span class="comment">       bit 6 = 1  transmitter shift and holding registers empty</span></span><br><span class="line"><span class="comment">       bit 5 = 1  transmitter holding register empty. Controller is</span></span><br><span class="line"><span class="comment">             ready to accept a new character to send.</span></span><br><span class="line"><span class="comment">       bit 4 = 1  break interrupt. the received data input is held in</span></span><br><span class="line"><span class="comment">             in the zero bit state longer than the time of start</span></span><br><span class="line"><span class="comment">             bit + data bits + parity bit + stop bits.</span></span><br><span class="line"><span class="comment">       bit 3 = 1  framing error. the stop bit that follows the last</span></span><br><span class="line"><span class="comment">             parity or data bit is a zero bit.</span></span><br><span class="line"><span class="comment">       bit 2 = 1  parity error. Character has wrong parity</span></span><br><span class="line"><span class="comment">       bit 1 = 1  overrun error. a character was sent to the receiver</span></span><br><span class="line"><span class="comment">             buffer before the previous character in the buffer</span></span><br><span class="line"><span class="comment">             could be read. This destroys the previous</span></span><br><span class="line"><span class="comment">             character.</span></span><br><span class="line"><span class="comment">       bit 0 = 1  data ready. a complete incoming character has been</span></span><br><span class="line"><span class="comment">             received and sent to the receiver buffer register.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">serial_putc</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// COM1 = 0x3F8, COM_LSR(Line Status Register) = 5, COM_LSR_TXRDY(传输缓冲区) = 0x20,</span></span><br><span class="line">    <span class="comment">// 0x03F8 + 5  =&gt; 0x03FD   0x03FD &amp; 0x20(0010 0000) =&gt; 取 bit 5</span></span><br><span class="line">    <span class="comment">// bti 5 = 1 :</span></span><br><span class="line">    <span class="comment">// transmitter holding register empty. Controller is ready to accept a new character to send.</span></span><br><span class="line">    <span class="comment">// 如果bit 5 = 1，那么传输方寄存器已空，controller可以接受一个新的字符了</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>;</span><br><span class="line">        !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="number">12800</span>;  <span class="comment">// bit 5 != 1  &amp;&amp; 没超时</span></span><br><span class="line">        i++)</span><br><span class="line">      delay();</span><br><span class="line">    <span class="comment">//COM_TX = 0    Out: Transmit buffer</span></span><br><span class="line">    <span class="comment">//serial_putc()函数的功能首先就是在bit 5 =1 的时候，跳出循环，否则只要 i &lt;12800就会一直循环等待。</span></span><br><span class="line">   outb(COM1 + COM_TX, c);   <span class="comment">// 将c写入I/O端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** Parallel port output code *****/</span></span><br><span class="line"><span class="comment">// For information on PC parallel port programming, see the class References</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">// 并行端口输入</span></span><br><span class="line"><span class="comment">/* 0x378~0x37A parallel printer port</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0378    w    data port</span></span><br><span class="line"><span class="comment">0379    r/w    status port</span></span><br><span class="line"><span class="comment">         bit 7 = 0 busy * 0x80</span></span><br><span class="line"><span class="comment">         bit 6 = 0 acknowledge</span></span><br><span class="line"><span class="comment">         bit 5 = 1 out of paper</span></span><br><span class="line"><span class="comment">         bit 4 = 1 printer is selected</span></span><br><span class="line"><span class="comment">         bit 3 = 0 error</span></span><br><span class="line"><span class="comment">         bit 2 = 0 IRQ has occurred</span></span><br><span class="line"><span class="comment">         bit 1-0 reserved</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">037A    r/w    control port</span></span><br><span class="line"><span class="comment">         bit 7-5 reserved</span></span><br><span class="line"><span class="comment">         bit 4 = 1 enable IRQ</span></span><br><span class="line"><span class="comment">         bit 3 = 1 select printer    * 0x08</span></span><br><span class="line"><span class="comment">         bit 2 = 0 initialize printer *0x04</span></span><br><span class="line"><span class="comment">         bit 1 = 1 automatic line feed</span></span><br><span class="line"><span class="comment">         bit 0 = 1 strobe        * 0x01</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">lpt_putc</span><span class="params">(<span class="keyword">int</span> c)</span>   <span class="comment">// 并行端口输入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 0x379 &amp; 0x80   读取0x379的内容，和0x80相与，取bits 7，判断是否繁忙</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; !(inb(<span class="number">0x378</span>+<span class="number">1</span>) &amp; <span class="number">0x80</span>) &amp;&amp; i &lt; <span class="number">12800</span>; i++)   <span class="comment">// io端口不繁忙且未超时，一直等待，直到使用了端口或等待时间到</span></span><br><span class="line">      delay();</span><br><span class="line">   outb(<span class="number">0x378</span>+<span class="number">0</span>, c);  <span class="comment">// write char c</span></span><br><span class="line">   outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>|<span class="number">0x04</span>|<span class="number">0x01</span>);   <span class="comment">//初始化 printer</span></span><br><span class="line">   outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>);  <span class="comment">// 选择 printer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">cga_putc</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// if no attribute given, then use black on white</span></span><br><span class="line">    <span class="comment">// 如果没有给定属性，则使用黑白相间的颜色</span></span><br><span class="line">   <span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>))    <span class="comment">// c 低16位为字符值，高16位为显示属性</span></span><br><span class="line">      c |= <span class="number">0x0700</span>;</span><br><span class="line">    <span class="comment">// crt_pos:当前输出位置指针，指向内存区中对应输出映射地址。</span></span><br><span class="line">   <span class="keyword">switch</span> (c &amp; <span class="number">0xff</span>) &#123;    <span class="comment">// 取低16位</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>:   <span class="comment">// backspace</span></span><br><span class="line">      <span class="keyword">if</span> (crt_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         crt_pos--;</span><br><span class="line">         crt_buf[crt_pos] = (c &amp; ~<span class="number">0xff</span>) | <span class="string">&#x27; &#x27;</span>;  <span class="comment">// 删除处使用&#x27; &#x27;填充</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:    <span class="comment">// //new line：换行, 自动添加回车</span></span><br><span class="line">      crt_pos += CRT_COLS;   <span class="comment">// CRT_COLS默认输出格式下整个屏幕的列数，为80。</span></span><br><span class="line">        <span class="comment">// CRT_ROWS:默认输出格式下整个屏幕的行数，为25。</span></span><br><span class="line">      <span class="comment">/* fallthru */</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">      crt_pos -= (crt_pos % CRT_COLS);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:  <span class="comment">// tab  转换为五个 &#x27; &#x27;</span></span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      crt_buf[crt_pos++] = c;       <span class="comment">/* write the character */</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// What is the purpose of this?</span></span><br><span class="line">    <span class="comment">// CRT_SIZE:是CRT_COLS和CRT_ROWS的乘积，即2000=80*25，是不翻页时一页屏幕最大能容纳的字数。</span></span><br><span class="line">    <span class="comment">// 当前屏幕写满了，</span></span><br><span class="line">   <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 函数：memmove(): memmove(void *dst, const void *src, size_t n).</span></span><br><span class="line"><span class="comment">         * 意为将从src指向位置起的n字节数据送到dst指向位置，可以在两个区域重叠时复制。</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">// 所有数据向前挪动一行，最上面一行数据丢失</span></span><br><span class="line">      memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">      <span class="comment">// 清空最后一行，用空格填充</span></span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">         crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      crt_pos -= CRT_COLS;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 写光标位置</span></span><br><span class="line">   <span class="comment">/* move that little blinky thing */</span></span><br><span class="line">   outb(addr_6845, <span class="number">14</span>);</span><br><span class="line">   outb(addr_6845 + <span class="number">1</span>, crt_pos &gt;&gt; <span class="number">8</span>);</span><br><span class="line">   outb(addr_6845, <span class="number">15</span>);</span><br><span class="line">   outb(addr_6845 + <span class="number">1</span>, crt_pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="problem-2"><a href="#problem-2" class="headerlink" title="problem 2"></a>problem 2</h4><ol>
<li><p>从console.c</p>
<p>解释以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1      if (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">2              int i;</span><br><span class="line">3              memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));</span><br><span class="line">4              for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">5                      crt_buf[i] = 0x0700 | &#x27; &#x27;;</span><br><span class="line">6              crt_pos -= CRT_COLS;</span><br><span class="line">7      &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>见上</p>
<h4 id="problem-3"><a href="#problem-3" class="headerlink" title="problem 3"></a>problem 3</h4><ol>
<li><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</p>
<p>Trace the execution of the following code step-by-step:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = 1, y = 3, z = 4;</span><br><span class="line">cprintf(&quot;x %d, y %x, z %d\n&quot;, x, y, z);</span><br></pre></td></tr></table></figure>

<ul>
<li>In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</li>
<li>List (in order of execution) each call to <code>cons_putc</code>, <code>va_arg</code>, and <code>vcprintf</code>. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what <code>ap</code> points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</li>
</ul>
</li>
</ol>
<p>对于以下问题，您可能希望查阅第 2 讲的注释。这些注释涵盖了 GCC 在 x86 上的调用约定。</p>
<p>逐步跟踪以下代码的执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = 1, y = 3, z = 4;</span><br><span class="line">cprintf(&quot;x %d, y %x, z %d\n&quot;, x, y, z);</span><br></pre></td></tr></table></figure>

<h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><ul>
<li>在调用 to<code>cprintf()</code>时，<code>fmt</code>指向什么？<code>ap</code>指向什么？</li>
<li>列出（按执行顺序）对<code>cons_putc</code>、<code>va_arg</code>和 <code>vcprintf</code>的每个调用。对于<code>cons_putc</code>，也列出它的argument。对于 <code>va_arg</code>，列出<code>ap</code>调用前后所指向的内容。列出它的两个参数的<code>vcprintf</code>值。</li>
</ul>
<p>将代码复制到该位置</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/gJmLk95Ce7Z2jb8.png" alt="image-20220522214913927" style="zoom:67%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/M9Fv2azChmu6XpU.png" alt="image-20220522215011773" style="zoom:67%;" />

<p>在gdb给该行打断点</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/CJT36u1powsZPjS.png" alt="image-20220522215850429"></p>
<p>disassemble 反汇编当前代码段的部分指令</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/Z6QbjgWxeX21oCU.png" alt="image-20220522215943610"></p>
<p>在kernel.asm中查找该地址</p>
<p>（vim命令模式下，/+查找字符是向下查找，?是向上查找。 如果你要继续查找此关键字，敲字符n就可以继续查找了）</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/T4gfBOJXFW8Rjid.png" alt="image-20220522220412446" style="zoom: 67%;" />

<p>call 0xf0100906 &lt;cprintf&gt;</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/jCSTbcLE8UJzdRV.png" alt="image-20220522221005338" style="zoom:67%;" />

<p>va_start，函数名称，读取可变参数的过程其实就是在栈区中，使用指针,遍历栈区中的参数列表,从低地址到高地址一个一个地把参数内容读出来的过程·</p>
<p>可以看到 fmt 是 cprintf 函数的第一个参数，即指向字符串<code>&quot;x %d, y %x, z %d\n&quot;</code>的指针。</p>
<p>ap 指向第二个参数的地址。<strong>注意 ap 中存放的是第二个参数的地址，而非第二个参数。</strong></p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/HJTjCcetVzk7buf.png" alt="image-20220522221407297" style="zoom:67%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/MQk6y5TJuNXf3Yz.png" alt="image-20220522221535010" style="zoom:67%;" />

<h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><p>调用关系为 cprintf -&gt; vcprintf -&gt; vprintfmt -&gt; putch -&gt; cputchar -&gt; cons_putc</p>
<p>接上图，可以看到vpprintf后是vprintfmt</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/RsxIbcmhAouZWJ1.png" alt="image-20220522222019680"></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/BlO5HewtJvWUdRG.png" alt="image-20220522222138140"></p>
<p>之后，vprintfmt依次调用putch和cputchar</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/84lAVsnb9TUjMvf.png" alt="image-20220522222344930"></p>
<p>cputchar调用 cons_putc</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/gNm5rjRT9S6iIWl.png" alt="image-20220522222504049"></p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/IoJriQZ5zH7v9k4.png" alt="image-20220522222602885" style="zoom:67%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/NVXpFGzkdOghPEJ.png" alt="image-20220522222620191" style="zoom:67%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/6yoTIQYmvVL3USq.png" alt="image-20220522222706554" style="zoom:67%;" />

<p>0xf010022b之后，    准备输出</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/CREO15lqh9NfXDg.png" alt="image-20220522223041430" style="zoom:50%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/sNVe8uUR5aiJzMx.png" alt="image-20220522223632755" style="zoom:50%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/TSWJcyAMg6GzNZ1.png" alt="image-20220522223329251" style="zoom:67%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/8BRwLbQqtJD2O93.png" alt="image-20220522223357850" style="zoom:67%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/Sy7DiNdcsqnoR9Q.png" alt="image-20220522223512459" style="zoom:67%;" />

<p>120，32,  49， 44， 32， 121， 32， 51， 44， 32， 122， 32， 52， 10</p>
<p>ascii 码转换为char</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/m1pUGnx78lB5VjP.png" alt="image-20220522223726095" style="zoom: 67%;" />

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/BUn6TOxev9pg3ul.png" alt="image-20220522223755233"></p>
<h4 id="problem-4"><a href="#problem-4" class="headerlink" title="problem 4"></a>problem 4</h4><p>Run the following code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise.</p>
<p>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/3SezlGXtE7gMcTD.png" alt="image-20220523130430575"></p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/8fuNUjOd9vnQEkH.png" alt="image-20220523131152245" style="zoom:80%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/LZHfOB14oKDQedl.png" alt="image-20220523131208149" style="zoom:80%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/Az8IQt2FhgD73d1.png" alt="image-20220523131709311" style="zoom:67%;" />

<p>71, 101, 49, 49, 48, 32, 87, 111, 114, 108, 100</p>
<p>He110 World</p>
<img src="https://s2.loli.net/2022/05/23/nrQyBk9HSv85XWC.png" alt="image-20220523131908104" style="zoom:67%;" />

<p>%x 指无符号十六进制数</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/EPGICj2LrVmTzqt.png" alt="image-20220523133643397" style="zoom:67%;" />

<p>57616转换为16进制，正好是e110</p>
<p>%s指字符串，0x00646c72在小端模式下对应的ASCII码为 0x72, 0x6c, 0x64, 0x00, 可得’rld’</p>
<p>如果是在大端 (big endian) 模式下要得到同样的输出，应该改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x726c6400</span>;</span><br><span class="line"><span class="built_in">cprintf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<h4 id="problem-5"><a href="#problem-5" class="headerlink" title="problem 5"></a>problem 5</h4><p>In the following code, what is going to be printed after ‘ y= ‘ ? (note: the answer is not a specific value.) Why does this happen?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure>

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/ioOsFIc4qzEX5gC.png" alt="image-20220523141401716" style="zoom:67%;" />

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/2GnipTQcFz5Rul4.png" alt="image-20220523144320399"></p>
<p>y的值没有给定，所以输出一个不确定的值</p>
<h4 id="problem-6"><a href="#problem-6" class="headerlink" title="problem 6"></a>problem 6</h4><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p>
<h1 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h1><h3 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h3><p>确定内核初始化堆栈的位置，以及堆栈在内存中的确切位置。内核如何为其堆栈保留空间？堆栈指针初始化为指向该保留区域的哪一端？</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/2WT6iQGvJsgpR3a.png" alt="image-20220523172823907" style="zoom: 50%;" />

<p>bootstacktop是栈顶，地址为0xf0117000</p>
<p>mmu.h中</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/ZEQK9WBALjIfe3k.png" alt="image-20220523174049954" style="zoom:80%;" />

<p>memlayout.h</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/XgPc52kHWMnfwiD.png" alt="image-20220523174104956" style="zoom:67%;" />

<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/zl42JmAv5B7cjV1.png" alt="image-20220523174140644" style="zoom:67%;" />

<p>栈大小是32KB，栈顶指针存在esp，为 0xf0117000</p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/zahDgVRnyj6U9Od.png" alt="image-20220523174417402" style="zoom:67%;" />

<h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><p>要熟悉x86上的C调用约定，请在<strong>obj/kern/kernel.asm</strong>中找到<strong>test_backtrace</strong>函数的地址，在那里设置一个断点，并检查内核启动后每次调用它时会发生什么。test_backtrace的每个递归嵌套级别在堆栈上推送多少32位字，这些字是什么？</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/nZ2YagVsuP9FXSW.png" alt="image-20220528164332775"></p>
<p>给back_trace的test_backtrace(x-1); mon_backtrace(0, 0, 0);和 打上断点，    查看<code>esp</code>的初始值。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/MjnGhxmEktR2NWP.png" alt="image-20220528165206593"></p>
<p>初始x传入值为5，向后执行直至x=0</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/Dsg8NQlOAvY2otG.png" alt="image-20220528171319674"></p>
<p>中途查看esp内容，发现第二列保存的是x的值。每次递归会保存两行。每一列的意思是</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/WKwp2NxBIPHaAX8.png" alt="image-20220528210745786"></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/hxk1DYoTrZwpB2P.png" alt="image-20220528211308210"></p>
<p><strong>x86堆栈要倒着长，如果以为push以后esp会增加可就大错特错了。。ebp虽然叫栈底，但是永远大于等于栈顶</strong></p>
<p>0xf0100069应该是test_backtrace的下一条的返回地址。</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/e9OsqWFKYv81B76.png" alt="image-20220528180523233"></p>
<p>test_backtrace(5)的栈帧范围是：esp: 0xf0116fc0      ebp: 0xf0116fc8</p>
<p>test_backtrace(4):   esp: 0xf0116fa0      ebp: 0xf0116fa8</p>
<p>test_backtrace(3):   esp: 0xf0116f80      ebp: 0xf0116f88</p>
<p>test_backtrace(2):   esp: 0xf0116f60      ebp: 0xf0116f68</p>
<p>test_backtrace(1):   esp: 0xf0116f40      ebp: 0xf0116f48</p>
<p>next x           |       this x     |    don’t know  | don’t know  | </p>
<p>don’t know  |        last  x   |     last ebp       |  return addr|</p>
<h3 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h3><p>implement a stack backtrace function</p>
<p>The backtrace function should display a listing of function call frames in the following format:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span><br><span class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>Each line contains an <code>ebp</code>, <code>eip</code>, and <code>args</code>.</p>
<p>运行 <code>make grade</code> 这个评级脚本去查看它的输出是否是我们的脚本所期望的结果/。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C函数调用时，首先将参数push入栈，然后push返回地址，接着将原来的EBP push入栈，然后将ESP的值赋给EBP，令ESP指向新的栈顶。而函数返回时，会将EBP的值赋予ESP，然后pop出原来的EBP的值赋予EBP指针。</span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/SIWUp2ahfZOP4t8.png" alt="image-20220528223530430"></p>
<img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/bVInmrfcN6YsqjB.png" alt="image-20220528223513219" style="zoom:67%;" />

<h3 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h3><p>修改堆栈回溯函数以显示每个<code>eip</code>对应的函数名、源文件名和行<code>号</code>。</p>
<p>在<code>debuginfo_eip</code>中，<code>__STAB_*</code>来自哪里？这个问题有一个很长的答案；为了帮助您找到答案，以下是您可能想做的一些事情：</p>
<ul>
<li>look in the file <code>kern/kernel.ld</code> for <code>__STAB_*</code></li>
<li>run objdump -h obj/kern/kernel</li>
<li>run objdump -G obj/kern/kernel</li>
<li>run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s.</li>
<li>see if the bootloader loads the symbol table in memory as part of loading the kernel binary</li>
</ul>
<p>向内核监视器添加一个<code>backtrace </code>命令，并扩展您的实现<code>mon_backtrace</code>以调用<code>debuginfo_eip</code>并打印表单的每个堆栈帧的一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">K&gt; backtrace</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000</span><br><span class="line">         kern/monitor.c:143: monitor+106</span><br><span class="line">  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000</span><br><span class="line">         kern/init.c:49: i386_init+59</span><br><span class="line">  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff</span><br><span class="line">         kern/entry.S:70: &lt;unknown&gt;+0</span><br><span class="line">K&gt; </span><br></pre></td></tr></table></figure>

<p>Each line gives the file name and line within that file of the stack frame’s <code>eip</code>, followed by the name of the function and the offset of the <code>eip</code> from the first instruction of the function (e.g., <code>monitor+106</code> means the return <code>eip</code> is 106 bytes past the beginning of <code>monitor</code>).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Include debugging information in kernel memory */</span></span><br><span class="line">.stab : &#123;</span><br><span class="line">	PROVIDE(__STAB_BEGIN__ = .);</span><br><span class="line">	*(.stab);</span><br><span class="line">	PROVIDE(__STAB_END__ = .);</span><br><span class="line">	BYTE(<span class="number">0</span>)		<span class="comment">/* Force the linker to allocate space</span></span><br><span class="line"><span class="comment">			   for this section */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.stabstr : &#123;</span><br><span class="line">	PROVIDE(__STABSTR_BEGIN__ = .);</span><br><span class="line">	*(.stabstr);</span><br><span class="line">	PROVIDE(__STABSTR_END__ = .);</span><br><span class="line">	BYTE(<span class="number">0</span>)		<span class="comment">/* Force the linker to allocate space</span></span><br><span class="line"><span class="comment">			   for this section */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/WMQfEjbsJgDlU4S.png" alt="image-20220528230025894"></p>
<p>可以得到stab和 stabstr的起始地址和结束地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__STAB_BEGIN__ = 0xf0101f2c</span><br><span class="line">__STAB_END__ = 0xf0101f2c + 00004549 - 1</span><br><span class="line">__STABSTR_BEGIN__ = 0xf0106475</span><br><span class="line">__STABSTR_END__ = 0xf0106475 + 00008b11 - 1</span><br></pre></td></tr></table></figure>

<p>objdump -G obj/kern/kernel 列出所有stab的信息</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/wJ6T2spyFvP7DxI.png" alt="image-20220528230955470"></p>
<p>进入内核后打个断点，查看stabstr内的内容</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/FszN2t4h6bVH3nG.png" alt="image-20220528232511341"></p>
<p>使用<code>objdump -G obj/kern/kernel &gt; output.md</code>将内核的符号表信息输出到output.md文件</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/oLO9PpUryhDSVeE.png" alt="image-20220603142339089"></p>
<p>观察kernel.asm</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/9I7hWzcHuRLlPUs.png" alt="image-20220603142401904"></p>
<p>观察entry.S</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/Cv6OTo4a31SArkx.png" alt="image-20220603142437259"></p>
<p>可以看到，output.md 中的各个字段，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symnum   下标，整个符号表看作一个数组，Symnum是当前符号在数组中的下标</span><br><span class="line">n_type   符号类型，FUN指函数名，SLINE指在text段中的行号</span><br><span class="line">n_othr   不清楚</span><br><span class="line">n_desc   在文件中的行号</span><br><span class="line">n_value  表示地址</span><br><span class="line">n_strx   </span><br><span class="line">String   保存信息（函数、语句啥的）</span><br></pre></td></tr></table></figure>

<p>在查看<code>kdebug.c</code>时候发现函数的参数为<code>int</code>类型，但是传入是<code>N_FUN</code>，于是翻了一下<code>stab.h</code></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/U61vX4bqchRWj37.png" alt="image-20220603145602882"></p>
<p>修改monitor.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> ebp;</span><br><span class="line">    <span class="keyword">uint32_t</span>* eip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    ebp = read_ebp();</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="comment">// ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span></span><br><span class="line">    <span class="comment">// eip = *(uint32_t *(ebp + 4))</span></span><br><span class="line">    <span class="keyword">while</span>(ebp != <span class="number">0</span>)&#123;</span><br><span class="line">        eip = (<span class="keyword">uint32_t</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 08x   八位宽无符号16进制</span></span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>,</span><br><span class="line">                ebp, eip[<span class="number">0</span>], eip[<span class="number">1</span>], eip[<span class="number">2</span>], eip[<span class="number">3</span>], eip[<span class="number">4</span>], eip[<span class="number">5</span>]);</span><br><span class="line">        <span class="comment">// 打印行号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(debuginfo_eip(eip[<span class="number">0</span>], &amp;info)==<span class="number">0</span>)&#123;</span><br><span class="line">            cprintf(<span class="string">&quot;    %s:%d: %s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_name, eip[<span class="number">0</span>] - info.eip_fn_addr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取 ebp的 内容  返回</span></span><br><span class="line">        ebp = *((<span class="keyword">uint32_t</span> *) ebp);</span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/Ol4sxCRFyk765Z3.png" alt="image-20220603161956295"></p>
<p>可以看到后续多了<code>:F(0,15)</code></p>
<p>那么需要输出指定长度，以便把后面多余的字符删除。test_backtrace 和 i386_init 为函数名</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/ZtsXhU9qlTwdf5D.png" alt="image-20220603162303721"></p>
<p>使用<code>eip_fn_namelen</code>进行指定长度的输出</p>
<p>修改为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;    %s:%d: %.*s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, eip[<span class="number">0</span>] - info.eip_fn_addr);</span><br></pre></td></tr></table></figure>

<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/b5VjniJfOaTDpmW.png" alt="image-20220603162648588"></p>
<p>正常输出</p>
<p><code>make grade</code></p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/YsG4kSha2vADzR7.png" alt="image-20220603162723295"></p>
<h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><ol>
<li>启动顺序   bios-&gt;bootloader-&gt;kernel</li>
</ol>
<p>bios: </p>
<p>0x000FFFFF~0x0010 0000</p>
<p>bootloader:</p>
<p>sectorsize(扇区大小)是512</p>
<p><img src="https://zbdbcdb.oss-cn-hangzhou.aliyuncs.com/img/SQLMoxtWkUBPyHg.png" alt="image-20220603165727917"></p>
<p>0x7c00~0x7dff</p>
<p>BIOS找到一个可引导的软盘或硬盘，它将512字节的引导扇区加载到物理地址0x7c00到0x7dff的内存中，然后使用jmp指令将CS:IP设置为0000:7c00，将控制权传递给<strong>the boot loader</strong>。</p>
<p>kern  入口LMA为 00100000 被映射到虚拟地址（LMA）0xf0100000<br>kernel最先加载的就是 .text<br>所作操作：开启内存分页机制，启用虚拟内存，I/O的实现，栈的初始化。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/centos%E6%98%BE%E7%A4%BA%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/centos%E6%98%BE%E7%A4%BA%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/" class="post-title-link" itemprop="url">centos扩展root</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-16 10:37:17 / 修改时间：10:40:28" itemprop="dateCreated datePublished" datetime="2022-05-16T10:37:17+08:00">2022-05-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p><strong>仅作记录</strong></p>
<p>ref: <a target="_blank" rel="noopener" href="https://blog.csdn.net/twilight1999/article/details/123840372">https://blog.csdn.net/twilight1999/article/details/123840372</a></p>
<p><img src="https://s2.loli.net/2022/05/16/WQNqYGo94wDTb6u.png" alt="image-20220516103804877"></p>
<p><img src="https://s2.loli.net/2022/05/16/3YptBci6qogIjkK.png" alt="image-20220516103901544"></p>
<p><img src="https://s2.loli.net/2022/05/16/ZiD4djJs3ExIqQc.png" alt="image-20220516103912000"></p>
<p><img src="https://s2.loli.net/2022/05/16/D1CGQ3R4rNHlqEv.png" alt="image-20220516103928952"></p>
<p><img src="https://s2.loli.net/2022/05/16/OTRvL1cHmiQbU6C.png" alt="image-20220516103939013"></p>
<p><img src="https://s2.loli.net/2022/05/16/GjIwrRZcJvd79ha.png" alt="image-20220516103947750"></p>
<p><img src="https://s2.loli.net/2022/05/16/gkFC9wuDfep8rP5.png" alt="image-20220516104001619"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/14/MIT6.828%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/14/MIT6.828%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">MIT6.828</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-14 15:55:56" itemprop="dateCreated datePublished" datetime="2022-05-14T15:55:56+08:00">2022-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-17 11:59:55" itemprop="dateModified" datetime="2022-05-17T11:59:55+08:00">2022-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>环境配置是个大坑</p>
<p>直接按照课程教程</p>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/tools.html">https://pdos.csail.mit.edu/6.828/2017/tools.html</a></p>
<p>安装ubuntu（32位），我之前安装64，后来各种报错。<strong>ubuntu安装时，插上蓝牙键盘或鼠标设备有时也报错，显示cpu不兼容。</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kinvy/p/15074844.html">https://www.cnblogs.com/kinvy/p/15074844.html</a>     &lt;———-亲测有效</p>
<p><strong>复制过来仅作记录</strong></p>
<h3 id="1-测试编译工具"><a href="#1-测试编译工具" class="headerlink" title="1.测试编译工具"></a>1.测试编译工具</h3><p>shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -i</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727123132004.png"><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727123132004.png" alt="image-20210727123132004"></a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -m32 -print-libgcc-file-name 		<span class="comment">#测试gcc</span></span></span><br></pre></td></tr></table></figure>

<p>上面这条命令是测试gcc的，一般系统是没有gcc的，需要安装</p>
<p>安装gcc , gdb, git, vim</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt-get install -y build-essential gdb git vim</span></span><br></pre></td></tr></table></figure>

<p>安装32位的支持库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt-get install gcc-multilib</span></span><br></pre></td></tr></table></figure>

<h3 id="2-编译安装工具链"><a href="#2-编译安装工具链" class="headerlink" title="2. 编译安装工具链"></a>2. 编译安装工具链</h3><h4 id="2-1下载以下工具包"><a href="#2-1下载以下工具包" class="headerlink" title="2.1下载以下工具包"></a>2.1下载以下工具包</h4><ul>
<li><a href="ftp://ftp.gmplib.org/pub/gmp-5.0.2/gmp-5.0.2.tar.bz2">ftp://ftp.gmplib.org/pub/gmp-5.0.2/gmp-5.0.2.tar.bz2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2">https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</a></li>
<li><a target="_blank" rel="noopener" href="http://www.multiprecision.org/downloads/mpc-0.9.tar.gz">http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</a></li>
<li><a target="_blank" rel="noopener" href="http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2">http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</a></li>
<li><a target="_blank" rel="noopener" href="http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2">http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</a></li>
<li><a target="_blank" rel="noopener" href="http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2">http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</a></li>
</ul>
<p>第一个包可能下载不了，可以自己搜索，或是使用下面的链接</p>
<p><a target="_blank" rel="noopener" href="https://mirrors.sjtug.sjtu.edu.cn/gnu/gmp/gmp-5.0.2.tar.bz2">https://mirrors.sjtug.sjtu.edu.cn/gnu/gmp/gmp-5.0.2.tar.bz2</a></p>
<h4 id="2-2-编译安装"><a href="#2-2-编译安装" class="headerlink" title="2.2 编译安装"></a>2.2 编译安装</h4><p>为了方便，将以上6个压缩包放在一个文件夹下 ，<code>~/download/mit6.828</code></p>
<p>文件夹结构</p>
<p><a target="_blank" rel="noopener" href="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727131718755.png"><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727131718755.png" alt="image-20210727131718755"></a></p>
<blockquote>
<p>以下的操作都是在 <code>~/download/mit6.828</code> 目录下</p>
</blockquote>
<ol>
<li><p>安装gmp-5.0.2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf gmp-5.0.2.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> gmp-5.0.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span>   <span class="comment"># 可能的错误：No usable m4 in $PATH or /usr/5bin (see config.log for reasons).</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span>             </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure>

<p>逐条执行命令，每执行一条后，输出无 <code>error</code> 就可往下执行，后面几个安装包也是一样的</p>
<blockquote>
<p>可能的错误是第3个命令，如果报错，执行以下命令，然后再次执行第3行命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt install m4</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装mpfr-3.1.2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf mpfr-3.1.2.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> mpfr-3.1.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span>           </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装mpc-0.9</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xzf mpc-0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> mpc-0.9</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span>            </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装binutils-2.21.1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf binutils-2.21.1.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> binutils-2.21.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span> --target=i386-jos-elf --disable-werror</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install             <span class="comment"># This step may require privilege (sudo make install)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line"><span class="meta">$</span><span class="bash">i386-jos-elf-objdump -i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功安装会输出类似下面的信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> BFD header file version (GNU Binutils) 2.21.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> elf32-i386</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  (header little endian, data little endian)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   i386...</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装gcc-core-4.6.4</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf gcc-core-4.6.4.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> gcc-4.6.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir build</span>           </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash">../configure --prefix=/usr/<span class="built_in">local</span> \</span></span><br><span class="line"><span class="bash">    --target=i386-jos-elf --disable-werror \</span></span><br><span class="line"><span class="bash">    --disable-libssp --disable-libmudflap --with-newlib \</span></span><br><span class="line"><span class="bash">    --without-headers --enable-languages=c MAKEINFO=missing</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make all-gcc</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install-gcc</span>         </span><br><span class="line"><span class="meta">$</span><span class="bash">make all-target-libgcc		<span class="comment">#可能会报错 [configure-target-libgcc] Error 1</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install-target-libgcc</span>   </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ../..</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line"><span class="meta">$</span><span class="bash">i386-jos-elf-gcc -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功安装会输出类似下面的信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using built-in specs.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> COLLECT_GCC=i386-jos-elf-gcc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> COLLECT_LTO_WRAPPER=/usr/<span class="built_in">local</span>/libexec/gcc/i386-jos-elf/4.6.4/lto-wrapper</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Target: i386-jos-elf</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行11行命令可能会报错，如果报错，执行以下命令，然后再次执行第11行命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/lib</span> </span><br></pre></td></tr></table></figure></li>
<li><p>安装gdb-7.3.1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf gdb-7.3.1.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> gdb-7.3.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span> --target=i386-jos-elf --program-prefix=i386-jos-elf- \</span></span><br><span class="line"><span class="bash">    --disable-werror</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make all			<span class="comment">#可能的错误 no termcap library found</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span>         </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能报错的命令第5个，如果出现错误，执行以下命令，然后再执行该命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">wget http://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -zxv -f termcap-1.3.1.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> termcap-1.3.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure</span> </span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装-QEMU"><a href="#安装-QEMU" class="headerlink" title="安装 QEMU"></a>安装 QEMU</h2><h3 id="1-安装工具包"><a href="#1-安装工具包" class="headerlink" title="1. 安装工具包"></a>1. 安装工具包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt install libsdl1.2-dev libtool-bin libglib2.0-dev  libz-dev  libpixman-1-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo apt install python2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-下载qemu"><a href="#2-下载qemu" class="headerlink" title="2. 下载qemu"></a>2. 下载qemu</h3><p>qemu需要用6.828定制的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">git <span class="built_in">clone</span> https://github.com/mit-pdos/6.828-qemu.git qemu</span></span><br></pre></td></tr></table></figure>

<h3 id="3-编译安装"><a href="#3-编译安装" class="headerlink" title="3. 编译安装"></a>3. 编译安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./configure --disable-kvm --disable-werror --prefix=/usr/<span class="built_in">local</span>  --target-list=<span class="string">&quot;i386-softmmu x86_64-softmmu&quot;</span> --python=python2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span></span><br></pre></td></tr></table></figure>

<p>可能的错误：</p>
<ol>
<li><p>缺少一个头文件，错误如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qga/commands-posix.c: In function ‘dev_major_minor’:</span><br><span class="line">qga/commands-posix.c:633:13: error: In the GNU C Library, &quot;major&quot; is defined</span><br><span class="line"> by &lt;sys/sysmacros.h&gt;. For historical compatibility, it is</span><br><span class="line"> currently defined by &lt;sys/types.h&gt; as well, but we plan to</span><br><span class="line"> remove this soon. To use &quot;major&quot;, include &lt;sys/sysmacros.h&gt;</span><br><span class="line"> directly. If you did not intend to use a system-defined macro</span><br><span class="line"> &quot;major&quot;, you should undefine it after including &lt;sys/types.h&gt;. [-Werror]</span><br><span class="line">         *devmajor = major(st.st_rdev);</span><br><span class="line">             ^~~~~~~~~~~~~~~~~~~~~~~~~~   </span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决：在 qga/commands-posix.c文件中的 #include &lt;sys/types.h&gt; 下面增加#include &lt;sys/sysmacros.h&gt;即可</p>
</blockquote>
</li>
</ol>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载实验源码</span></span><br><span class="line"><span class="meta">$</span><span class="bash">git <span class="built_in">clone</span> https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> lab</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make qemu-nox</span></span><br></pre></td></tr></table></figure>

<p>测试成功</p>
<p><a target="_blank" rel="noopener" href="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727171159202.png"><img src="https://s2.loli.net/2022/05/16/GwcegZSjm3AsvRU.png" alt="image-20210727171159202"></a></p>
<h2 id="vscode连接ubuntu"><a href="#vscode连接ubuntu" class="headerlink" title="vscode连接ubuntu"></a>vscode连接ubuntu</h2><p>连接时一直显示失败，但是termius可以连接上</p>
<p>应该是vscode不支持此版本的ubuntu</p>
<p>换到clion后，可以使用</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/14/vsvode%E4%BD%BF%E7%94%A8ssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/14/vsvode%E4%BD%BF%E7%94%A8ssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/" class="post-title-link" itemprop="url">vsvode使用ssh远程连接linux</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-14 15:24:45 / 修改时间：15:25:31" itemprop="dateCreated datePublished" datetime="2022-05-14T15:24:45+08:00">2022-05-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1.找到自己电脑公钥C:<code>Users**用户名**.ssh</code>这个目录<br><code>id-rsa</code>和<code>id-rsa.pub</code>两个文件, 第一个是私钥文件,第二个是公钥文件</p>
<p>2.将公钥添加到远程linux系统中</p>
<p>sudo vim /root/.ssh/authorized_keys</p>
<p>:wq保存退出</p>
<p>3.启用秘钥方式登录</p>
<p>sudo vim /etc/ssh/sshd_config</p>
<p><code>PubkeyAuthentication</code> yes的注释去掉</p>
<p>:wq保存退出</p>
<p>4.检查ssh服务</p>
<p>sudo netstat -ntlp | grep ssh 如果有22端口说明已经启动，如果没有列出执行以下命令</p>
<p>/etc/init.d/ssh resart</p>
<p>5.配置vscode远程连接信息</p>
<p>  1.vscode安装Remote - SSH</p>
<p>  2.Remote Explorer里面选择SSH Targets</p>
<p>  3.选择+号添加连接信息， ssh <strong>user</strong>@<strong>ip</strong> -p 22, 其中user为远程电脑登录用户名，ip为远程电脑ip地址</p>
<p>  如果配置过程中出现 <strong>过程试图写入的管道不存在</strong>找到以下文件</p>
<p>  C:<code>Users**用户名**.sshconfig</code></p>
<p>``` 右键 属性-&gt;安全-&gt;高级-&gt;禁用继承/然后 添加-&gt;-&gt;高级-&gt;立即查找-&gt;选择你的用户名-&gt;添加上**修改**的权限`</p>
<p>`` 然后使用vscode再次连接，中间过程会弹出输入登录机器密码的对话框，输入即可</p>
<p>仅作记录</p>
<p>ref: <a target="_blank" rel="noopener" href="http://t.zoukankan.com/guanglin-p-14931464.html">http://t.zoukankan.com/guanglin-p-14931464.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
