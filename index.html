<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="我的一些记录">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="我的一些记录">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>我的一些记录</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">我的一些记录</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/28/6-828Lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/28/6-828Lab3/" class="post-title-link" itemprop="url">6.828Lab3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-28 22:15:45" itemprop="dateCreated datePublished" datetime="2022-06-28T22:15:45+08:00">2022-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-04 22:40:31" itemprop="dateModified" datetime="2022-07-04T22:40:31+08:00">2022-07-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="LAB3-User-Environments"><a href="#LAB3-User-Environments" class="headerlink" title="LAB3: User Environments"></a>LAB3: User Environments</h1><p>实验三中，you will implement the basic kernel facilities required to get a protected user-mode environment (i.e., “process”) running. 将实现运行受保护的<strong>用户模式环境（即进程）</strong>所需的基本内核功能。将增强JOS内核以设置数据结构来跟踪 用户环境、创建单个用户环境、将程序映像（program image）加载到其中并开始运行。还需要使得JOS内核能够处理用户环境进行的任何调用和解决它所造成的一切异常情况。</p>
<p> <strong>killall XXX杀掉所有的进程 kill xxx(PID)杀死进程号xxx的进程,查看所有运行进程的命令:ps -aux</strong></p>
<h1 id="Part-A-User-Environment-and-Expection-Handling"><a href="#Part-A-User-Environment-and-Expection-Handling" class="headerlink" title="Part A: User Environment and Expection Handling"></a>Part A: User Environment and Expection Handling</h1><p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220629161158698.png" alt="image-20220629161158698"></p>
<p>inc/env.h 查看最大进程个数NENV为1024</p>
<p>kern/env.c 全局变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// env指针指向一个由Env结构体组成的数组，同时，不活动的Env记录在env_free_list 中, 和之前的page_free_list很像</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">envs</span> =</span> <span class="literal">NULL</span>;      <span class="comment">// All environments</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">curenv</span> =</span> <span class="literal">NULL</span>;    <span class="comment">// The current env    curenv记录着现在正在运行的进程，在第一个进程运行之前为空</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_free_list</span>;</span>  <span class="comment">// Free environment list</span></span><br><span class="line">               <span class="comment">// (linked by Env-&gt;env_link)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENVGENSHIFT    12    <span class="comment">// &gt;= LOGNENV</span></span></span><br></pre></td></tr></table></figure>

<p>inc/enc.h 中查看Env结构体的具体信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>   <span class="comment">// Saved registers </span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span>     <span class="comment">// Next free Env</span></span><br><span class="line">   <span class="keyword">envid_t</span> env_id;          <span class="comment">// Unique environment identifier</span></span><br><span class="line">   <span class="keyword">envid_t</span> env_parent_id;    <span class="comment">// env_id of this env&#x27;s parent</span></span><br><span class="line">   <span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span>    <span class="comment">// Indicates special system environments</span></span><br><span class="line">   <span class="keyword">unsigned</span> env_status;      <span class="comment">// Status of the environment</span></span><br><span class="line">   <span class="keyword">uint32_t</span> env_runs;    <span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Address space</span></span><br><span class="line">   <span class="keyword">pde_t</span> *env_pgdir;     <span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>env_id  进程的身份标识。</p>
<p>env_status 进程的运行状态。</p>
<p>env_link 类似于PageInfo中的pp_link，用于创建空闲进程链表，若进程槽已分配，则置为NULL。</p>
<p>env_tf 是一个Trapframe型的结构体（Trapframe是指中断、自陷、异常进入内核后，在堆栈上形成的一种数据结构），用于登记进程运行时的寄存器信息。</p>
<p>env_pgdir 指向进程运行所用的页目录，即描述了进程的用户地址空间。</p>
<p><em><strong>在JOS中，进程的运行实体是线程，而env_tf描述的实际上是所说的之行线程。文档中说明：当进程不在运行状态时，env_tf保存了进程的寄存器信息，内核在硬件控制权由用户转到内核时保存这些信息，使得进程可以在之后恢复到它交出控制权时的状态。</strong></em></p>
<h2 id="Exercise-1-Allocating-the-Environments-Array"><a href="#Exercise-1-Allocating-the-Environments-Array" class="headerlink" title="Exercise 1: Allocating the Environments Array"></a>Exercise 1: Allocating the Environments Array</h2><p>修改 kern/pmap.c 中的 mem_init() 来分配和映射 envs 数组。这个数组完全由 ENEV(1024) 个结构体Env组成，与分配 pages 数组的方式非常相似。同时像 pages 数组一样， 在UENVS(定义在inc/memlayout.h)上的用户，内存也该被映射为只读，这样用户进程就可以从这个数组中读取数据。</p>
<p><strong>You should run your code and make sure <code>check_kern_pgdir()</code> succeeds.</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">mem_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> cr0;</span><br><span class="line">   <span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span></span><br><span class="line">   i386_detect_memory();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Remove this line when you&#x27;re ready to test this function.</span></span><br><span class="line">   <span class="comment">//panic(&quot;mem_init: This function is not finished\n&quot;);</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// create initial page directory.</span></span><br><span class="line">   kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">   <span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Recursively insert PD in itself as a page table, to form</span></span><br><span class="line">   <span class="comment">// a virtual page table at virtual address UVPT.</span></span><br><span class="line">   <span class="comment">// (For now, you don&#x27;t have understand the greater purpose of the</span></span><br><span class="line">   <span class="comment">// following line.)</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">   kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span></span><br><span class="line">   <span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line">   <span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line">   <span class="comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span></span><br><span class="line">   <span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line">   <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Make &#x27;envs&#x27; point to an array of size &#x27;NENV&#x27; of &#x27;struct Env&#x27;.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Now that we&#x27;ve allocated the initial kernel data structures, we set</span></span><br><span class="line">   <span class="comment">// up the list of free physical pages. Once we&#x27;ve done so, all further</span></span><br><span class="line">   <span class="comment">// memory management will go through the page_* functions. In</span></span><br><span class="line">   <span class="comment">// particular, we can now map memory using boot_map_region</span></span><br><span class="line">   <span class="comment">// or page_insert</span></span><br><span class="line">   page_init();</span><br><span class="line"></span><br><span class="line">   check_page_free_list(<span class="number">1</span>);</span><br><span class="line">   check_page_alloc();</span><br><span class="line">   check_page();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line">   <span class="comment">// Permissions:</span></span><br><span class="line">   <span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line">   <span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">   <span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line">   <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Map the &#x27;envs&#x27; array read-only by the user at linear address UENVS</span></span><br><span class="line">   <span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line">   <span class="comment">// Permissions:</span></span><br><span class="line">   <span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line">   <span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line">   <span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line">   <span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">   <span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line">   <span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line">   <span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line">   <span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line">   <span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line">   <span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">   <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line">   <span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line">   <span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line">   <span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line">   <span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line">   <span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line">   <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Check that the initial page directory has been set up correctly.</span></span><br><span class="line">   check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Switch from the minimal entry page directory to the full kern_pgdir</span></span><br><span class="line">   <span class="comment">// page table we just created. Our instruction pointer should be</span></span><br><span class="line">   <span class="comment">// somewhere between KERNBASE and KERNBASE+4MB right now, which is</span></span><br><span class="line">   <span class="comment">// mapped the same way by both page tables.</span></span><br><span class="line">   <span class="comment">//</span></span><br><span class="line">   <span class="comment">// If the machine reboots at this point, you&#x27;ve probably set up your</span></span><br><span class="line">   <span class="comment">// kern_pgdir wrong.</span></span><br><span class="line">   lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">   check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// entry.S set the really important flags in cr0 (including enabling</span></span><br><span class="line">   <span class="comment">// paging).  Here we configure the rest of the flags that we care about.</span></span><br><span class="line">   cr0 = rcr0();</span><br><span class="line">   cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;</span><br><span class="line">   cr0 &amp;= ~(CR0_TS|CR0_EM);</span><br><span class="line">   lcr0(cr0);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Some more checks, only possible after kern_pgdir is installed.</span></span><br><span class="line">   check_page_installed_pgdir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span></span><br><span class="line">    i386_detect_memory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove this line when you&#x27;re ready to test this function.</span></span><br><span class="line">    <span class="comment">// panic(&quot;mem_init: This function is not finished\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// create initial page directory.</span></span><br><span class="line">    kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">    <span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Recursively insert PD in itself as a page table, to form</span></span><br><span class="line">    <span class="comment">// a virtual page table at virtual address UVPT.</span></span><br><span class="line">    <span class="comment">// (For now, you don&#x27;t have understand the greater purpose of the</span></span><br><span class="line">    <span class="comment">// following line.)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span></span><br><span class="line">    <span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line">    <span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line">    <span class="comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span></span><br><span class="line">    <span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// 创建一个struct PageInfo 的数组</span></span><br><span class="line">    <span class="comment">// kernel 使用这个数组来耿总每个物理页</span></span><br><span class="line">    <span class="comment">// 对于每一个物理页，都会有一个对应的 struct PageInfo 在数组中</span></span><br><span class="line">    pages = (struct PageInfo *) boot_alloc(npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line">    <span class="comment">// npages 是内存中物理页的数量</span></span><br><span class="line">    <span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Now that we&#x27;ve allocated the initial kernel data structures, we set</span></span><br><span class="line">    <span class="comment">// up the list of free physical pages. Once we&#x27;ve done so, all further</span></span><br><span class="line">    <span class="comment">// memory management will go through the page_* functions. In</span></span><br><span class="line">    <span class="comment">// particular, we can now map memory using boot_map_region</span></span><br><span class="line">    <span class="comment">// or page_insert</span></span><br><span class="line">    page_init();</span><br><span class="line"></span><br><span class="line">    check_page_free_list(<span class="number">1</span>);</span><br><span class="line">    check_page_alloc();</span><br><span class="line">    check_page();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line">    <span class="comment">// Permissions:</span></span><br><span class="line">    <span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line">    <span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">    <span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// UPAGES是JOS记录物理页面使用情况的数据结构，只有kernel能够访问</span></span><br><span class="line">    <span class="comment">// 为了使用户空间能访问这块数据结构，会将PAGES映射到UPAGES的位置</span></span><br><span class="line">    <span class="comment">// 但是现在需要让用户空间能够读取这段线性地址，因此需要建立映射，将用户空间的一块内存映射到存储该数据结构的物理地址上</span></span><br><span class="line">    <span class="comment">// boot_map_region() 建立映射关系</span></span><br><span class="line">    boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)UPAGES, npages*<span class="keyword">sizeof</span>(struct PageInfo), PADDR(pages), PTE_U | PTE_P);</span><br><span class="line">    <span class="comment">// 目前建立了一个页目录，kernel_pgdir</span></span><br><span class="line">    <span class="comment">// pgdir为页目录指针， UPAGES为虚拟地址，npages*sizeof(struct* PageInfo)为映射的内存块大小</span></span><br><span class="line">    <span class="comment">// PADDR(pages) 为物理地址， PTE_U | PTE为权限 (PTE_U 表示用户可读)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line">    <span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line">    <span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">    <span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line">    <span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line">    <span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line">    <span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line">    <span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line">    <span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// kernel  内核栈</span></span><br><span class="line">    <span class="comment">// kernel stack 从虚拟地址 KSTACKTOP 开始，向低地址增长，所以KSTACKTOP实际上是栈顶</span></span><br><span class="line">    <span class="comment">// KSTACKTOP = 0xf0000000，</span></span><br><span class="line">    <span class="comment">// KSTKSIZE = (8*PGSIZE) = 8*4096(bytes) = 32KB</span></span><br><span class="line">    <span class="comment">// 只需要映射 [KSTACKTOP, KSTACKTOP - KSTKSIZE) 范围的虚拟地址</span></span><br><span class="line">    boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)(KSTACKTOP - KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);</span><br><span class="line">    <span class="comment">// PTE_W 开启了写权限，但是并未打开 PTE_U， 因此用户没有权限，只有内核有权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line">    <span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line">    <span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line">    <span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line">    <span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line">    <span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// 内核部分</span></span><br><span class="line">    <span class="comment">// KERNBASE    = 0xF0000000， VA大小为 2^32 - KERNBASE</span></span><br><span class="line">    <span class="comment">// ROUNDUP(a,n) 将a四舍五入到最接近n的倍数</span></span><br><span class="line">    boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)KERNBASE, ROUNDUP(<span class="number">0xffffffff</span> - KERNBASE + <span class="number">1</span>, PGSIZE), <span class="number">0</span>, PTE_W | PTE_P);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the initial page directory has been set up correctly.</span></span><br><span class="line">    check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch from the minimal entry page directory to the full kern_pgdir</span></span><br><span class="line">    <span class="comment">// page table we just created. Our instruction pointer should be</span></span><br><span class="line">    <span class="comment">// somewhere between KERNBASE and KERNBASE+4MB right now, which is</span></span><br><span class="line">    <span class="comment">// mapped the same way by both page tables.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the machine reboots at this point, you&#x27;ve probably set up your</span></span><br><span class="line">    <span class="comment">// kern_pgdir wrong.</span></span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">    check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// entry.S set the really important flags in cr0 (including enabling</span></span><br><span class="line">    <span class="comment">// paging).  Here we configure the rest of the flags that we care about.</span></span><br><span class="line">    cr0 = rcr0();</span><br><span class="line">    cr0 |= CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_MP;</span><br><span class="line">    cr0 &amp;= ~(CR0_TS | CR0_EM);</span><br><span class="line">    lcr0(cr0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some more checks, only possible after kern_pgdir is installed.</span></span><br><span class="line">    check_page_installed_pgdir();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="Exercise-2-Creating-and-Running-Environments"><a href="#Exercise-2-Creating-and-Running-Environments" class="headerlink" title="Exercise 2: Creating and Running Environments"></a>Exercise 2: Creating and Running Environments</h2><p>You will now write the code in <code>kern/env.c</code> necessary to run a user environment. Because we do not yet have a filesystem, we will set up the kernel to load a static binary image that is <em>embedded within the kernel itself</em>. <strong>JOS embeds this binary in the kernel as a ELF executable image.</strong></p>
<p>In <code>i386_init()</code> in <code>kern/init.c</code> you’ll see code to run one of these binary images in an environment. However, the critical functions to set up user environments are not complete; you will need to fill them in.</p>
<p><strong>在kern/env.c中，补充完成以下函数</strong></p>
<p><strong>env_init()</strong></p>
<p>​    初始化 envs 数组中所有的结构体 Env，并把它们添加到env_free_list。</p>
<p>​    调用 env_init_percpu，它为 privilege level 0(kernel)  和  privilege level 3(user) 配置特定的段。</p>
<p><strong>env_steup_vm()</strong></p>
<p>​    为新环境分配一个页目录，并且初始化新环境地址空间的内核部分。</p>
<p><strong>region_alloc()</strong></p>
<p>​    为环境分配和映射物理内存。</p>
<p><strong>load_icode()</strong></p>
<p>​    您需要解析ELF二进制映像，就像引导加载程序已经做的那样，并将其内容加载到新环境的用户地址空间中。</p>
<p><strong>env_create()</strong></p>
<p>​    使用env_alloc分配一个环境，并调用load_icode将ELF二进制文件加载到其中。</p>
<p><strong>env_run()</strong></p>
<p>​    启动以用户模式运行的给定环境。</p>
<p>As you write these functions, you might find the new cprintf verb <code>%e</code> useful – it prints a description corresponding to an error code. For example,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = -E_NO_MEM;</span><br><span class="line">panic(&quot;env_alloc: %e&quot;, r);</span><br></pre></td></tr></table></figure>

<p>will panic with the message “env_alloc: out of memory”.</p>
<p>Below is a call graph of the code up to the point where the user code is invoked. Make sure you understand the purpose of each step.</p>
<ul>
<li>start (kern/entry.S)</li>
<li>i386_init (kern/init.c)<ul>
<li>cons_init</li>
<li>mem_initenv_init</li>
<li>trap_init (still incomplete at this point)</li>
<li>env_create</li>
<li>env_run<ul>
<li>env_pop_tf</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>boot.S中通过ljmp跳转指令使cs的索引值指向代码段描述符，并将选择子ds、es、fs、gs和ss的索引值均设置为指向数据段描述符，至此这些段选择子均不曾被更改过。现在我们要创建进程，而原先的GDT中并没有特权级为3的数据段和代码段描述符，所以我们必须加载一个新的GDT。env_init_percpu重新加载了GDT，并设置了各个段选择子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">truct Segdesc gdt[] =</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 0x0 - unused (always faults -- for trapping NULL far pointers)</span></span><br><span class="line">   SEG_NULL,</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x8 - kernel code segment</span></span><br><span class="line">   [GD_KT &gt;&gt; <span class="number">3</span>] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x10 - kernel data segment</span></span><br><span class="line">   [GD_KD &gt;&gt; <span class="number">3</span>] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x18 - user code segment</span></span><br><span class="line">   [GD_UT &gt;&gt; <span class="number">3</span>] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>, <span class="number">3</span>),</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x20 - user data segment</span></span><br><span class="line">   [GD_UD &gt;&gt; <span class="number">3</span>] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>, <span class="number">3</span>),</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 0x28 - tss, initialized in trap_init_percpu()</span></span><br><span class="line">   [GD_TSS0 &gt;&gt; <span class="number">3</span>] = SEG_NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pseudodesc</span> <span class="title">gdt_pd</span> =</span> &#123;</span><br><span class="line">   <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) gdt</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220701172502082.png" alt="image-20220701172502082"></p>
<p><strong>env_init()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up envs array</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// 初始化 envs 数组中所有的结构体 Env，添加到env_free_list</span></span><br><span class="line">    <span class="keyword">int</span> i = NENV;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        i--;</span><br><span class="line">        envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">        envs[i].env_link = env_free_list;</span><br><span class="line">        env_free_list = &amp;envs[i];</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();  <span class="comment">// 重新加载</span></span><br></pre></td></tr></table></figure>

<p><strong>env_steup_vm()</strong></p>
<p>为新环境分配一个页目录，并且初始化新环境地址空间的内核部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">env_setup_vm</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))  <span class="comment">// 给p分配个 页目录</span></span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//    - The VA space of all envs is identical above UTOP</span></span><br><span class="line">	<span class="comment">//	(except at UVPT, which we&#x27;ve set below).</span></span><br><span class="line">	<span class="comment">//	See inc/memlayout.h for permissions and layout.</span></span><br><span class="line">	<span class="comment">//	Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line">	<span class="comment">//	(Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line">	<span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line">	<span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line">	<span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line">	<span class="comment">//	physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line">	<span class="comment">//	is an exception -- you need to increment env_pgdir&#x27;s</span></span><br><span class="line">	<span class="comment">//	pp_ref for env_free to work correctly.</span></span><br><span class="line">	<span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// env_setup_vm负责创建进程自己的页目录，并初始化内核地址空间。</span></span><br><span class="line">    <span class="comment">// 它不需要为内核地址空间另外创建页表，只要先将内核页目录kern_pgdir的所有目录项复制过来即可，以后再设置用户地址空间。</span></span><br><span class="line">    <span class="comment">// // pde_t *env_pgdir;		// Kernel virtual address of page dir</span></span><br><span class="line">    e-&gt;env_pgdir = page2kva(p);</span><br><span class="line">    <span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line">    p-&gt;pp_ref++;  <span class="comment">// p此时指向了页目录</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// UVPT maps the env&#x27;s own page table read-only.</span></span><br><span class="line">	<span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line">    <span class="comment">// PDX()   page directory index   NPDENTRIES	1024</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>region_alloc()</strong></p>
<p>为环境env分配 len 字节的物理内存，并将其映射到环境地址空间中的虚拟地址va。不以任何方式将映射页归零或初始化。页面应该是用户和内核可写的。Panic if any allocation attempt fails.</p>
<p>region_alloc为一个进程分配指定长度的内存空间，并按指定的起始线性地址映射到分配的物理内存上。该函数只在加载用户程序到内存中时（目前通过load_icode）才被用到，分配用户栈的工作将交给load_icode完成。我们会用到lab2中实现的page_alloc和page_insert分别完成物理页的分配与映射。我们不需要对被分配的物理页进行初始化，物理页的权限将被设置为内核和用户都可读写，va和va+len需要设置为页对齐（corner-case应该是当分配的地址超过UTOP时，这里直接panic）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">region_alloc</span><span class="params">(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line">    <span class="comment">//   &#x27;va&#x27; and &#x27;len&#x27; values that are not page-aligned.</span></span><br><span class="line">    <span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line">    <span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> va_start = ROUNDDOWN((<span class="keyword">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">    <span class="keyword">uintptr_t</span> va_end = ROUNDUP((<span class="keyword">uintptr_t</span>)va + len, PGSIZE);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pginfo</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cur_va = va_start;cur_va&lt;va_end;cur_va+=PGSIZE)&#123;</span><br><span class="line">        pginfo = page_alloc(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!pginfo)&#123;</span><br><span class="line">            panic(<span class="string">&quot;region_alloc: pageinfo failed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">&quot;insert page at %08x\n.&quot;</span>, cur_va);</span><br><span class="line">        page_insert(e-&gt;env_pgdir, pginfo, (<span class="keyword">void</span>*)cur_va, PTE_U | PTE_W | PTE_P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>load_icode()</strong></p>
<p>由于我们还没有实现文件系统，甚至连磁盘都没有，所以当然不可能从磁盘上加载一个用户程序到内存中。因此，我们暂时将ELF可执行文件嵌入内核，并从内存中加载这样的ELF文件，以此模拟从磁盘加载用户程序的过程。lab3 GNUmakefile负责设置将这样的ELF可执行文件直接嵌入内核</p>
<p><u>Hint:</u></p>
<p>在ELF段头指定的地址处把每个程序段加载到虚拟内存中。</p>
<p>你应该只加载 <code>ph-&gt;p_type == ELF_PROG_LOAD</code> 的段。</p>
<p>每个段的虚拟地址可以使用 <code>ph-&gt;p_va</code> 得到，同时它在内存中的大小可通过<code>ph-&gt;memsz</code>得到。</p>
<p>The <code>ph-&gt;p_filesz</code> bytes from the ELF binary, starting at <code>binary + ph-&gt;p_offset</code>, should be copied to virtual address  <code>ph-&gt;p_va</code>. </p>
<p>ELF头应该有 <code>ph-&gt;p_filesz &lt;= ph-&gt;p_memsz</code>.</p>
<p>所有的页面是用户可读/写的。</p>
<p>ELF段不一定是页面对齐的，但是你可以假设这个函数中没有两个段会接触同一个虚拟页面。</p>
<p>您还必须对程序的入口点做一些操作，以确保环境从那里开始执行。</p>
<p>怎么切换页目录？<br>lcr3([页目录物理地址]) 将地址加载到 cr3 寄存器。</p>
<p>怎么更改函数入口？<br>将 <code>env-&gt;env_tf.tf_eip</code> 设置为 <code>elf-&gt;e_entry</code>，等待之后的 <code>env_pop_tf()</code> 调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">load_icode</span><span class="params">(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//  Load each program segment into virtual memory</span></span><br><span class="line">	<span class="comment">//  at the address specified in the ELF segment header.</span></span><br><span class="line">	<span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></span><br><span class="line">	<span class="comment">//  Each segment&#x27;s virtual address can be found in ph-&gt;p_va</span></span><br><span class="line">	<span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></span><br><span class="line">	<span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></span><br><span class="line">	<span class="comment">//  &#x27;binary + ph-&gt;p_offset&#x27;, should be copied to virtual address</span></span><br><span class="line">	<span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span></span><br><span class="line">	<span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></span><br><span class="line">	<span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  All page protection bits should be user read/write for now.</span></span><br><span class="line">	<span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></span><br><span class="line">	<span class="comment">//  assume for this function that no two segments will touch</span></span><br><span class="line">	<span class="comment">//  the same virtual page.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You may find a function like region_alloc useful.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  Loading the segments is much simpler if you can move data</span></span><br><span class="line">	<span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></span><br><span class="line">	<span class="comment">//  So which page directory should be in force during</span></span><br><span class="line">	<span class="comment">//  this function?</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You must also do something with the program&#x27;s entry point,</span></span><br><span class="line">	<span class="comment">//  to make sure that the environment starts executing there.</span></span><br><span class="line">	<span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> *<span class="title">elf_hdr</span> =</span> (struct Elf *)binary;   <span class="comment">// ELF头// 准备对二进制ELF文件进行操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span>   <span class="comment">// 程序头</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(elf_hdr-&gt;e_magic != ELF_MAGIC)&#123;</span><br><span class="line">        panic(<span class="string">&quot;load_icode: invalid ELF binary.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ph = (struct Proghdr*)(binary + elf_hdr-&gt;e_phoff);  <span class="comment">// 加上偏移量</span></span><br><span class="line">    eph = ph+elf_hdr-&gt;e_phnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换页目录</span></span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));  <span class="comment">// lcr3() to switch to its address space.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;ph&lt;eph;ph++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;  <span class="comment">// 满足ELF的条件</span></span><br><span class="line">            <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">                panic(<span class="string">&quot;load_icode: file size is greater than memory size&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            region_alloc(e, (<span class="keyword">void</span>*)ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">            <span class="built_in">memcpy</span>((<span class="keyword">void</span>*)ph-&gt;p_va, binary+ph-&gt;p_offset, ph-&gt;p_filesz);    <span class="comment">// 拷贝文件内容</span></span><br><span class="line">            <span class="built_in">memset</span>((<span class="keyword">void</span>*)ph-&gt;p_va + ph-&gt;p_filesz, <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;env_tf.tf_eip = elf_hdr-&gt;e_entry; <span class="comment">// 切换入口</span></span><br><span class="line">	<span class="comment">// Now map one page for the program&#x27;s initial stack</span></span><br><span class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line">    <span class="comment">// 现在映射一个页面为程序的初始堆栈在虚拟地址USTACKTOP - PGSIZE.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    region_alloc(e,(<span class="keyword">void</span>*)USTACKTOP - PGSIZE, PGSIZE);</span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>env_create()</strong><br>作用是新建一个进程。调用已经写好的 env_alloc() 函数即可，之后更改类型并且利用 load_icode() 读取 ELF。</p>
<p>这里的进程即环境.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用是新建一个进程。</span></span><br><span class="line"><span class="comment">// 调用已经写好的 env_alloc() 函数即可，之后更改类型并且利用 load_icode() 读取 ELF。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">env_create</span><span class="params">(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span>   <span class="comment">// 新建一个进程</span></span><br><span class="line">    <span class="keyword">int</span> r = env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(r&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;env_create: env alloc error.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配成功</span></span><br><span class="line">    e-&gt;env_type = ENV_TYPE_USER;</span><br><span class="line">    load_icode(e, binary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>env_run()</strong></p>
<p>​    启动以用户模式运行的给定环境。</p>
<p>//步骤1:如果这是一个上下文切换(一个新的环境正在运行):</p>
<p>/ / 1。设置当前环境(如果有的话)回ENV_RUNNABLE如果它是ENV_RUNNING(想想它可以处于什么其他状态)，</p>
<p>/ / 2。将’curenv’设置为新环境，</p>
<p>/ / 3。设置它的状态为ENV_RUNNING，更新env_status</p>
<p>/ / 4。更新它的’env_runs’计数器，</p>
<p>/ / 5。使用lcr3()切换到它的地址空间。</p>
<p>//步骤2:使用env_pop_tf()恢复环境的寄存器，并在环境中进入用户模式。</p>
<p>//Hint: 这个函数从<code>e-&gt;env_tf</code>加载新环境的状态。返回前面编写的代码，确保将e-&gt;env_tf的相关部分设置为合理的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">env_run</span><span class="params">(struct Env *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Hint: This function loads the new environment&#x27;s state from</span></span><br><span class="line">   <span class="comment">// e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line">   <span class="comment">// and make sure you have set the relevant parts of</span></span><br><span class="line">   <span class="comment">// e-&gt;env_tf to sensible values.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// struct Env *curenv 记录着当前正在运行的进程</span></span><br><span class="line">    <span class="keyword">if</span>(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    curenv = e;</span><br><span class="line">    e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">    e-&gt;env_runs++;</span><br><span class="line">    lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">    env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// panic(&quot;env_run not yet implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Exercise-3-Handling-Interrupts-and-Exceptions"><a href="#Exercise-3-Handling-Interrupts-and-Exceptions" class="headerlink" title="Exercise 3: Handling Interrupts and Exceptions"></a>Exercise 3: Handling Interrupts and Exceptions</h2><p>用户空间中的第一个<code>int $0x30</code>系统调用指令是一个死胡同:一旦处理器进入用户模式，就没有办法返回。现在需要实现基本的异常和系统调用处理，以便内核能够从用户模式代码中恢复对处理器的控制。您应该做的第一件事是彻底熟悉x86中断和异常机制。</p>
<p>Read <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/c09.htm">Chapter 9, Exceptions and Interrupts</a> in the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/readings/i386/toc.htm">80386 Programmer’s Manual</a> (or Chapter 5 of the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/readings/ia32/IA32-3A.pdf">IA-32 Developer’s Manual</a>), if you haven’t already.</p>
<p>根据xv6讲义，一共有三种必须<strong>将控制由用户程序转移到内核</strong>的情形：系统调用、异常和中断。</p>
<p><strong>系统调用</strong>发生在用户程序请求一项操作系统的服务时。</p>
<p><strong>异常</strong>发生在用户程序想要执行某种非法的操作时，如除以零或者访问不存在的页表项。</p>
<p><strong>中断</strong>发生在某个外部设备需要操作系统的留意时，比如时钟芯片会定时产生一个中断提醒操作系统可以将硬件资源切换给下一个进程使用一会儿了。</p>
<p>在大多数处理器上，这三种情形都是由同一种硬件机制来处理的。对于x86，系统调用和异常本质上也是生成一个中断，因此操作系统只需要提供一套针对中断的处理策略就可以了。</p>
<p>操作系统处理中断时要用到<strong>中断描述符表IDT</strong>和<strong>程序状态段TSS</strong></p>
<ol>
<li><strong>中断描述符表IDT (interrupt descriptor table)</strong></li>
</ol>
<p>​        x86最多支持256个不同中断和异常的条目，每个包含一个中断向量，是一个0～255之间的数字，代表中断来源：不同的设备及类型错误。</p>
<p>​        IDT使得系统调用、异常和中断都只能经由被内核定义的入口进入正确的中断处理程序。每一个中断处理程序都对应一个中断向量或中断号，处理器接收中断号后，会以它作为索引值从IDT中找到对应的中断描述符。接着，处理器从描述符中取出定位中断处理程序要用到的 <strong>eip(指令指针寄存器)</strong> 和 <strong>cs(代码段寄存器)</strong> 的值。</p>
<p>EIP中的值指向内核中处理这类异常的代码。 Extend Instruction Pointer</p>
<p>CS中的最低两位表示优先级，因此寻址空间少两位 . </p>
<p>在JOS中，所有异常都在内核模式处理，优先级为0(用户模式为3)</p>
<ol start="2">
<li><strong>任务状态段 (Task State Segment, TSS)</strong></li>
</ol>
<p>​    处理器需要保存中断和异常出现时的自身状态，例如EIP和CS，以便处理完后能返回原函数继续执行。但是存储区域必须禁止用户访问，避免恶意代码或bug的破坏。</p>
<p>​    因此，当x86处理器处理从用户态到内核态的模式转换时，也会切换到内核栈。而<strong>TSS</strong>指明段选择器和栈地址，处理器将SS, ESP, EFLAGS, CS, EIP压入新栈，然后从IDT读取EIP和CS，根据新栈设置ESP和SS。</p>
<p><strong>SS是堆栈段寄存器。它指向将用于堆栈的内存的一般区域。</strong> </p>
<p><strong>ESP是堆栈指针寄存器。它指向在存储器的“堆栈段”区域内的堆栈“顶部”的任何给定点处的精确位置。</strong></p>
<p><strong>EFLAGS标志寄存器。</strong></p>
<p>JOS仅利用TSS来定义需要切换的内核栈。由于内核模式在JOS优先级是0，因此处理器用TSS的ESP0和SS0来定义内核栈，无需TSS结构体中的其他内容。其中，SS0中存储的是GD_KD</p>
<p>  <code>#define GD_KD     0x10     // kernel data</code> </p>
<p>ESP0中存储的是KSTACKTOP </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define KSTACKTOP   KERNBASE</span><br><span class="line">#define KERNBASE   0xF0000000</span><br></pre></td></tr></table></figure>



<p>在x86体系中，中断向量范围为0-255（vector number），最多表示256个异常或者中断，用一个8位的无符号整数表示，前32个vector为处理器保留用作异常处理。</p>
<p>32-255被指定为用户定义的中断，并且不由处理器保留。这些vector通常分配给外部I/O设备，以便这些设备能够向处理器发送中断。</p>
<p><strong>一个例子</strong></p>
<p>通过一个例子来理解上面的知识。假设处理器正在执行用户环境的代码，遇到了”除0”异常。</p>
<ol>
<li><p>处理器切换到内核栈，利用了上文 TSS 中的 ESP0 和 SS0。</p>
</li>
<li><p>处理器将异常参数 push 到了内核栈。一般情况下，按顺序 push <code>SS, ESP, EFLAGS, CS, EIP</code><br>+——————–+ KSTACKTOP<br>| 0x00000 | old SS | “ - 4<br>| old ESP | “ - 8<br>| old EFLAGS | “ - 12<br>| 0x00000 | old CS | “ - 16<br>| old EIP | “ - 20 &lt;—- ESP<br>+——————–+<br>存储这些寄存器状态的意义是：SS(堆栈选择器) 的低 16 位与 ESP 共同确定当前栈状态；EFLAGS(标志寄存器)存储当前FLAG；CS(代码段寄存器) 和 EIP(指令指针寄存器) 确定了当前即将执行的代码地址，E 代表”扩展”至32位。根据这些信息，就能保证处理中断结束后能够恢复到中断前的状态。</p>
</li>
<li><p>因为我们将处理一个”除0”异常，其对应中断向量是0，因此，处理器读取 IDT 的条目0，设置 <code>CS:EIP</code> 指向该条目对应的处理函数。</p>
</li>
<li><p>处理函数获得程序控制权并且处理该异常。例如，终止进程的运行。</p>
</li>
</ol>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220703163747621.png" alt="image-20220703163747621"></p>
<p>ref：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f67034d0c3f2">https://www.jianshu.com/p/f67034d0c3f2</a></p>
<p><strong>嵌套的异常和中断</strong></p>
<p>内核和用户进程都会引起异常和中断。然而，仅在从用户环境进入内核时才会切换栈。如果中断发生时已经在内核态了(此时， <code>CS</code> 寄存器的低 2bit 为 <code>00</code>) ，那么 CPU 就直接将状态压入内核栈，不再需要切换栈。这样，内核就能处理内核自身引起的”嵌套异常”，这是实现保护的重要工具。<br>如果处理器已经处于内核态，然后发生了嵌套异常，由于它并不进行栈切换，所以无须存储 <code>SS</code> 和 <code>ESP</code> 寄存器状态。对于不包含 error code 的异常，在进入处理函数前内核栈状态如下所示：</p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220703163920093.png" alt="image-20220703163920093"></p>
<p>对于包含了 error code 的异常，则将 error code 继续 push 到 <code>EIP</code>之后。<br>警告：如果 CPU 处理嵌套异常的时候，无法将状态 push 到内核栈（由于栈空间不足等原因），则 CPU 无法恢复当前状态，只能重启。当然，这是内核设计中必须避免的。</p>
<p>头文件 <code>inc/trap.h</code> 和 <code>kern/trap.h</code> 包含了与中断和异常相关的定义，需要仔细阅读。其中 <code>kern/trap.h</code> 包含内核私有定义，而 <code>inc/trap.h</code> 包含对内核以及用户进程和库都有用的定义。<br>每个异常和中断都应该在 <code>trapentry.S</code> 和 <code>trap_init()</code> 有自己的处理函数，并在 IDT 中将这些处理函数的地址初始化。每个处理函数都需要在栈上新建一个 <code>struct Trapframe</code>（见 <code>inc/trap.h</code>)，以其地址为参数调用 <code>trap()</code> 函数，然后进行异常处理。</p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220703165253213.png" alt="image-20220703165253213"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0xf0103734 &lt;env_pop_tf+15&gt;:  iret   </span><br><span class="line">0xf0103734      486             asm volatile(</span><br><span class="line">(gdb) info registers</span><br><span class="line">eax            0x0      0</span><br><span class="line">ecx            0x0      0</span><br><span class="line">edx            0x0      0</span><br><span class="line">ebx            0x0      0</span><br><span class="line">esp            0xf0224030       0xf0224030</span><br><span class="line">ebp            0x0      0x0</span><br><span class="line">esi            0x0      0</span><br><span class="line">edi            0x0      0</span><br><span class="line">eip            0xf0103734       0xf0103734 &lt;env_pop_tf+15&gt;</span><br><span class="line">eflags         0x96     [ PF AF SF ]</span><br><span class="line">cs             0x8      8</span><br><span class="line">ss             0x10     16</span><br><span class="line">ds             0x23     35</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">es             0x23     35</span><br><span class="line">fs             0x23     35</span><br><span class="line">gs             0x23     35</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x800020:    cmp    $0xeebfe000,%esp</span><br><span class="line">0x00800020 in ?? ()</span><br><span class="line">(gdb) info registers</span><br><span class="line">eax            0x0      0</span><br><span class="line">ecx            0x0      0</span><br><span class="line">edx            0x0      0</span><br><span class="line">ebx            0x0      0</span><br><span class="line">esp            0xeebfe000       0xeebfe000</span><br><span class="line">ebp            0x0      0x0</span><br><span class="line">esi            0x0      0</span><br><span class="line">edi            0x0      0</span><br><span class="line">eip            0x800020 0x800020</span><br><span class="line">eflags         0x2      [ ]</span><br><span class="line">cs             0x1b     27</span><br><span class="line">ss             0x23     35</span><br><span class="line">ds             0x23     35</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">es             0x23     35</span><br><span class="line">fs             0x23     35</span><br><span class="line">gs             0x23     35</span><br></pre></td></tr></table></figure>

<p>可以看到<code>=&gt; 0x800020:    cmp    $0xeebfe000,%esp</code>时，进入了用户态，因为cs的值变为了<code>GD_UT | 0X3 = 0x1b</code>，esp的值为USTACKTOP的值<code>0xeebfe000</code></p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704103409165.png" alt="image-20220704103409165"></p>
<p><strong>Exercise 4.</strong> Edit <code>trapentry.S</code> and <code>trap.c</code> and implement the features described above. The macros <code>TRAPHANDLER</code> and <code>TRAPHANDLER_NOEC</code> in <code>trapentry.S</code> should help you, as well as the T_* defines in <code>inc/trap.h</code>. You will need to add an entry point in <code>trapentry.S</code> (using those macros) for each trap defined in <code>inc/trap.h</code>, and you’ll have to provide <code>_alltraps</code> which the <code>TRAPHANDLER</code> macros refer to. You will also need to modify <code>trap_init()</code> to initialize the <code>idt</code> to point to each of these entry points defined in <code>trapentry.S</code>; the <code>SETGATE</code> macro will be helpful here.</p>
<p>Your <code>_alltraps</code> should:</p>
<ol>
<li>push values to make the stack look like a struct Trapframe</li>
<li>load <code>GD_KD</code> into <code>%ds</code> and <code>%es</code></li>
<li><code>pushl %esp</code> to pass a pointer to the Trapframe as an argument to trap()</li>
<li><code>call trap</code> (can <code>trap</code> ever return?)</li>
</ol>
<p>Consider using the <code>pushal</code> instruction; it fits nicely with the layout of the <code>struct Trapframe</code>.</p>
<p>Test your trap handling code using some of the test programs in the <code>user</code> directory that cause exceptions before making any system calls, such as <code>user/divzero</code>. You should be able to get make grade to succeed on the <code>divzero</code>, <code>softint</code>, and <code>badsegment</code> tests at this point.</p>
<p>查看<code>trapentry.s</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="line"> * It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="line"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="line"> *</span><br><span class="line"> * You shouldn&#x27;t call a TRAPHANDLER function from C, but you may</span><br><span class="line"> * need to _declare_ one in C (for instance, to get a function pointer</span><br><span class="line"> * during IDT setup).  You can declare the function with</span><br><span class="line"> *   void NAME();</span><br><span class="line"> * where NAME is the argument passed to TRAPHANDLER.</span><br><span class="line"> */</span><br><span class="line">#define TRAPHANDLER(name, num)                \</span><br><span class="line">   .globl name;      /* define global symbol for &#x27;name&#x27; */  \</span><br><span class="line">   .type name, @function; /* symbol type is function */     \</span><br><span class="line">   .align 2;     /* align function definition */       \</span><br><span class="line">   name:        /* function starts here */    \</span><br><span class="line">   pushl $(num);                    \</span><br><span class="line">   jmp _alltraps</span><br></pre></td></tr></table></figure>

<p>.global  定义了全局符号。</p>
<p>​       汇编函数如果需要在其他文件内调用，需要把函数声明为全局，此时就会使用.global这个伪操作。</p>
<p>.type  用来制定一个符号类型是函数类型或者是对象类型，对象类型一般是数据</p>
<p>​        <code>.type symbol, @object</code></p>
<p>​        <code>.type symbol, @function</code></p>
<p>.align  用来指定内存对齐方式</p>
<p>​        <code>.align size</code></p>
<p>​        表示按size字节对齐内存</p>
<p>这一步做了什么？光看这里很难理解，提示说是构造一个 <code>Trapframe</code> 结构体来保存现场，但是这里怎么直接就 push 中断向量了？实际上，在上文已经指出， cpu 自身会先 push 一部分寄存器（见例子所述），而其他则由用户和操作系统决定。由于中断向量是操作系统定义的，所以从这部分开始就已经不属于 cpu 的工作范畴了。</p>
<p>在 <code>trapentry.S</code> 中：</p>
<p>根据inc/trap.h 绑定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="line">// It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="line"></span><br><span class="line">// Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="line">// Use TRAPHANDLER_NOEC for traps where the CPU doesn&#x27;t push an error code.</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="line"> */</span><br><span class="line">// 绑定异常到自定义处理器</span><br><span class="line">TRAPHANDLER_NOEC(handler0, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(handler1, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(handler2, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(handler3, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(handler4, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(handler5, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(handler6, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(handler7, T_DEVICE)</span><br><span class="line">TRAPHANDLER(handler8, T_DBLFLT)</span><br><span class="line">// 9 deprecated since 386</span><br><span class="line">TRAPHANDLER(handler10, T_TSS)</span><br><span class="line">TRAPHANDLER(handler11, T_SEGNP)</span><br><span class="line">TRAPHANDLER(handler12, T_STACK)</span><br><span class="line">TRAPHANDLER(handler13, T_GPFLT)</span><br><span class="line">TRAPHANDLER(handler14, T_PGFLT)</span><br><span class="line">// 15 reserved by intel</span><br><span class="line">TRAPHANDLER_NOEC(handler16, T_FPERR)</span><br><span class="line">TRAPHANDLER(handler17, T_ALIGN)</span><br><span class="line">TRAPHANDLER_NOEC(handler18, T_MCHK)</span><br><span class="line">TRAPHANDLER_NOEC(handler19, T_SIMDERR)</span><br><span class="line">// system call (interrupt)</span><br><span class="line">TRAPHANDLER_NOEC(handler48, T_SYSCALL)</span><br><span class="line"></span><br><span class="line">// 该函数是全局的，但是在 C 文件中使用的时候需要使用 void name(); 再声明一下。</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 你不应该从C调用TRAPHANDLER函数，但你可能需要在C中_declare_(例如，在IDT设置期间获得一个函数指针)。您可以使用声明函数</span><br><span class="line">    void NAME();</span><br><span class="line">    其中NAME是传递给TRAPHANDLER的参数。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for _alltraps</span><br><span class="line"> */</span><br><span class="line">_alltraps:</span><br><span class="line">pushl %es</span><br><span class="line">pushl %ds</span><br><span class="line">pushal</span><br><span class="line"></span><br><span class="line">movw $GD_KD, %ax</span><br><span class="line">movw %ax, %ds</span><br><span class="line">movw %ax, %es</span><br><span class="line"></span><br><span class="line">pushl %esp</span><br><span class="line">call trap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 不能用立即数直接给段寄存器赋值。因此不能直接写movw $GD_KD, %ds。</span><br></pre></td></tr></table></figure>



<p><strong>SETGATE MACRO</strong></p>
<p>Set up a normal interrupt/trap gate descriptor.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Set up a normal interrupt/trap gate descriptor.</span><br><span class="line">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span><br><span class="line">    //   see section 9.6.1.3 of the i386 reference: &quot;The difference between</span><br><span class="line">    //   an interrupt gate and a trap gate is in the effect on IF (the</span><br><span class="line">    //   interrupt-enable flag). An interrupt that vectors through an</span><br><span class="line">    //   interrupt gate resets IF, thereby preventing other interrupts from</span><br><span class="line">    //   interfering with the current interrupt handler. A subsequent IRET</span><br><span class="line">    //   instruction restores IF to the value in the EFLAGS image on the</span><br><span class="line">    //   stack. An interrupt through a trap gate does not change IF.&quot;</span><br><span class="line">// - sel: 代码段选择器 for interrupt/trap handler</span><br><span class="line">// - off: 代码段的偏移量 for interrupt/trap handler</span><br><span class="line">// - dpl: Descriptor Privilege Level -</span><br><span class="line">//   the privilege level required for software to invoke</span><br><span class="line">//   this interrupt/trap gate explicitly using an int instruction.</span><br><span class="line">/*</span><br><span class="line">gate</span><br><span class="line">这是一个 struct Gatedesc。</span><br><span class="line">istrap</span><br><span class="line">该中断是 trap(exception) 则为1，是 interrupt 则为0。</span><br><span class="line">sel</span><br><span class="line">代码段选择器。进入内核的话是 GD_KT。</span><br><span class="line">off</span><br><span class="line">相对于段的偏移，简单来说就是函数地址。</span><br><span class="line">dpl(Descriptor Privileged Level)</span><br><span class="line">权限描述符。</span><br><span class="line">*/</span><br><span class="line">#define SETGATE(gate, istrap, sel, off, dpl)         \</span><br><span class="line">&#123;                       \</span><br><span class="line">   (gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff;       \</span><br><span class="line">   (gate).gd_sel = (sel);             \</span><br><span class="line">   (gate).gd_args = 0;                \</span><br><span class="line">   (gate).gd_rsv1 = 0;                \</span><br><span class="line">   (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;   \</span><br><span class="line">   (gate).gd_s = 0;               \</span><br><span class="line">   (gate).gd_dpl = (dpl);             \</span><br><span class="line">   (gate).gd_p = 1;               \</span><br><span class="line">   (gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16;     \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Challenge!</em> You probably have a lot of very similar code right now, between the lists of <code>TRAPHANDLER</code> in <code>trapentry.S</code> and their installations in <code>trap.c</code>. Clean this up. Change the macros in <code>trapentry.S</code> to <strong>automatically generate a table</strong> for <code>trap.c</code> to use. Note that you can switch between laying down code and data in the assembler by using the directives <code>.text</code> and <code>.data</code>.</p>
<p><strong>Questions</strong></p>
<p>Answer the following questions in your <code>answers-lab3.txt</code>:</p>
<ol>
<li><p>What is the purpose of having an individual handler function for each exception/interrupt? (i.e., if all exceptions/interrupts were delivered to the same handler, what feature that exists in the current implementation could not be provided?)</p>
<p>为每个异常/中断提供单独的处理函数的目的是什么?(也就是说，如果所有异常/中断都被交付给同一个处理程序，当前实现中存在的哪些特性不能提供?)</p>
<p>答：因为每个异常和中断的处理方式不同，例如除0异常不会继续返回程序执行，而I/O操作中断后会继续返回程序处理。一个handler难以处理多种情况。</p>
</li>
<li><p>Did you have to do anything to make the <code>user/softint</code> program behave correctly? The grade script expects it to produce a general protection fault (trap 13), but <code>softint</code>‘s code says <code>int $14</code>. <em>Why</em> should this produce interrupt vector 13? What happens if the kernel actually allows <code>softint</code>‘s <code>int $14</code>instruction to invoke the kernel’s page fault handler (which is interrupt vector 14)?</p>
</li>
</ol>
<h1 id="Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls"><a href="#Part-B-Page-Faults-Breakpoints-Exceptions-and-System-Calls" class="headerlink" title="Part B: Page Faults, Breakpoints Exceptions, and System Calls"></a>Part B: Page Faults, Breakpoints Exceptions, and System Calls</h1><h2 id="Exercise5-Handling-Page-Faults"><a href="#Exercise5-Handling-Page-Faults" class="headerlink" title="Exercise5: Handling Page Faults"></a>Exercise5: Handling Page Faults</h2><p>缺页错误异常，中断向量 14 (<code>T_PGFLT</code>)，是一个非常重要的异常类型，lab3 以及 lab4 都强烈依赖于这个异常处理。当程序遇到缺页异常时，它将引起异常的虚拟地址存入 <code>CR2</code> 控制寄存器( control register)。在 <code>trap.c</code> 中，我们已经提供了<code>page_fault_handler()</code> 函数用来处理缺页异常。</p>
<p>修改trap_dispatch()，将页面故障异常分派到page_fault_handler()。现在，您应该能够在faultread、faultreadkernel、faultwrite和faultwritekernel测试中获得成功。如果其中任何一个不工作，找出原因并解决它们。记住，您可以使用make run-x或make run-x-nox将JOS引导到特定的用户程序中。例如，make run-hello-nox运行hello用户程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Handle processor exceptions.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">switch</span>(tf-&gt;tf_trapno)&#123;</span><br><span class="line">        <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">            page_fault_handler();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">                panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                env_destroy(curenv);  <span class="comment">// 销毁</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Exercise-6-The-Breakpoint-Exception"><a href="#Exercise-6-The-Breakpoint-Exception" class="headerlink" title="Exercise 6: The Breakpoint Exception"></a>Exercise 6: The Breakpoint Exception</h2><p>断点异常，中断向量 3 (<code>T_BRKPT</code>) 允许调试器给程序加上断点。原理是暂时把程序中的某个指令替换为一个 1 字节大小的 <code>int3</code>软件中断指令。在 JOS 中，我们将它实现为一个伪系统调用。这样，任何程序（不限于调试器）都能使用断点功能。</p>
<p>Modify <code>trap_dispatch()</code> to make breakpoint exceptions invoke the kernel monitor. You should now be able to get make grade to succeed on the <code>breakpoint</code> test.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">trap_dispatch</span><span class="params">(struct Trapframe *tf)</span>    <span class="comment">// dispatch 调度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Handle processor exceptions.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">switch</span>(tf-&gt;tf_trapno)&#123;</span><br><span class="line">        <span class="keyword">case</span> T_PGFLT:</span><br><span class="line">            page_fault_handler(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_BRKPT:</span><br><span class="line">            monitor(tf);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">            print_trapframe(tf);</span><br><span class="line">            <span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">                panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                env_destroy(curenv);  <span class="comment">// 销毁</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em>Challenge!</em> Modify the JOS kernel monitor so that you can ‘continue’ execution from the current location (e.g., after the <code>int3</code>, if the kernel monitor was invoked via the breakpoint exception), and so that you can single-step one instruction at a time. You will need to understand certain bits of the <code>EFLAGS</code> register in order to implement single-stepping.</p>
<p><em>Optional:</em> If you’re feeling really adventurous, find some x86 disassembler source code - e.g., by ripping it out of QEMU, or out of GNU binutils, or just write it yourself - and extend the JOS kernel monitor to be able to disassemble and display instructions as you are stepping through them. Combined with the symbol table loading from lab 1, this is the stuff of which real kernel debuggers are made.</p>
<p><strong>Questions</strong></p>
<ol>
<li><p>The break point test case will either generate a break point exception or a general protection fault depending on how you initialized the break point entry in the IDT (i.e., your call to <code>SETGATE</code> from <code>trap_init</code>). Why? How do you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup would cause it to trigger a general protection fault?</p>
<p>断点测试用例将生成断点异常或一般保护故障，这取决于您在IDT中初始化断点条目的方式(即，从trap_init调用SETGATE)。为什么?您需要如何设置它才能使断点异常像上面指定的那样工作?哪些不正确的设置会导致它触发一般的保护故障?</p>
<p><strong>答：</strong>权限问题。特权级别是个很重要的点。每个IDT的entries内的中断描述符都为中断处理程序设定了一个DPL(Descriptor Privilege Level)。用户程序的特权级别是3，内核的特权级别是0(可知<strong>0级别更高</strong>)。如果用户产生的中断/异常需要级别0，那么用户就无权请内核调用这个处理程序，就会产生一个general protection fault，如果是内核发生中断/异常的话，特权级别总是够的</p>
<p><code>SETGATE(idt[T_BRKPT], 1, GD_KT, brkpt_handler, 3);</code>中如果最后一个参数dpl设为3就会产生一个breakpoint exception，如果设为0就会产生一个general protection fault。这也是由于特权级别影响的。breakpoint test程序的特权级别是3，如果断点异常处理程序特权设为3那就可以是断点异常，如果设为0就产生保护错误。</p>
</li>
<li><p>What do you think is the point of these mechanisms, particularly in light of what the <code>user/softint</code> test program does?</p>
<p>里面是这条代码<code>asm volatile(&quot;int $14&quot;);</code>本来想中断调用页面错误处理，结果因为特权级别不够而产生一个保护异常，所以重点应该是要分清特权级别吧。要区分<code>$14</code> 与 <code>$0x30</code>。</p>
<p>优先级别低的代码无法访问优先级高的代码，优先级高低由gd_dpl判断。数字越小越高。</p>
</li>
</ol>
<h2 id="Exercise-7-System-calls"><a href="#Exercise-7-System-calls" class="headerlink" title="Exercise 7: System calls"></a>Exercise 7: System calls</h2><p>用户进程通过调用系统调用请求内核为它们做一些事情。当用户进程调用一个系统调用时，处理器进入内核模式，处理器和内核合作保存用户进程的状态，内核执行相应的代码来执行系统调用，然后恢复用户进程。用户进程如何获得内核的注意，以及用户进程如何指定要执行的调用，这些具体细节在不同的系统中有所不同。</p>
<p>在JOS内核中，我们将使用int指令，它会导致处理器中断。特别地，我们将使用int $0x30作为系统调用中断。我们已经为您定义了常量T_SYSCALL到48 (0x30)。您必须设置中断描述符，以允许用户进程引起中断。注意，中断0x30不能由硬件生成，所以不会因为允许用户代码生成它而产生歧义。</p>
<p>应用程序将在寄存器中传递系统调用号和系统调用参数。这样，内核就不需要在用户环境的堆栈或指令流中到处寻找了。系统调用号将进入%eax，参数(最多5个)将分别进入%edx、%ecx、%ebx、%edi和%esi。内核将返回值返回到%eax中。调用系统调用的汇编代码已经为您编写，在lib/syscall.c中的syscall()中。你应该通读一遍，确保你明白发生了什么.</p>
<p>exercise: 在内核中为中断向量T_SYSCALL添加一个处理程序。你必须编辑kern/trapentry。S和kern/trap.c的trap_init()。您还需要更改trap_dispatch()来处理系统调用中断，方法是使用适当的参数调用sycall(在kern/syscall.c中定义)，然后将返回值传递回%eax中的用户进程。最后，你需要在kern/syscall.c中实现syscall()。确保如果系统调用号无效，syscall()返回-E_INVAL。您应该阅读并理解lib/syscall.c(特别是内联汇编例程)，以确认您对系统调用接口的理解。通过为每个调用调用相应的内核函数来处理inc/syscall.h中列出的所有系统调用。</p>
<p>Run the user/hello program under your kernel (make run-hello). It should print “hello, world” on the console and then cause a page fault in user mode. If this does not happen, it probably means your system call handler isn’t quite right. You should also now be able to get make grade to succeed on the testbss test.</p>
<p><strong>inc/syscall.h</strong></p>
<p>定义了系统调用号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JOS_INC_SYSCALL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JOS_INC_SYSCALL_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* system call numbers */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   SYS_cputs = <span class="number">0</span>,</span><br><span class="line">   SYS_cgetc,</span><br><span class="line">   SYS_getenvid,</span><br><span class="line">   SYS_env_destroy,</span><br><span class="line">   NSYSCALLS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* !JOS_INC_SYSCALL_H */</span></span></span><br></pre></td></tr></table></figure>



<p>lib/syscall.c</p>
<p>这是系统调用的通用模板，不同的系统调用都会以不同参数调用syscall函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call stubs.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int32_t</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> check, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int32_t</span> ret;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Generic system call: 在AX中传递系统呼叫号，在DX、CX、BX、DI、SI中最多传递5个参数。</span></span><br><span class="line">   <span class="comment">// 使用t_sycall中断内核。</span></span><br><span class="line">	 <span class="comment">// “volatile”告诉汇编器不要因为没有使用返回值而对该指令进行优化。</span></span><br><span class="line">	 <span class="comment">// 最后一个子句告诉汇编器，这可能会改变条件代码和任意内存位置。</span></span><br><span class="line">   <span class="comment">// 可以看到，该段汇编的output为 ret</span></span><br><span class="line">   <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;int %1\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">           : <span class="string">&quot;=a&quot;</span> (ret)</span></span></span><br><span class="line"><span class="params"><span class="function">           : <span class="string">&quot;i&quot;</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;a&quot;</span> (num),    </span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;d&quot;</span> (a1),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;c&quot;</span> (a2),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;b&quot;</span> (a3),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;D&quot;</span> (a4),</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="string">&quot;S&quot;</span> (a5)</span></span></span><br><span class="line"><span class="params"><span class="function">           : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(check &amp;&amp; ret &gt; <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;syscall %d returned %d (&gt; 0)&quot;</span>, num, ret);</span><br><span class="line">		<span class="comment">// 函数的返回为ret</span></span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sys_cputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   syscall(SYS_cputs, <span class="number">0</span>, (<span class="keyword">uint32_t</span>)s, len, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_cgetc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> syscall(SYS_cgetc, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">sys_env_destroy</span><span class="params">(<span class="keyword">envid_t</span> envid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> syscall(SYS_env_destroy, <span class="number">1</span>, envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">envid_t</span></span></span><br><span class="line"><span class="function"><span class="title">sys_getenvid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_getenvid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>补充知识：GCC内联汇编</strong><br>其语法固定为：<br><code>asm volatile (“asm code”：output：input：changed);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;int %1\n&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">         : <span class="string">&quot;=a&quot;</span> (ret)</span></span></span><br><span class="line"><span class="params"><span class="function">         : <span class="string">&quot;i&quot;</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;a&quot;</span> (num),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;d&quot;</span> (a1),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;c&quot;</span> (a2),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;b&quot;</span> (a3),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;D&quot;</span> (a4),</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="string">&quot;S&quot;</span> (a5)</span></span></span><br><span class="line"><span class="params"><span class="function">         : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">限定符</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“m”、”v”、”o”</td>
<td align="center">内存单元</td>
</tr>
<tr>
<td align="center">“r”</td>
<td align="center">任何寄存器</td>
</tr>
<tr>
<td align="center">“q”</td>
<td align="center">寄存器eax、ebx、ecx、edx之一</td>
</tr>
<tr>
<td align="center">“i”、”h”</td>
<td align="center">直接操作数</td>
</tr>
<tr>
<td align="center">“E”、”F”</td>
<td align="center">浮点数</td>
</tr>
<tr>
<td align="center">“g”</td>
<td align="center">任意</td>
</tr>
<tr>
<td align="center">“a”、”b”、”c”、”d”</td>
<td align="center">分别表示寄存器eax、ebx、ecx和edx</td>
</tr>
<tr>
<td align="center">“S”、”D”</td>
<td align="center">寄存器esi、edi</td>
</tr>
<tr>
<td align="center">“I”</td>
<td align="center">常数 (0至31)</td>
</tr>
</tbody></table>
<p>除了这些约束之外, 输出值还包含一个约束修饰符:</p>
<table>
<thead>
<tr>
<th align="center">输出修饰符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">可以读取和写入操作数</td>
</tr>
<tr>
<td align="center">=</td>
<td align="center">只能写入操作数</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">如果有必要操作数可以和下一个操作数切换</td>
</tr>
<tr>
<td align="center">&amp;</td>
<td align="center">在内联函数完成之前, 可以删除和重新使用操作数</td>
</tr>
</tbody></table>
<p>根据表格内容，可以看出该内联汇编作用就是引发一个<code>int</code>中断，中断向量为立即数 <code>T_SYSCALL</code>，同时，对寄存器进行操作。看懂这，就清楚了，这一部分应该不需要我们改动，因为我们处理的是中断已经产生后的部分。<strong>当然，还有另一种更简单的思路，</strong><code>inc/</code> <strong>目录下的，其实都是操作系统留给用户的接口</strong>，所以才会在里面看到 <code>stdio.h</code>，<code>assert.h</code> 等文件。那么，要进行系统调用肯定也是先调用 <code>inc/</code> 中的那个，具体处理应该是在 <code>kern/</code> 中实现。</p>
<p>ref：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f67034d0c3f2">https://www.jianshu.com/p/f67034d0c3f2</a></p>
<p><strong>kern/trap.c</strong></p>
<p>trap_init()添加</p>
<img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704144047847.png" alt="image-20220704144047847" style="zoom: 50%;" />

<p>权限更改为3，以便用户进程可以触发该中断</p>
<p>修改<strong>trap_dispatch()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> T_SYSCALL:</span><br><span class="line">    tf-tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_edx,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_edi,</span><br><span class="line">                                 tf-&gt;tf_regs.reg_esi);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p><strong>kern/syscall.c</strong></p>
<p>我们在 <code>kern/trap.c</code> 中调用的实际上就是这里的 syscall 函数，而不是 <code>lib/syscall.c</code> 中的那个。想明白这一点，设置参数也就很简单了，注意返回值的处理。</p>
<img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704154830887.png" alt="image-20220704154830887" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="function"><span class="keyword">int32_t</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line">   <span class="comment">// Return any appropriate return value.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//panic(&quot;syscall not implemented&quot;);</span></span><br><span class="line">    <span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">        <span class="keyword">case</span> SYS_cputs:</span><br><span class="line">            sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span> *)a1, a2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">            retVal = sys_cgetc();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">            retVal = sys_getenvid()&gt;=<span class="number">0</span>;  <span class="comment">// // Returns the current environment&#x27;s envid.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">            retVal = sys_env_destroy(a1);  <span class="comment">// env_id</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>make grade</code> 可以通过 testbss，运行 <code>make run-hello</code> 可以打印出 <code>hello world</code>，紧接着提示了页错误。</p>
<img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704163653390.png" alt="image-20220704163653390" style="zoom:50%;" />

<img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704163812230.png" alt="image-20220704163812230" style="zoom:50%;" />

<img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704163804732.png" alt="image-20220704163804732" style="zoom:50%;" />

<p>通过 exercise 7，可以看出 JOS系 统调用的步骤为：</p>
<ol>
<li>用户进程使用 <code>inc/</code> 目录下暴露的接口</li>
<li><code>lib/syscall.c</code> 中的函数将系统调用号及必要参数传给寄存器，并引起一次 <code>int $0x30</code> 中断</li>
<li><code>kern/trap.c</code> 捕捉到这个中断，并将 TrapFrame 记录的寄存器状态作为参数，调用处理中断的函数</li>
<li><code>kern/syscall.c</code> 处理中断</li>
</ol>
<h2 id="Exercise-8-User-mode-startup"><a href="#Exercise-8-User-mode-startup" class="headerlink" title="Exercise 8: User-mode startup"></a>Exercise 8: User-mode startup</h2><p>一个用户程序开始运行在<code>lib/entry.S</code>的顶部。在一些设置之后，这段代码调用<code>lib/libmain.c中</code>的<code>libmain()</code>。你应该修改<code>libmain()</code>来初始化全局指针<code>thisenv</code>，使其指向envs[]数组中的环境结构体Env。(Note that <code>lib/entry.S</code> has already defined <code>envs</code> to point at the <code>UENVS</code> mapping you set up in Part A.) </p>
<p>Hint: look in <code>inc/env.h</code> and use <code>sys_getenvid</code>.</p>
<p><code>libmain()</code> then calls umain, which, in the case of the hello program, is in <code>user/hello.c</code>. Note that after printing “hello, world”, it tries to access <code>thisenv-&gt;env_id.</code> This is why it faulted earlier.</p>
<p>Now that you’ve initialized <code>thisenv</code> properly, it should not fault. If it still faults, you probably haven’t mapped the <code>UENVS</code> area user-readable (back in Part A in <code>pmap.c</code>; this is the first time we’ve actually used the <code>UENVS</code> area).</p>
<p>Add the required code to the user library, then boot your kernel. You should see <code>user/hello</code> print “<code>hello, world</code>“ and then print “<code>i am environment 00001000</code>“. <code>user/hello</code> then attempts to “exit” by calling <code>sys_env_destroy()</code> (see <code>lib/libmain.c</code> and <code>lib/exit.c</code>). Since the kernel currently only supports one user environment, it should report that it has destroyed the only environment and then drop into the kernel monitor. You should be able to get make grade to succeed on the <code>hello</code> test.</p>
<p><strong>umain.c</strong></p>
<p>user/hello.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">umain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cprintf(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">   cprintf(<span class="string">&quot;i am environment %08x\n&quot;</span>, thisenv-&gt;env_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">libmain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// set thisenv to point at our Env structure in envs[].</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">   thisenv = &amp;envs[ENVX(sys_getenvid())];  <span class="comment">// &amp;envs[ENVX(envid)]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// save the name of the program so that panic() can use it</span></span><br><span class="line">   <span class="keyword">if</span> (argc &gt; <span class="number">0</span>)</span><br><span class="line">      binaryname = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// call user main routine</span></span><br><span class="line">   umain(argc, argv);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// exit gracefully</span></span><br><span class="line">   <span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704172003993.png" alt="image-20220704172003993"></p>
<p>hello 完成</p>
<h2 id="Exercise-9-Page-faults-and-memory-protection"><a href="#Exercise-9-Page-faults-and-memory-protection" class="headerlink" title="Exercise 9: Page faults and memory protection"></a>Exercise 9: Page faults and memory protection</h2><p>内存保护是操作系统的关键功能，它确保了一个程序中的错误不会导致其他程序或是操作系统自身的崩溃。<br>操作系统通常依赖硬件的支持来实现内存保护。操作系统会告诉硬件哪些虚拟地址可用哪些不可用。当某个程序想访问不可用的内存地址或不具备权限时，处理器将在出错指令处停止程序，然后陷入内核。如果错误可以处理，内核就处理并恢复程序运行，否则无法恢复。<br>作为可以修复的错误，设想某个自动生长的栈。在许多系统中内核首先分配一个页面给栈，如果某个程序访问了页面外的空间，内核会自动分配更多页面以让程序继续。这样，内核只用分配程序需要的栈内存给它，然而程序感觉仿佛可以拥有任意大的栈内存。<br>系统调用也为内存保护带来了有趣的问题。许多系统调用接口允许用户传递指针给内核，这些指针指向待读写的用户缓冲区。内核处理系统调用的时候会对这些指针解引用。这样就带来了两个问题：</p>
<ol>
<li>内核的页错误通常比用户进程的页错误严重得多，如果内核在操作自己的数据结构时发生页错误，这就是一个内核bug，会引起系统崩溃。<strong>因此，内核需要记住这个错误是来自用户进程。</strong></li>
<li>内核比用户进程拥有更高的内存权限，<strong>用户进程给内核传递的指针可能指向一个只有内核能够读写的区域，内核必须谨慎避免解引用这类指针</strong>，因为这样可能导致内核的私有信息泄露或破坏内核完整性。</li>
</ol>
<p>我们将<strong>对用户进程传给内核的指针做一个检查来解决这两个问题</strong>。内核将检查指针指向的是内存中用户空间部分，页表也允许内存操作。</p>
<p>Change <code>kern/trap.c</code> to <strong>panic</strong> if a page fault happens <strong>in kernel mode</strong>.</p>
<p><strong>Hint:</strong> to determine whether a fault happened in user mode or in kernel mode, check the <strong>low bits</strong> of the <code>tf_cs</code>. (<strong>tf_cs是0x18还是0x1b， 0x18｜0x03 = 0x1b此时是用户模式，0x18是内核模式，检查&amp;3后的低2位</strong>)</p>
<p>Read <code>user_mem_assert</code> in <code>kern/pmap.c</code> and implement <code>user_mem_check</code> in that same file.</p>
<p>Change <code>kern/syscall.c</code> to sanity check arguments to system calls.</p>
<p>Boot your kernel, running <code>user/buggyhello</code>. The environment should be destroyed, and the kernel should <em>not</em> panic. You should see:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[00001000] user_mem_check assertion failure for va 00000001</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Destroyed the only environment - nothing more to do!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Finally, change <code>debuginfo_eip</code> in <code>kern/kdebug.c</code> to call <code>user_mem_check</code> on <code>usd</code>, <code>stabs</code>, and <code>stabstr</code>. If you now run <code>user/breakpoint</code>, you should be able to run <code>backtrace</code> from the kernel monitor and see the backtrace traverse into <code>lib/libmain.c</code> before the kernel panics with a page fault. What causes this page fault? You don’t need to fix it, but you should understand why it happens.</p>
<p><strong>kern/trap.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_fault_handler</span><span class="params">(struct Trapframe *tf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">   fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line">   <span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span>(!(tf-&gt;tf_cs &amp; <span class="number">3</span>))&#123;</span><br><span class="line">        panic(<span class="string">&quot;page fault in kernel mode.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">   <span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">   cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">      curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">   print_trapframe(tf);</span><br><span class="line">   env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>kern/pmap.c</strong></p>
<p>user_mem_check</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查一个环境是否允许访问权限为&#x27;perm | PTE_P&#x27;的内存范围[va, va+len]。</span></span><br><span class="line"><span class="comment">// 通常&#x27;perm&#x27;至少包含PTE_U，但这不是必需的。&#x27;va&#x27;和&#x27;len&#x27;不需要按页面对齐;必须测试包含任何该范围的每个页面。</span></span><br><span class="line"><span class="comment">// 你可以测试&#x27;len/PGSIZE&#x27;， &#x27;len/PGSIZE + 1&#x27;，或者&#x27;len/PGSIZE + 2&#x27;页面。</span></span><br><span class="line"><span class="comment">// 用户程序可以访问一个虚拟地址，如果</span></span><br><span class="line"><span class="comment">// (1)该地址在ULIM之下</span></span><br><span class="line"><span class="comment">// (2)页表给了它权限。这些正是您应该在这里实现的测试。</span></span><br><span class="line"><span class="comment">// 这些正是您应该在这里实现的测试。</span></span><br><span class="line"><span class="comment">// 如果有错误，设置&#x27;user_mem_check_addr&#x27;变量为第一个错误的虚拟地址。</span></span><br><span class="line"><span class="comment">// 如果用户程序可以访问这个地址范围，返回0，否则返回-E_FAULT。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">user_mem_check</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">    <span class="comment">// 内存范围[va, va+len]</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> start_va = ROUNDDOWN((<span class="keyword">uintptr_t</span>)va, PGSIZE);</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = ROUNDUP((<span class="keyword">uintptr_t</span>)va + len, PGSIZE);</span><br><span class="line">    <span class="comment">// 访问内存，通过页表，那么直接看page table entry</span></span><br><span class="line">    <span class="comment">// 遍历查看是否有权限</span></span><br><span class="line">    <span class="comment">// pgdir_walk returns a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line">    <span class="comment">// pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)</span></span><br><span class="line">    <span class="keyword">for</span>((<span class="keyword">uintptr_t</span>)cur_va = start_va;cur_va&lt;end_va;cur_va+=PGSIZE)&#123;</span><br><span class="line">        <span class="comment">// env-&gt;env_pgdir 取进程对应的页表</span></span><br><span class="line">        <span class="keyword">pte_t</span>* cur_pte = pgdir_walk(env-&gt;env_pgdir, (<span class="keyword">void</span>*)cur_va, <span class="number">0</span>);  <span class="comment">// 只查询不建立</span></span><br><span class="line">        <span class="keyword">if</span>(cur_pte == <span class="literal">NULL</span> || (*cur_pte &amp; (perm | PTE_P))!=(perm | PTE_P) || cur_va&gt;=ULIM)&#123;  <span class="comment">// 不满足要求</span></span><br><span class="line">            <span class="keyword">if</span>(cur_va == start_va)&#123;  <span class="comment">// 因为va做了近似，所以第一个页面地址要做处理</span></span><br><span class="line">                user_mem_check_addr = va;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                user_mem_check_addr = cur_va;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 程序不能访问这个地址，返回-E_FAULT</span></span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以访问</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704223729337.png" alt="image-20220704223729337" style="zoom:50%;" />

<p>不能写为cur_va&lt;=end_va。会内存越界</p>
<p>user_mem_assert</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Checks that environment &#x27;env&#x27; is allowed to access the range</span></span><br><span class="line"><span class="comment">// of memory [va, va+len) with permissions &#x27;perm | PTE_U | PTE_P&#x27;.</span></span><br><span class="line"><span class="comment">// If it can, then the function simply returns.</span></span><br><span class="line"><span class="comment">// If it cannot, &#x27;env&#x27; is destroyed and, if env is the current</span></span><br><span class="line"><span class="comment">// environment, this function will not return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">user_mem_assert</span><span class="params">(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (user_mem_check(env, va, len, perm | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      cprintf(<span class="string">&quot;[%08x] user_mem_check assertion failure for &quot;</span></span><br><span class="line">         <span class="string">&quot;va %08x\n&quot;</span>, env-&gt;env_id, user_mem_check_addr);</span><br><span class="line">      env_destroy(env);  <span class="comment">// may not return</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用了user_mem_check()，不满足则摧毁页面</p>
<p>运行 <code>make run-buggyhello-nox</code></p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704213103991.png" alt="image-20220704213103991"></p>
<pre><code>[00001000] user_mem_check assertion failure for va 00000001
[00001000] free env 00001000
Destroyed the only environment - nothing more to do!
</code></pre>
<p>最后，change <code>debuginfo_eip</code> in <code>kern/kdebug.c</code> to call <code>user_mem_check</code> on <code>usd</code>, <code>stabs</code>, and <code>stabstr</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">      <span class="comment">// 就是查看能否访问 UserStabData</span></span><br><span class="line">      <span class="comment">// int user_mem_check(struct Env *env, const void *va, size_t len, int perm)</span></span><br><span class="line">      <span class="keyword">if</span>(user_mem_check(curenv, (<span class="keyword">void</span>*) usd, <span class="keyword">sizeof</span>(struct UserStabData), PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">stabs = usd-&gt;stabs;</span><br><span class="line">stab_end = usd-&gt;stab_end;</span><br><span class="line">stabstr = usd-&gt;stabstr;</span><br><span class="line">stabstr_end = usd-&gt;stabstr_end;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure the STABS and string table memory is valid.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">      <span class="keyword">if</span>(user_mem_check(curenv, (<span class="keyword">void</span>*) stabs, stab_end - stabs, PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(user_mem_check(curenv, (<span class="keyword">void</span>*) stabstr, stabstr_end - stabstr, PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><code>make run-breakpoint-nox</code> 然后 使用 <code>backtrace</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">K&gt; backtrace</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp efffff10  eip f0100a39  args <span class="number">00000001</span> efffff28 f0226000 <span class="number">00000000</span> f01e4a40</span><br><span class="line">    kern/monitor.c:<span class="number">222</span>: monitor+<span class="number">260</span></span><br><span class="line">  ebp efffff80  eip f0103f80  args f0226000 efffffbc <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">    kern/trap.c:<span class="number">200</span>: trap+<span class="number">187</span></span><br><span class="line">  ebp efffffb0  eip f010409d  args efffffbc <span class="number">00000000</span> <span class="number">00000000</span> eebfdfd0 efffffdc</span><br><span class="line">    kern/trapentry.S:<span class="number">93</span>: &lt;unknown&gt;+<span class="number">0</span></span><br><span class="line">  ebp eebfdfd0  eip <span class="number">0080007b</span>  args <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">    lib/libmain.c:<span class="number">26</span>: libmain+<span class="number">63</span></span><br><span class="line">Incoming TRAP frame at <span class="number">0xeffffe8c</span></span><br><span class="line">kernel panic at kern/trap.c:<span class="number">272</span>: page fault in kernel mode.</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> a <span class="built_in">list</span> of commands.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到遍历到了：<code>lib/libmain.c:26: libmain+63</code></p>
<p>ebp(基址指针寄存器)寄存器的内容，efffff10，efffff80，efffffb0都位于内核栈，eebfdfd0位于用户栈。</p>
<p>输入<code>make run-breakpoint-nox-gdb       make gdb</code></p>
<p>把断点打在 monitor()函数处(kern/monitor.c)</p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704220321417.png" alt="image-20220704220321417"></p>
<p>查看ebp的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用者ebp   返回地址eip  参数1  参数2</span><br><span class="line">参数3       参数4        参数5  ...</span><br></pre></td></tr></table></figure>

<p>在查看0xeebfdfd0到用户栈栈顶0xeebfdff0的内容</p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704221209942.png" alt="image-20220704221209942"></p>
<p>试图越界访问，可得到</p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704221230450.png" alt="image-20220704221230450"></p>
<p>可以看到，最后就只剩了12个字符</p>
<p>这一次，backtrace的打印内容为</p>
<p><code>ebp eebfdfd0  eip 0080007b  args 00000000 00000000 00000000 00000000 00000000</code></p>
<p>那么下一次为</p>
<p><code>ebp eebfdff0  eip 00800031  args 00000000 00000000 之后的三个参数全部超过内存访问界限了</code></p>
<p>现在修改backtrace的函数，输出两个args，backtrace位于kern/monitor.c</p>
<img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704221854670.png" alt="image-20220704221854670" style="zoom:50%;" />

<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220704223813288.png" alt="image-20220704223813288"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/03/6-828Lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/03/6-828Lab2/" class="post-title-link" itemprop="url">6.828Lab2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-03 17:02:07" itemprop="dateCreated datePublished" datetime="2022-06-03T17:02:07+08:00">2022-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-28 21:56:08" itemprop="dateModified" datetime="2022-06-28T21:56:08+08:00">2022-06-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Lab2-Memory-Management"><a href="#Lab2-Memory-Management" class="headerlink" title="Lab2: Memory Management"></a>Lab2: Memory Management</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro:"></a><strong>Intro:</strong></h2><p>在本实验中，您将为您的操作系统编写内存管理代码。内存管理有两个组件。</p>
<p>第一个组件是内核的物理内存分配器，以便内核可以分配内存并在以后释放它。您的分配器将以 4096 字节为单位运行，称为 <em>pages</em>。您的任务是维护数据结构，记录哪些物理页面是空闲的，哪些是已分配的，以及有多少进程共享每个分配的页面。您还将编写例程来分配和释放内存页面。</p>
<p>内存管理的第二个组成部分是<em>虚拟内存</em>，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。x86 硬件的内存管理单元 (MMU) 在指令使用内存时执行映射，并参考一组页表。您将根据我们提供的规范修改 JOS 以设置 MMU 的页表。</p>
<p><strong>切换到lab2</strong></p>
<p><img src="https://s2.loli.net/2022/06/03/cMWvLOmap3qKoRQ.png" alt="image-20220603213654097"></p>
<p><img src="https://s2.loli.net/2022/06/03/OvA5ZRXUjzwGI39.png" alt="image-20220603213707953"></p>
<p><code>memlayout.h</code>描述了您必须通过修改<code>pmap.c</code>来实现的虚拟地址空间的布局。</p>
<p><code>memlayout.h</code>和<code>pmap.h</code>定义了<code>PageInfo</code> 用于跟踪哪些物理内存页面空闲的结构。</p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220623205319533.png" alt="image-20220623205319533"></p>
<p><code>kclock.c</code> and <code>kclock.h</code> manipulate the PC’s battery-backed clock and CMOS RAM hardware, in which the BIOS records the amount of physical memory the PC contains, among other things. </p>
<p><code>pmap.c</code>中的代码需要读取这个设备硬件，以便计算出有多少物理内存，但是这部分代码是为您完成的：您不需要了解 CMOS 硬件如何工作的细节。</p>
<p>请特别注意<code>memlayout.h</code>和<code>pmap.h</code>，因为本实验要求您使用并理解它们包含的许多定义。您可能还想查看<code>inc/mmu.h</code>，因为它还包含许多对本实验有用的定义。</p>
<p>在开始实验之前，不要忘记add -f 6.828获取 6.828 版本的 QEMU。</p>
<h1 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h1><p>您现在将编写物理页分配器。它通过对象的链接列表跟踪哪些页面是空闲的<code>struct PageInfo</code>（与 xv6 不同，这些对象<em>不</em>嵌入空闲页面本身），每个对象对应一个物理页面。您需要先编写物理页面分配器，然后才能编写其余的虚拟内存实现，因为您的页表管理代码将需要分配物理内存来存储页表。</p>
<h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><p>在文件<code>kern/pmap.c</code>中，您必须实现以下函数的代码（可能按照给定的顺序）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">boot_alloc()</span><br><span class="line">mem_init()（仅限于调用check_page_free_list(<span class="number">1</span>)）</span><br><span class="line">page_init()</span><br><span class="line">page_alloc()</span><br><span class="line">page_free()</span><br></pre></td></tr></table></figure>

<p><code>check_page_free_list() 和 check_page_alloc()</code>测试您的物理页面分配器。</p>
<p>您应该启动 JOS 并查看是否<code>check_page_alloc()</code> 报告成功。</p>
<p>Fix您的代码以使其通过。You may find it helpful to add your own <code>assert()</code>s to verify that your assumptions are correct.</p>
<p><strong>boot_alloc()</strong> 是一个内存分配器</p>
<p>函数的核心是维护一个静态变量<strong>nextfree</strong>，代表下一个可以使用的空闲内存空间的<strong>虚拟地址</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">boot_alloc</span><span class="params">(<span class="keyword">uint32_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nextfree;    <span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line">    <span class="keyword">char</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line">    <span class="comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span></span><br><span class="line">    <span class="comment">// which points to the end of the kernel&#x27;s bss segment:</span></span><br><span class="line">    <span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line">    <span class="comment">// to any kernel code or global variables.</span></span><br><span class="line">    <span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">        <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line">        nextfree = ROUNDUP((<span class="keyword">char</span> *) end, PGSIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span></span><br><span class="line">    <span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">    <span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// LAB 2: Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;  <span class="comment">// if n == 0, returns the address of the next free page without allocating anything.</span></span><br><span class="line">        <span class="keyword">return</span> nextfree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// n &gt; 0 分配足够的连续物理内存页以容纳〞n”个字节。returns a kernel virtual address.</span></span><br><span class="line">    result = nextfree;</span><br><span class="line">    nextfree += ROUNDUP(n, PGSIZE); <span class="comment">// Round up to the nearest multiple of PGSIZE</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>mem_init()</strong> 需要我们设置一个两层的页表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">mem_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cr0;</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find out how much memory the machine has (npages &amp; npages_basemem).</span></span><br><span class="line">    i386_detect_memory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove this line when you&#x27;re ready to test this function.</span></span><br><span class="line">    <span class="comment">// panic(&quot;mem_init: This function is not finished\n&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// create initial page directory.</span></span><br><span class="line">    kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line">    <span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Recursively insert PD in itself as a page table, to form</span></span><br><span class="line">    <span class="comment">// a virtual page table at virtual address UVPT.</span></span><br><span class="line">    <span class="comment">// (For now, you don&#x27;t have understand the greater purpose of the</span></span><br><span class="line">    <span class="comment">// following line.)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">    kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span></span><br><span class="line">    <span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line">    <span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line">    <span class="comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span></span><br><span class="line">    <span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line">    <span class="comment">// 创建一个struct PageInfo 的数组</span></span><br><span class="line">    <span class="comment">// kernel 使用这个数组来耿总每个物理页</span></span><br><span class="line">    <span class="comment">// 对于每一个物理页，都会有一个对应的 struct PageInfo 在数组中</span></span><br><span class="line">    pages = (struct PageInfo *) boot_alloc(npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line">    <span class="comment">// npages 是内存中物理页的数量</span></span><br><span class="line">    <span class="built_in">memset</span>(pages, <span class="number">0</span>, npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Now that we&#x27;ve allocated the initial kernel data structures, we set</span></span><br><span class="line">    <span class="comment">// up the list of free physical pages. Once we&#x27;ve done so, all further</span></span><br><span class="line">    <span class="comment">// memory management will go through the page_* functions. In</span></span><br><span class="line">    <span class="comment">// particular, we can now map memory using boot_map_region</span></span><br><span class="line">    <span class="comment">// or page_insert</span></span><br><span class="line">    page_init();</span><br><span class="line"></span><br><span class="line">    check_page_free_list(<span class="number">1</span>);</span><br><span class="line">    check_page_alloc();</span><br><span class="line">    check_page();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Now we set up virtual memory</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line">    <span class="comment">// Permissions:</span></span><br><span class="line">    <span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line">    <span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line">    <span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line">    <span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line">    <span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line">    <span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line">    <span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line">    <span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line">    <span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line">    <span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line">    <span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line">    <span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line">    <span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line">    <span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line">    <span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line">    <span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line">    <span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the initial page directory has been set up correctly.</span></span><br><span class="line">    check_kern_pgdir();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch from the minimal entry page directory to the full kern_pgdir</span></span><br><span class="line">    <span class="comment">// page table we just created. Our instruction pointer should be</span></span><br><span class="line">    <span class="comment">// somewhere between KERNBASE and KERNBASE+4MB right now, which is</span></span><br><span class="line">    <span class="comment">// mapped the same way by both page tables.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the machine reboots at this point, you&#x27;ve probably set up your</span></span><br><span class="line">    <span class="comment">// kern_pgdir wrong.</span></span><br><span class="line">    lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line">    check_page_free_list(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// entry.S set the really important flags in cr0 (including enabling</span></span><br><span class="line">    <span class="comment">// paging).  Here we configure the rest of the flags that we care about.</span></span><br><span class="line">    cr0 = rcr0();</span><br><span class="line">    cr0 |= CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_MP;</span><br><span class="line">    cr0 &amp;= ~(CR0_TS | CR0_EM);</span><br><span class="line">    lcr0(cr0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some more checks, only possible after kern_pgdir is installed.</span></span><br><span class="line">    check_page_installed_pgdir();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>page_init()</strong> 初始化页面结构和内存空闲列表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line">    <span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line">    <span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line">    <span class="comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span></span><br><span class="line">    <span class="comment">// 将页 0 标记为使用状态</span></span><br><span class="line">    pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line">    <span class="comment">//     is free.</span></span><br><span class="line">    <span class="comment">// 剩下的标为空闲状态</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;npages_basemem;++i)&#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line">    <span class="comment">//     never be allocated.</span></span><br><span class="line">    <span class="comment">// io端口, 不能被分配</span></span><br><span class="line">    <span class="keyword">for</span>(i = IOPHYSMEM/PGSIZE;i&lt;EXTPHYSMEM/PGSIZE;++i)&#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">    <span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line">    <span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line">    <span class="comment">//     page tables and other data structures?</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Change the code to reflect this.</span></span><br><span class="line">    <span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line">    <span class="comment">// free pages!</span></span><br><span class="line">    <span class="comment">// 找到第一个能分配的页面</span></span><br><span class="line">    <span class="comment">// boot_alloc有个 nextfree指针，但是是虚拟地址，我们要将其转换为物理地址 physical address</span></span><br><span class="line">    <span class="comment">// PADDR 可以实现地址的转换</span></span><br><span class="line">    <span class="keyword">size_t</span> first_free_address = PADDR(boot_alloc(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 看看extend physical memory 是不是free</span></span><br><span class="line">    <span class="keyword">for</span>(i = EXTPHYSMEM/PGSIZE;i&lt;first_free_address/PGSIZE;++i)&#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把页面设为空闲，插入链表头部</span></span><br><span class="line">    <span class="keyword">for</span> (i = first_free_address/PGSIZE; i &lt; npages; i++) &#123;</span><br><span class="line">        pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">        pages[i].pp_link = page_free_list;</span><br><span class="line">        page_free_list = &amp;pages[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>page_alloc()</strong> 完成页面的分配。</p>
<p>分配是基于PageInfo的，只是把页面标记为使用，并未真正的分配页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page2kva: page to kernel virtual address</span></span><br><span class="line"><span class="function">struct PageInfo *</span></span><br><span class="line"><span class="function"><span class="title">page_alloc</span><span class="params">(<span class="keyword">int</span> alloc_flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// 超过空闲内存的范围，则返回NULL</span></span><br><span class="line">    <span class="comment">// 所分配界面的 pp_link 设置为空, 以便page_free可以检查double-free bug。</span></span><br><span class="line">    <span class="comment">// 分配物理页面。如果(alloc_flags &amp; ALLOC_ZERO)，用&#x27;\0&#x27;字节填充整个返回的物理页面。</span></span><br><span class="line">    <span class="keyword">if</span>(page_free_list == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">allocated_page</span> =</span> page_free_list;</span><br><span class="line">    page_free_list = page_free_list-&gt;pp_link;</span><br><span class="line">    allocated_page-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(alloc_flags &amp; ALLOC_ZERO)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(page2kva(allocated_page),<span class="string">&#x27;\0&#x27;</span>,PGSIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allocated_page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>page_free()</strong></p>
<p>释放一个页面，到page_free_list中</p>
<p>(This function should only be called when pp-&gt;pp_ref reaches 0.)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a page to the free list.</span></span><br><span class="line"><span class="comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_free</span><span class="params">(struct PageInfo *pp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">    <span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line">    <span class="keyword">if</span>(pp-&gt;pp_ref&gt;<span class="number">0</span> || pp-&gt;pp_link!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        panic(<span class="string">&quot;Double check failed when dealloc page&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pp-&gt;pp_link = page_free_list;  <span class="comment">// 头插</span></span><br><span class="line">    page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用 <code>make qemu-nox</code> 运行，发现报了个panic， 需要把panic注释掉。看漏了</p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220626094749150.png" alt="image-20220626094749150"></p>
<p>![image-20220626094809597](/Users/zhangqing/Library/Application Support/typora-user-images/image-20220626094809597.png)</p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220626104146086.png" alt="image-20220626104146086"></p>
<h1 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h1><p><strong>虚拟内存</strong><br>当 cpu 拿到一个地址并根据地址访问内存时，在 x86架构下药经过至少两级的地址变换：段式变换和页式变换。分段机制的主要目的是将代码段、数据段以及堆栈段分开，保证互不干扰。分页机制则是为了实现虚拟内存。<br>虚拟内存主要的好处是：</p>
<p>让每个程序都以为自己独占计算机内存空间，概念清晰，方便程序的编译和装载。<br>通过将部分内存暂存在磁盘上，可以让程序使用比物理内存大得多的虚拟内存，突破物理内存的限制。<br>通过对不同进程设置不同页表，可以防止进程访问其他进程的地址空间。通过在不同进程之间映射相同的物理页，又可以提供进程间的共享。</p>
<p><strong>虚拟、线性和物理地址</strong></p>
<p><strong>虚拟地址</strong><br>最原始的地址，也是 C/C++ 指针使用的地址。由前 16bit 段 (segment) 选择器和后 32bit 段内的偏移 (offset) 组成，显然一个段大小为 4GB。通过虚拟地址可以获得线性地址。<br><strong>线性地址</strong><br>前 10bit 为页目录项(page directory entry, PDE)，即该地址在页目录中的索引。中间 10bit 为页表项(page table entry, PTE)，代表在页表中的索引，最后 12bit 为偏移，也就是每页 4kB。通过线性地址可以获得物理地址。</p>
<p>页目录偏移DIR ｜页表偏移Table｜页内偏移Offset</p>
<p><strong>物理地址</strong><br>经过段转换以及页面转换，最终在 RAM 的硬件总线上的地址。</p>
<p><em><strong>JOS只有一个段，因此虚拟地址在数值上等于线性地址。</strong></em></p>
<h2 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h2><p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220626152236756.png" alt="image-20220626152236756"></p>
<p>pgdir 是指向页目录的指针。</p>
<p><strong>pgdir_walk()</strong>  returns a pointer to page table entry(PTE) for linear address(va)。查找一个虚拟地址对应的页表项地址。</p>
<img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/1200.png" alt="img" style="zoom: 50%;" />

<p>在页目录项、页表项中存储的是页表项的<strong>物理地址</strong>前 20bit 外加 12bit 的 flag。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given &#x27;pgdir&#x27;, a pointer to a page directory, pgdir_walk returns</span></span><br><span class="line"><span class="comment">// a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// This requires walking the two-level page table structure.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The relevant page table page might not exist yet.</span></span><br><span class="line"><span class="comment">// If this is true, and create == false, then pgdir_walk returns NULL.</span></span><br><span class="line"><span class="comment">// Otherwise, pgdir_walk allocates a new page table page with page_alloc.</span></span><br><span class="line"><span class="comment">//    - If the allocation fails, pgdir_walk returns NULL.</span></span><br><span class="line"><span class="comment">//    - Otherwise, the new page&#x27;s reference count is incremented,</span></span><br><span class="line"><span class="comment">//	the page is cleared,</span></span><br><span class="line"><span class="comment">//	and pgdir_walk returns a pointer into the new page table page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 1: you can turn a PageInfo * into the physical address of the</span></span><br><span class="line"><span class="comment">// page it refers to with page2pa() from kern/pmap.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 2: the x86 MMU checks permission bits in both the page directory</span></span><br><span class="line"><span class="comment">// and the page table, so it&#x27;s safe to leave permissions in the page</span></span><br><span class="line"><span class="comment">// directory more permissive than strictly necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 3: look at inc/mmu.h for useful macros that manipulate page</span></span><br><span class="line"><span class="comment">// table and page directory entries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// typedef uint32_t pte_t;</span></span><br><span class="line"><span class="comment">// pgdir_walk returns a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line"><span class="function"><span class="keyword">pte_t</span> *</span></span><br><span class="line"><span class="function"><span class="title">pgdir_walk</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// pgdir 页目录项地址</span></span><br><span class="line">    <span class="comment">// va 虚拟地址，jos只有一个段，因此虚拟地址等于线性地址</span></span><br><span class="line">    <span class="comment">// create 若页目录项不存在是否创建</span></span><br><span class="line">    <span class="comment">// return  页表项指针</span></span><br><span class="line">    <span class="keyword">uint32_t</span> page_dir_index = PDX(va);</span><br><span class="line">    <span class="keyword">uint32_t</span> page_table_index = PTX(va);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pte_t</span>* pgtab;</span><br><span class="line">    <span class="keyword">if</span>(pgdir[page_dir_index] &amp;&amp; PTE_P)&#123;  <span class="comment">// 存在且可写</span></span><br><span class="line">        pgtab = KADDR(PTE_ADDR(pgdir[page_dir_index]));  <span class="comment">// KADDR-&gt;virtual address</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 不存在</span></span><br><span class="line">        <span class="keyword">if</span>(create)&#123;</span><br><span class="line">            <span class="comment">// 创建新的页表项</span></span><br><span class="line">            <span class="comment">// For page_alloc, zero the returned physical page.</span></span><br><span class="line">            <span class="comment">// ALLOC_ZERO = 1&lt;&lt;0,</span></span><br><span class="line">            struct PageInfo* new_pageInfo = page_alloc(ALLOC_ZERO);</span><br><span class="line">            <span class="keyword">if</span>(new_pageInfo)&#123;</span><br><span class="line">                new_pageInfo-&gt;pp_ref+=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 存入数组</span></span><br><span class="line">                <span class="comment">// 依次获取 table_index 和 dir_index</span></span><br><span class="line">                <span class="comment">// page2kva() page to kernel virtual address</span></span><br><span class="line">                pgtab = (<span class="keyword">pte_t</span>*)page2kva(new_pageInfo);</span><br><span class="line">                pgdir[page_dir_index] = PADDR(pgtab) | PTE_P | PTE_W | PTE_U; <span class="comment">// PADDR 虚拟到物理</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;pgtab[page_table_index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>page_lookup()</strong></p>
<p>// 返回映射到虚拟地址 va 的页面<br>// pgdir_walk 只查询，不创建，create为0<br>// pa2page 由物理地址 返回对应的页面描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map [va, va+size) of virtual address space to physical [pa, pa+size) in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and va and pa are both page-aligned.</span><br><span class="line">This function is only intended to set up the ``static&#x27;&#x27; mappings above UTOP. As such, it should *not* change the pp_ref field on the mapped pages.</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the page mapped at virtual address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// If pte_store is not zero, then we store in it the address</span></span><br><span class="line"><span class="comment">// of the pte for this page.  This is used by page_remove and</span></span><br><span class="line"><span class="comment">// can be used to verify page permissions for syscall arguments,</span></span><br><span class="line"><span class="comment">// but should not be used by most callers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return NULL if there is no page mapped at va.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk and pa2page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 返回映射到虚拟地址 va 的页面</span></span><br><span class="line"><span class="comment">// pgdir_walk 只查询，不创建，create为0</span></span><br><span class="line"><span class="comment">// pa2page 由物理地址 返回对应的页面描述</span></span><br><span class="line"><span class="function">struct PageInfo *</span></span><br><span class="line"><span class="function"><span class="title">page_lookup</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va, <span class="keyword">pte_t</span> **pte_store)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// pdgir 页目录地址</span></span><br><span class="line">    <span class="comment">// va 虚拟地址</span></span><br><span class="line">    <span class="comment">// pte_store 指向页表指针的指针 the address of the pte for this page</span></span><br><span class="line">    <span class="comment">// If pte_store is not zero, then we store in it the address of the pte for this page.</span></span><br><span class="line">    <span class="keyword">pde_t</span>* find_pgtab = pgdir_walk(pgdir, va, <span class="number">0</span>);  <span class="comment">// 根据va，返回一个指向page table entry的指针</span></span><br><span class="line">    <span class="keyword">if</span>(!find_pgtab)&#123;  <span class="comment">// 没找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到了</span></span><br><span class="line">    <span class="comment">// 再找page table的虚拟地址</span></span><br><span class="line">    <span class="keyword">if</span>(pte_store)&#123;</span><br><span class="line">        *pte_store = find_pgtab;  <span class="comment">// 保存下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回页面描述 struct PageInfo *</span></span><br><span class="line">	<span class="keyword">return</span> pa2page(PTE_ADDR(*find_pgtab));  <span class="comment">// PTE_ADDR 将页表指针指向的内容转为物理地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>page_remove()</strong> </p>
<p> 移除一个虚拟地址与对应物理地址的映射关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unmaps the physical page at virtual address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// If there is no physical page at that address, silently does nothing.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Details:</span></span><br><span class="line"><span class="comment">//   - The ref count on the physical page should decrement.</span></span><br><span class="line"><span class="comment">//   - The physical page should be freed if the refcount reaches 0.</span></span><br><span class="line"><span class="comment">//   - The pg table entry corresponding to &#x27;va&#x27; should be set to 0.</span></span><br><span class="line"><span class="comment">//     (if such a PTE exists)</span></span><br><span class="line"><span class="comment">//   - The TLB must be invalidated if you remove an entry from</span></span><br><span class="line"><span class="comment">//     the page table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The TA solution is implemented using page_lookup,</span></span><br><span class="line"><span class="comment">//     tlb_invalidate, and page_decref.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 移除一个虚拟地址与对应物理地址的映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">page_remove</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// pgdir 页目录地址</span></span><br><span class="line">    <span class="comment">// va 虚拟地址</span></span><br><span class="line">    <span class="comment">// 首先要找到 va对应的物理地址, 使用 page_lookup</span></span><br><span class="line">    <span class="comment">// page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)</span></span><br><span class="line">    <span class="keyword">pte_t</span>* pgtab;</span><br><span class="line">    <span class="keyword">pte_t</span>** pte_store = &amp;pgtab;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pInfo</span> =</span> page_lookup(pgdir, va, pte_store);</span><br><span class="line">    <span class="keyword">if</span>(!pInfo)&#123; <span class="comment">// 空的</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    page_decref(pInfo);  <span class="comment">// 减少页上的引用计数，如果没有引用则释放该计数。</span></span><br><span class="line">    *pgtab = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// tlb_invalidate(pde_t *pgdir, void *va)</span></span><br><span class="line">    tlb_invalidate(pgdir, va); <span class="comment">// 使TLB条目无效，但前提是正在编辑的页表是当前处理器正在使用的页表。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>page_insert()</strong></p>
<p>建立一个虚拟地址与物理页的映射，与page_remove() 对应。</p>
<p>The permissions (the low 12 bits) of the page table entry should be set to ‘perm|PTE_P’.</p>
<p><strong>requirement：</strong></p>
<p>// 如果已经有一个页面映射到’va’，it should be page_remove()d.</p>
<p>// 如果有必要，应按需分配一个页表，并插入到’pgdir’。</p>
<p>// 如果插入成功，pp-&gt;pp_ref应该加1。</p>
<p>// TLB必须无效，如果 ‘va’ 对应的一个页面已经存在。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立一个虚拟地址与物理页的映射，与page_remove() 对应</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">page_insert</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// pgdir 页目录指针</span></span><br><span class="line">    <span class="comment">// pp 页描述结构体 指针</span></span><br><span class="line">    <span class="comment">// va  虚拟地址</span></span><br><span class="line">    <span class="comment">// perm  权限</span></span><br><span class="line">    <span class="keyword">pte_t</span>* pgtab = pgdir_walk(pgdir, va, <span class="number">1</span>); <span class="comment">// 查询该虚拟地址对应的页表项(struct PageInfo)，不存在则建立</span></span><br><span class="line">    <span class="keyword">if</span>(!pgtab)&#123;  <span class="comment">// 建立失败</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立成功</span></span><br><span class="line">    <span class="keyword">if</span>(*pgtab &amp;&amp; PTE_P)&#123;  <span class="comment">// 可以写入</span></span><br><span class="line">        <span class="comment">// 若该虚拟地址va已经映射到了其他物理页</span></span><br><span class="line">        <span class="keyword">if</span>(page2pa(pp) == PTE_ADDR(*pgtab))&#123;  <span class="comment">// PTE_ADDR Address in page table or page directory entry</span></span><br><span class="line">            <span class="comment">// 更改权限，不增加引用</span></span><br><span class="line">            *pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 更新映射的物理页，则需要删除之前的映射关系</span></span><br><span class="line">            page_remove(pgdir, va);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除后建立新的物理页</span></span><br><span class="line">    *pgtab = page2pa(pp) | perm | PTE_P;</span><br><span class="line">    pp-&gt;pp_ref++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>boot_map_region()</strong></p>
<p>映射一片虚拟页到制定物理页，大小为size， size是PGSIZE的倍数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map [va, va+size) of virtual address space to physical [pa, pa+size)</span></span><br><span class="line"><span class="comment">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and</span></span><br><span class="line"><span class="comment">// va and pa are both page-aligned.</span></span><br><span class="line"><span class="comment">// Use permission bits perm|PTE_P for the entries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function is only intended to set up the ``static&#x27;&#x27; mappings</span></span><br><span class="line"><span class="comment">// above UTOP. As such, it should *not* change the pp_ref field on the</span></span><br><span class="line"><span class="comment">// mapped pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk</span></span><br><span class="line"><span class="comment">// 映射一片虚拟页到指定物理页，大小为size， size是PGSIZE的倍数</span></span><br><span class="line"><span class="comment">// va -&gt; pa</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">boot_map_region</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">    <span class="comment">// *pgdir 页目录指针</span></span><br><span class="line">    <span class="comment">// va 虚拟地址</span></span><br><span class="line">    <span class="comment">// size size是PGSIZE的倍数，</span></span><br><span class="line">    <span class="comment">// pa 物理地址</span></span><br><span class="line">    <span class="comment">// perm 权限</span></span><br><span class="line">    <span class="comment">// 直接使用页数来分配，避免溢出</span></span><br><span class="line">    <span class="keyword">pte_t</span>* pgtab;</span><br><span class="line">    <span class="keyword">size_t</span> pg_count = PGNUM(size);  <span class="comment">// size能分成多少页</span></span><br><span class="line">    <span class="comment">// pte_t* pgdir_walk(pde_t *pgdir, const void *va, int create)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i&lt;pg_count;++i)&#123;</span><br><span class="line">        pgtab = pgdir_walk(pgdir, (<span class="keyword">void</span>*)va, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// pgdir_walk returns a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line">        *pgtab = pa | perm | PTE_P; <span class="comment">// 权限</span></span><br><span class="line">        va+=PGSIZE;</span><br><span class="line">        pa+=PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220627153213219.png" alt="image-20220627153213219"></p>
<h1 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h1><p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220627204004274.png" alt="image-20220627204004274"></p>
<p>JOS将处理器的32位线性地址划分为 用户地址()  和  内核地址()，二者以ULIM划分。</p>
<p>计算可得出一个物理页大小是4MB</p>
<p>ULIM = (MMIOLIM - PTSIZE) = (KSTACKTOP - PTSIZE - PTSIZE) = 0xF0000000 - 0x00400000 - 0x00400000 = 0xef800000</p>
<p>查看memlayout.h 可以看到，的确为0xef800000</p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220627204422272.png" alt="image-20220627204422272"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line"><span class="comment">// UPAGES是JOS记录物理页面使用情况的数据结构，只有kernel能够访问</span></span><br><span class="line"><span class="comment">// 但是现在需要让用户空间能够读取这段线性地址，因此需要建立映射，将用户空间的一块内存映射到存储该数据结构的物理地址上</span></span><br><span class="line"><span class="comment">// boot_map_region() 建立映射关系</span></span><br><span class="line">boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)UPAGES, npages*<span class="keyword">sizeof</span>(struct PageInfo), PADDR(pages), PTE_U | PTE_P);</span><br><span class="line"><span class="comment">// 目前建立了一个页目录，kernel_pgdir</span></span><br><span class="line"><span class="comment">// pgdir为页目录指针， UPAGES为虚拟地址，npages*sizeof(struct* PageInfo)为映射的内存块大小</span></span><br><span class="line"><span class="comment">// PADDR(pages) 为物理地址， PTE_U | PTE为权限 (PTE_U 表示用户可读)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line"><span class="comment">// kernel  内核栈</span></span><br><span class="line"><span class="comment">// kernel stack 从虚拟地址 KSTACKTOP 开始，向低地址增长，所以KSTACKTOP实际上是栈顶</span></span><br><span class="line"><span class="comment">// KSTACKTOP = 0xf0000000，</span></span><br><span class="line"><span class="comment">// KSTKSIZE = (8*PGSIZE) = 8*4096(bytes) = 32KB</span></span><br><span class="line"><span class="comment">// 只需要映射 [KSTACKTOP, KSTACKTOP - KSTKSIZE) 范围的虚拟地址</span></span><br><span class="line">boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)(KSTACKTOP - KSTKSIZE), KSTKSIZE, PADDR(bootstack), PTE_W | PTE_P);</span><br><span class="line"><span class="comment">// PTE_W 开启了写权限，但是并未打开 PTE_U， 因此用户没有权限，只有内核有权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line"><span class="comment">// 内核部分</span></span><br><span class="line"><span class="comment">// KERNBASE    = 0xF0000000， VA大小为 2^32 - KERNBASE</span></span><br><span class="line"><span class="comment">// ROUNDUP(a,n) 将a四舍五入到最接近n的倍数</span></span><br><span class="line">boot_map_region(kern_pgdir, (<span class="keyword">uintptr_t</span>)KERNBASE, ROUNDUP(<span class="number">0xffffffff</span> - KERNBASE + <span class="number">1</span>, PGSIZE), <span class="number">0</span>, PTE_W | PTE_P);</span><br></pre></td></tr></table></figure>





<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220628111506229.png" alt="image-20220628111506229"></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><ol>
<li><p><strong>此时，页面目录中填写了哪些条目（行）？他们映射什么地址，指向哪里？换句话说，尽可能多地填写这张表格：</strong></p>
<table>
<thead>
<tr>
<th>入口</th>
<th>基本虚拟地址</th>
<th>指向（逻辑上）：</th>
</tr>
</thead>
<tbody><tr>
<td>1023</td>
<td>0xffc00000</td>
<td>page table for [252,256)MB of physical address</td>
</tr>
<tr>
<td>1022</td>
<td>0xff900000</td>
<td>page table for [248,252)MB of physical address</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>960</td>
<td>0xf0000000</td>
<td>page table for [0,4)MB of physical address</td>
</tr>
<tr>
<td>959</td>
<td>0xefc00000</td>
<td></td>
</tr>
<tr>
<td>958</td>
<td>0xef800000</td>
<td>ULIM</td>
</tr>
<tr>
<td>957</td>
<td>0xef400000</td>
<td>State register (UVPT)</td>
</tr>
<tr>
<td>956</td>
<td>0xef000000</td>
<td>UPAGES, array of PageInfo</td>
</tr>
<tr>
<td>955</td>
<td>0xeec00000</td>
<td>UPAGES, array of PageInfo</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>NULL</td>
</tr>
<tr>
<td>1</td>
<td>0x00400000</td>
<td>NULL</td>
</tr>
<tr>
<td>0</td>
<td>0x00000000</td>
<td><strong>same as 960</strong></td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User read-only virtual page table (see &#x27;uvpt&#x27; below)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UVPT      (ULIM - PTSIZE)</span></span><br><span class="line"><span class="comment">// Read-only copies of the Page structures</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UPAGES    (UVPT - PTSIZE)</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>我们已将内核和用户环境放置在同一地址空间中。为什么用户程序无法读取或写入内核的内存？哪些特定机制可以保护内核内存？</strong></p>
<p>页表内的标记位可以设置权限，PTE_U设置为1，用户才有权利读写。</p>
</li>
<li><p><strong>这个操作系统可以支持的最大物理内存量是多少？为什么？</strong></p>
<p>UPAGES 大小是4096bytes，即4MB，每个结构体 PageInfo 占8bytes。指针占4字节，uint16_t占两字节，对齐后8字节。</p>
<p>那么共有 4MB / 8B = 2^19 页，</p>
<p>每页的大小PGSIZE = 4096 bytes</p>
<p>那么最多使用 2^19 * 4096 = 2^31 = 2GB 的物理内存</p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220628152236712.png" alt="image-20220628152236712"></p>
</li>
<li><p><strong>如果我们真的有最大数量的物理内存，有多少空间来管理内存？这个开销是怎么分解的？</strong></p>
<p>为2GB的最大内存时，UPAGES的大小为4MB，page table directory 的大小为4MB, 一共8MB。 </p>
</li>
<li><p><strong>重新访问<code>kern/entry.S</code>和<code>kern/entrypgdir.c</code>中的页面表设置。在我们打开分页后，EIP仍然是一个低数字（略高于1MB）。我们什么时候过渡到KERNBASE上方的EIP运行？when we enable paging and  when we begin running at an EIP above KERNBASE，是什么使我们能够继续以低EIP执行？为什么需要这种过渡？</strong></p>
<p>EIP寄存器存储着CPU读取的下一条指令的地址，相当于PC计数器。在8086中，EIP=PC。</p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220628163341015.png" alt="image-20220628163341015"></p>
</li>
</ol>
<p>在jmp处打上断点，向后执行一步，产生了映射，分页机制启动</p>
<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220628163655193.png" alt="image-20220628163655193"></p>
<p>把虚拟地址的[0,4M) [KERNBASE, KERNBASE+4M)两个区间都映射到同一个物理地址区间[0,4M)的原因在于不要让指令的寻址受到地址空间变化的影响。</p>
<ul>
<li>Display in a useful and easy-to-read format all of the physical page mappings (or lack thereof) that apply to a particular range of virtual/linear addresses in the currently active address space. For example, you might enter <code>&#39;showmappings 0x3000 0x5000&#39;</code> to display the physical page mappings and corresponding permission bits that apply to the pages at virtual addresses 0x3000, 0x4000, and 0x5000.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加lab2 中的映射函数，以显示pa和va的对应关系</span></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">mon_showmappings</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数个数</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;invalid arguments num. \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数个数符合，那么依次提取pa和va</span></span><br><span class="line">    <span class="keyword">char</span> *errChar;</span><br><span class="line">    <span class="keyword">uintptr_t</span> start_addr = strtol(argv[<span class="number">1</span>], &amp;errChar, <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// typedef uint32_t uintptr_t;   uintptr_t represents the numerical value of virtual address.</span></span><br><span class="line">    <span class="keyword">if</span>(*errChar)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;invalid virtual address. \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_addr = strtol(argv[<span class="number">2</span>], &amp;errChar, <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">if</span>(*errChar)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;invalid virtual address. \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start_addr &gt; end_addr)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;address 1 should be lower than address 2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按页对齐</span></span><br><span class="line">    start_addr = ROUNDDOWN(start_addr, PGSIZE);</span><br><span class="line">    end_addr = ROUNDUP(end_addr, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次访问</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cur_addr = start_addr;</span><br><span class="line">    <span class="keyword">while</span>(cur_addr &lt;= end_addr)&#123;</span><br><span class="line">        <span class="comment">// 查询当前地址，没有则创建</span></span><br><span class="line">        <span class="keyword">pte_t</span> *cur_pte = pgdir_walk(kern_pgdir, (<span class="keyword">void</span>*)cur_addr, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// pgdir_walk() returns a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line">        <span class="keyword">if</span>(!cur_pte || !(cur_pte &amp;&amp; PTE_P))&#123;</span><br><span class="line">            cprintf(<span class="string">&quot;virtual address [%08x] - not mapped\n&quot;</span>, cur_addr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cprintf(<span class="string">&quot;virtual address [%08x] - physical address [%08x], permission&quot;</span>, cur_addr, PTE_ADDR(*cur_pte));</span><br><span class="line">            <span class="comment">// 查询三种权限</span></span><br><span class="line">            <span class="keyword">char</span> perm_PS = (*cur_pte &amp; PTE_PS)?<span class="string">&#x27;S&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">char</span> perm_W = (*cur_pte &amp; PTE_W)?<span class="string">&#x27;W&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">char</span> perm_U = (*cur_pte &amp; PTE_U)?<span class="string">&#x27;U&#x27;</span>:<span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            cprintf(<span class="string">&quot;=%c===%c%cP\n&quot;</span>, perm_PS, perm_W, perm_U);</span><br><span class="line">        &#125;</span><br><span class="line">        cur_addr += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/qqqqqqqzzzzzzzzz/software/raw/master/img/image-20220628213911940.png" alt="image-20220628213911940"></p>
<p>参考ref：<a target="_blank" rel="noopener" href="https://www.jianshu.com/u/6913c26d8b2c">https://www.jianshu.com/u/6913c26d8b2c</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/25/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%AD%90%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/25/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%AD%90%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">前缀和与子数组</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-25 10:48:09" itemprop="dateCreated datePublished" datetime="2022-05-25T10:48:09+08:00">2022-05-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-26 17:20:40" itemprop="dateModified" datetime="2022-05-26T17:20:40+08:00">2022-05-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>相似题目</strong></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/">467. 环绕字符串中唯一的子字符串</a>(中等)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-subarrays-with-bounded-maximum/">795.区间子数组个数</a>(中等)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fruit-into-baskets/">904. 水果成篮</a>(中等)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">992. K 个不同整数的子数组</a>（困难）</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a>（中等）</p>
</li>
</ul>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/range-sum-query-immutable/description/">303. 区域和检索 - 数组不可变</a></li>
<li><a href="https://leetcode.cn/link/?target=https://lucifer.ren/blog/2019/12/11/leetcode-1186/">1186.删除一次得到子数组最大和</a></li>
<li><a href="https://leetcode.cn/link/?target=https://lucifer.ren/blog/2020/01/09/1310.xor-queries-of-a-subarray/">1310. 子数组异或查询</a></li>
<li><a href="https://leetcode.cn/link/?target=https://github.com/azl397985856/leetcode/blob/master/problems/1371.find-the-longest-substring-containing-vowels-in-even-counts.md">1371. 每个元音包含偶数次的最长子字符串</a></li>
</ul>
<p>ref : <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-substrings-in-wraparound-string/solution/xi-fa-dai-ni-xue-suan-fa-yi-ci-gao-ding-qian-zhui-/">https://leetcode.cn/problems/unique-substrings-in-wraparound-string/solution/xi-fa-dai-ni-xue-suan-fa-yi-ci-gao-ding-qian-zhui-/</a></p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="例题1-presum"><a href="#例题1-presum" class="headerlink" title="例题1 (presum)"></a>例题1 (presum)</h2><p>有 N 个的正整数放到数组 A 里，现在要求一个新的数组 B，新数组的第 i 个数 B[i]是原数组 A 第 0 到第 i 个数的和。</p>
<p>求解：正常前缀和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; sum;</span><br><span class="line"><span class="keyword">int</span> n = sum.<span class="built_in">size</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">psum</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">psum1</span><span class="params">(n)</span></span>;</span><br><span class="line">psum[i] = psum[i<span class="number">-1</span>]+sum[i];   <span class="comment">// [l,r] -&gt;  psum[r] - psum[l-1]</span></span><br><span class="line">psum1[i] = psum[i<span class="number">-1</span>]+sum[i<span class="number">-1</span>]; <span class="comment">// [l, r] -&gt; psum[r+1] - psum[l];</span></span><br></pre></td></tr></table></figure>

<h2 id="例题2-countArray"><a href="#例题2-countArray" class="headerlink" title="例题2 (countArray)"></a>例题2 (countArray)</h2><p>求一个数组的连续子数组总个数。比如 [1,3,4]，其连续子数组有：<code>[1], [3], [4], [1,3], [3,4] , [1,3,4]</code>，需要返回 6。</p>
<p>总的连续子数组个数等于：<strong>以索引为 0 结尾的子数组个数 + 以索引为 1 结尾的子数组个数 + … + 以索引为 n - 1 结尾的子数组个数</strong>。</p>
<p><strong>利用 例题1 的前缀和思路， 边遍历边求和。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a: nums)&#123;</span><br><span class="line">        temp+=<span class="number">1</span>;</span><br><span class="line">        ans+=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度：<em>O</em>(N)，其中 N 为数组长度。</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="例题3-countArrayGapK"><a href="#例题3-countArrayGapK" class="headerlink" title="例题3 (countArrayGapK)"></a>例题3 (countArrayGapK)</h2><p>求一个数组相邻差为 1 连续子数组的总个数，就是<strong>索引差 1 的同时，值也差 1。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArrayGap1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] = nums[i<span class="number">-1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">            temp+=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="例题4-countArrayLessEqualK"><a href="#例题4-countArrayLessEqualK" class="headerlink" title="例题4 (countArrayLessEqualK)"></a>例题4 (countArrayLessEqualK)</h2><p>求出不大于 k 的子数组的个数。不大于 k 指的是子数组的全部元素都不大于 k。 比如 [1,3,4] 子数组有 [1], [3], [4], [1,3], [3,4] , [1,3,4]，不大于 3 的子数组有 [1], [3], [1,3] ，那么 [1,3,4] 不大于 3 的子数组个数就是 3。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArrayLessK</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt;= k)&#123;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="例题5-countArraMostEqualK"><a href="#例题5-countArraMostEqualK" class="headerlink" title="例题5(countArraMostEqualK)"></a>例题5(countArraMostEqualK)</h2><p>求出子数组最大值刚好是 k 的子数组的个数。 比如 [1,3,4] 子数组有 [1], [3], [4], [1,3], [3,4] , [1,3,4]，子数组最大值刚好是 3 的子数组有 [3], [1,3] ，那么 [1,3,4] 子数组最大值刚好是 3 的子数组个数就是 2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArraMostEqualK</span><span class="params">(<span class="keyword">int</span> k1, <span class="keyword">int</span> k2, vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子数组最大值刚好是k的子数组</strong>的个数 countArraMostEqualK可以使用<strong>求不大于k的子数组</strong>的方法countArrayLessEqualK 来求解，即 </p>
<p><code>countArraMostEqualK(k) = countArrayLessK (k) - countArrayLessK (k-1)</code></p>
<h2 id="例题6-countArraBetween"><a href="#例题6-countArraBetween" class="headerlink" title="例题6 (countArraBetween)"></a>例题6 (countArraBetween)</h2><p>求出子数组最大值刚好是 介于 k1 和 k2 的子数组的个数。</p>
<p><code>countArraBetween(k1, k2, nums)</code> 等价于 </p>
<p><code>countArrayLessK(k2, nums) - countArrayLessK(k1 - 1, nums), k2&gt;k1</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countArraBetween</span><span class="params">(<span class="keyword">int</span> k1, <span class="keyword">int</span> k2, vector&lt;<span class="keyword">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小于等于 k2 的区域</strong> 减去  <strong>小于 k1 的区域</strong> 就是 <strong>大于等于 k1 且小于等于 k2 的区域</strong>。</p>
<h1 id="467-环绕字符串中唯一的子字符串"><a href="#467-环绕字符串中唯一的子字符串" class="headerlink" title="467. 环绕字符串中唯一的子字符串"></a>467. 环绕字符串中唯一的子字符串</h1><p>把字符串 s 看作是 “abcdefghijklmnopqrstuvwxyz” 的无限环绕字符串，所以 s 看起来是这样的：</p>
<p>“…zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd….” .<br>现在给定另一个字符串 p 。返回 s 中 唯一 的 p 的 非空子串 的数量 。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: p = &quot;a&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 字符串 s 中只有一个&quot;a&quot;子字符。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: p = &quot;cac&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 字符串 s 中的字符串“cac”只有两个子串“a”、“c”。.</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: p = &quot;zab&quot;</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在字符串 s 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示:</span><br><span class="line">1 &lt;= p.length &lt;= 10^5</span><br><span class="line">p 由小写英文字母构成</span><br></pre></td></tr></table></figure>

<p>套模板3</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case467</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((p[i] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; p[i<span class="number">-1</span>] ==<span class="string">&#x27;z&#x27;</span>) || (p[i]-<span class="string">&#x27;a&#x27;</span>) == (p[i<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">26</span> + <span class="number">1</span>)%<span class="number">26</span>)&#123;</span><br><span class="line">            <span class="comment">// 连续</span></span><br><span class="line">            temp++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不连续</span></span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接套模板是错误的，因为对于<strong>cac</strong>这种情况，返回值是3， 但实际上是2，因为c被计算了两次，这就意味着需要去重，如果对于输入<code>abcd</code>使用set去重可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">ab (a, b)</span><br><span class="line">cd  (c, d)</span><br><span class="line">abc (a,b,c,ab,bc,abc)</span><br><span class="line">bcd (b,c,d,bc,cd,bcd)</span><br><span class="line">abcd (....)</span><br></pre></td></tr></table></figure>

<p>发现set中的元素是连续的，那么只用记录以某个字母为结束点的最大长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">case467</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">26</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((p[i] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; p[i<span class="number">-1</span>] ==<span class="string">&#x27;z&#x27;</span>) || (p[i]-<span class="string">&#x27;a&#x27;</span>) == (p[i<span class="number">-1</span>] - <span class="string">&#x27;a&#x27;</span> + <span class="number">26</span> + <span class="number">1</span>)%<span class="number">26</span>)&#123;</span><br><span class="line">            <span class="comment">// 连续</span></span><br><span class="line">            temp++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不连续</span></span><br><span class="line">            temp = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[p[i]-<span class="string">&#x27;a&#x27;</span>] = <span class="built_in">max</span>(dp[p[i]-<span class="string">&#x27;a&#x27;</span>], temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="795-区间子数组个数"><a href="#795-区间子数组个数" class="headerlink" title="795. 区间子数组个数"></a>795. 区间子数组个数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围 [left, right] 内的子数组，并返回满足条件的子数组的个数。</span><br><span class="line"></span><br><span class="line">生成的测试用例保证结果符合 32-bit 整数范围。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,1,4,3], left = 2, right = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：满足条件的三个子数组：[2], [2, 1], [3]</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,9,2,5,6], left = 2, right = 8</span><br><span class="line">输出：7</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= nums.length &lt;= 10^5</span><br><span class="line">0 &lt;= nums[i] &lt;= 10^9</span><br><span class="line">0 &lt;= left &lt;= right &lt;= 10^9</span><br></pre></td></tr></table></figure>

<p>可以看到满足例题6， countArrayBetween， 可以使用 <code>mostK(right) - mostK(left - 1)</code>来解决</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubarrayBoundedMax</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(vector&lt;<span class="keyword">int</span>&gt;&amp;, <span class="keyword">int</span>)&gt; atMostK = [&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt;= k)&#123;</span><br><span class="line">                    temp++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    temp = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans+=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">atMostK</span>(nums, right) - <span class="built_in">atMostK</span>(nums, left - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904. 水果成篮"></a>904. 水果成篮</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</span><br><span class="line"></span><br><span class="line">你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</span><br><span class="line"></span><br><span class="line">你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。</span><br><span class="line">你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。</span><br><span class="line">一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。</span><br><span class="line">给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：fruits = [1,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘全部 3 棵树。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：fruits = [0,1,2,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：可以采摘 [1,2,2] 这三棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：fruits = [1,2,3,2,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：可以采摘 [2,3,2,2] 这四棵树。</span><br><span class="line">如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：可以采摘 [1,2,1,1,2] 这五棵树。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= fruits.length &lt;= 10^5</span><br><span class="line">0 &lt;= fruits[i] &lt; fruits.length</span><br></pre></td></tr></table></figure>

<p>就是给你一个数组， 让你<strong>选定一个子数组， 这个子数组最多只有两种数字</strong>，这个选定的子数组最大可以是多少。</p>
<p>和例题四一个样，只不过lessEqual判断为辨别可使用篮子的个数。采摘要连续</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = fruits.<span class="built_in">size</span>();</span><br><span class="line">	unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 记录需要删除水果的起始下标</span></span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mp[fruits[i]] == <span class="number">0</span>) &#123; <span class="comment">// 没使用过</span></span><br><span class="line">			--k;</span><br><span class="line">		&#125;</span><br><span class="line">		mp[fruits[i]]++;</span><br><span class="line">		<span class="keyword">while</span> (k &lt; <span class="number">0</span>) &#123;  <span class="comment">// 有新水果进来，篮子已超出了两个</span></span><br><span class="line">			<span class="comment">// 直至删除空了一种水果，画图好理解</span></span><br><span class="line">			mp[fruits[j]]--;</span><br><span class="line">			<span class="keyword">if</span> (mp[fruits[j]] == <span class="number">0</span>) &#123;</span><br><span class="line">				++k;</span><br><span class="line">			&#125;</span><br><span class="line">			j++; </span><br><span class="line">		&#125;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, i - j + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="992-K-个不同整数的子数组"><a href="#992-K-个不同整数的子数组" class="headerlink" title="992. K 个不同整数的子数组"></a>992. K 个不同整数的子数组</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个正整数数组 nums和一个整数 k ，返回 num 中 「好子数组」 的数目。</span><br><span class="line"></span><br><span class="line">如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。</span><br><span class="line"></span><br><span class="line">例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。</span><br><span class="line">子数组 是数组的 连续 部分。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,1,2,3], k = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,2,1,3,4], k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= nums.length &lt;= 2 * 10^4</span><br><span class="line">1 &lt;= nums[i], k &lt;= nums.length</span><br></pre></td></tr></table></figure>

<p>条件为不同数字的个数。用个set，不断剔除掉最早出现的数字。</p>
<p>由例题 6，知：<code>equalK = MostEqualK(k) - MostEqualK(k - 1)</code>， 因此答案便呼之欲出了。其他部分和上面的题目 <strong>904. 水果成篮</strong> 一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> mostEqualK = [&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)-&gt;<span class="keyword">int</span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 保存最早出现的数字</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[nums[i]] == <span class="number">0</span>)&#123;  <span class="comment">// 没出现过，加进去</span></span><br><span class="line">                --k; <span class="comment">// 剩余的不同数目减一</span></span><br><span class="line">            &#125;</span><br><span class="line">            mp[nums[i]]++;</span><br><span class="line">            <span class="comment">// 没出现过的数字加进去后发现超出了不同数字的要求值</span></span><br><span class="line">            <span class="keyword">while</span>(k&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                mp[nums[j]]--;</span><br><span class="line">                <span class="keyword">if</span>(mp[nums[j]] == <span class="number">0</span>)&#123;  <span class="comment">// 直至清空前面任何一个数字</span></span><br><span class="line">                    <span class="comment">// 因为删除空的数字之前的那部分也是不能使用的，因为不连续</span></span><br><span class="line">                    ++k; <span class="comment">// k从-1归0， 此时正好用完</span></span><br><span class="line">                &#125;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (i - j + <span class="number">1</span>);  <span class="comment">// 按照之前求countArray的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mostEqualK</span>(nums, k) - <span class="built_in">mostEqualK</span>(nums, k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a>1109. 航班预订统计</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">这里有 n 个航班，它们分别从 1 到 n 进行编号。</span><br><span class="line"></span><br><span class="line">有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</span><br><span class="line">请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2   3   4   5</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       20  20</span><br><span class="line">预订记录 3 ：       25  25  25  25</span><br><span class="line">总座位数：      10  55  45  25  25</span><br><span class="line">因此，answer = [10,55,45,25,25]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：bookings = [[1,2,10],[2,2,15]], n = 2</span><br><span class="line">输出：[10,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       15</span><br><span class="line">总座位数：      10  25</span><br><span class="line">因此，answer = [10,25]</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1 &lt;= n &lt;= 2 * 10^4</span><br><span class="line">1 &lt;= bookings.length &lt;= 2 * 10^4</span><br><span class="line">bookings[i].length == 3</span><br><span class="line">1 &lt;= firsti &lt;= lasti &lt;= n</span><br><span class="line">1 &lt;= seatsi &lt;= 10^4</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 差分数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;bookings.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            nums[bookings[i][<span class="number">0</span>]<span class="number">-1</span>] += bookings[i][<span class="number">2</span>];</span><br><span class="line">            nums[bookings[i][<span class="number">1</span>]] -= bookings[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            nums[i]+=nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/6-828Lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/17/6-828Lab1/" class="post-title-link" itemprop="url">6.828Lab1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-17 12:00:23" itemprop="dateCreated datePublished" datetime="2022-05-17T12:00:23+08:00">2022-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-03 17:00:17" itemprop="dateModified" datetime="2022-06-03T17:00:17+08:00">2022-06-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="PC-Bootstrap"><a href="#PC-Bootstrap" class="headerlink" title="PC Bootstrap"></a>PC Bootstrap</h1><h2 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h2><img src="https://s2.loli.net/2022/05/23/apzkU1cGI5YCqgR.png" alt="image-20220517122025755" style="zoom: 67%;" />

<ul>
<li>早期PC，16位，只有可用物理地址只有1M(0x00000000~0x000FFFFF)</li>
<li>最重要的部分是**Basic Input/Output System (BIOS)**，它占据从0x000F0000到0x000FFFFF的64KB区域。在早期的pc机中，BIOS保存在read-only memory (ROM)中，现在pc机将BIOS存储在updateable flash memory(可更新的闪存)中。</li>
<li>BIOS负责执行基本的系统初始化，如激活显卡和检查已安装的内存数量。在执行此初始化之后，BIOS从某些适当的位置(如 floppy disk(软盘), hard disk, CD-ROM, or the network)加载操作系统，并将机器的控制权传递给操作系统。</li>
<li>虽然现在可以处理器支持4GB的物理地址空间了，但还是保留那1MB的物理地址的设定来向后兼容</li>
</ul>
<h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><p>学习boot.s,main.c,boot.asm，了解在GDB中执行the boot loader时发生了什么？</p>
<p>在地址 0x7c00 处设置断点，它是加载后的引导扇区的位置。继续运行，直到那个断点。在 <code>boot/boot.S</code> 中跟踪代码，使用源代码和反汇编文件 <code>obj/boot/boot.asm</code> 去保持跟踪。</p>
<p>在 <code>boot/main.c</code> 文件中跟踪进入 <code>bootmain()</code> ，然后进入 <code>readsect()</code>。识别 <code>readsect()</code> 中相关的每一个语句的准确汇编指令。跟踪 <code>readsect()</code> 中剩余的指令，然后返回到 <code>bootmain()</code> 中，识别 <code>for</code> 循环的开始和结束位置，这个循环从磁盘上读取内核的剩余扇区。找出循环结束后运行了什么代码，在这里设置一个断点，然后继续。接下来再走完引导加载器的剩余工作。</p>
<p>完成之后，就能够回答下列的问题了：</p>
<ul>
<li><strong>处理器开始运行 32 代码时指向到什么地方？从 16 位模式切换到 32 位模式的真实原因是什么？</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Jump to next instruction, but in 32-bit code segment.</span><br><span class="line"># Switches processor into 32-bit mode.</span><br><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br><span class="line">  7c2d:    ea 32 7c 08 00 66 b8   ljmp   $0xb866,$0x87c32</span><br></pre></td></tr></table></figure>

<p>在boot.asm 这里切换到32位代码。应该是经过64与60端口的控制，加载完<strong>GDT</strong>表后，<strong>CRO的bit0位为1</strong>，此时机器已处于保护模式，故处理器从16位模式转为32位模式。</p>
<p>全局描述表(GDT Global Descriptor Table):在保护模式下一个重要的数据结构。用来存储内存的分段信息。</p>
<p>GDT可以被放在内存的任何位置，那么当程序员通过段寄存器来引用一个段描述符时，CPU必须知道GDT的入口，也就是基地址放在哪里，所以Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址，程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。</p>
<ul>
<li><strong>引导加载器执行的最后一个指令是什么，内核加载之后的第一个指令是什么？</strong></li>
</ul>
<p>引导加载程序的最后一条指令是boot/main.c中bootmain函数最后的<code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code> 这个第一条指令位于/kern/entry.S文件中，第一句 movw $0x1234, 0x472</p>
<img src="https://s2.loli.net/2022/05/17/PDW1a34oZVg8Ytd.png" alt="image-20220517140436330" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/17/5mKUDGAswoZbuIt.png" alt="image-20220517140447848" style="zoom:67%;" />



<ul>
<li><strong>内核的第一个指令在哪里？</strong></li>
</ul>
<p>位于<code>/kern/entry.S</code>文件中</p>
<ul>
<li><strong>为从硬盘上获取完整的内核，引导加载器如何决定有多少扇区必须被读入？在哪里能找到这些信息？</strong></li>
</ul>
<p>通过<code>ELF program headers</code>决定，他在操作系统内核映像文件的ELF头部信息里找到。</p>
<p>Examine the full list of the names, sizes, and link addresses of all the sections in the kernel executable by typing:</p>
<p><img src="https://s2.loli.net/2022/05/17/ZRyWbj38usFvmN9.png" alt="image-20220517155248619"></p>
<ul>
<li><code>.text</code>：程序的可运行指令。</li>
<li><code>.rodata</code>：只读数据，比如，由 C 编译器生成的 ASCII 字符串常量。（然而我们并不需要操心设置硬件去禁止写入它）</li>
<li><code>.data</code>：保持在程序的初始化数据中的数据节，比如，初始化声明所需要的全局变量，比如，像 <code>int x = 5;</code>。</li>
</ul>
<p>look at the <code>.text</code> section of the boot loader:</p>
<p><img src="https://s2.loli.net/2022/05/17/3fRjomwzLVUyE6h.png" alt="image-20220517155417627"></p>
<h3 id="Exercise4"><a href="#Exercise4" class="headerlink" title="Exercise4"></a>Exercise4</h3><p>下载 <a target="_blank" rel="noopener" href="https://sipb.mit.edu/iap/6.828/files/pointers.c">pointers.c</a> 的源代码，运行它，然后确保你理解了输出值的来源的所有内容。尤其是，确保你理解了第 1 行和第 6 行的指针地址的来源、第 2 行到第 4 行的值是如何得到的、以及为什么第 5 行指向的值表面上看像是错误的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">16</span>);  <span class="comment">//一个int四个字节，共16个字节</span></span><br><span class="line">    <span class="keyword">int</span> *c;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	a[i] = <span class="number">100</span> + i;</span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">200</span>;  <span class="comment">// c指向a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c[<span class="number">1</span>] = <span class="number">300</span>;</span><br><span class="line">    *(c + <span class="number">2</span>) = <span class="number">301</span>;</span><br><span class="line">    <span class="number">3</span>[c] = <span class="number">302</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = c + <span class="number">1</span>;  <span class="comment">// c指向a[1]。由于a中存int，一个int占四个字节，所以c的地址会+4，而不是+1</span></span><br><span class="line">    *c = <span class="number">400</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    c = (<span class="keyword">int</span> *) ((<span class="keyword">char</span> *) c + <span class="number">1</span>);  </span><br><span class="line">    <span class="comment">//如果先将c转化为字符串，再直接对字符串+1，这样导致c实际地址就是+1</span></span><br><span class="line">    *c = <span class="number">500</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,</span><br><span class="line">	   a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    b = (<span class="keyword">int</span> *) a + <span class="number">1</span>;</span><br><span class="line">    c = (<span class="keyword">int</span> *) ((<span class="keyword">char</span> *) a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;6: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> ac, <span class="keyword">char</span> **av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/05/17/t9ayFTDzYM75lJw.png" alt="img" style="zoom:67%;" />

<p><strong>如果先将c转化为字符串，再直接对字符串+1，这样导致c实际地址就是+1，从<code>0x7fffd33e72c4</code>到<code>0x7fffd33e72c5</code></strong></p>
<h5 id="c-int-char-c-1-与c-c-1的区别"><a href="#c-int-char-c-1-与c-c-1的区别" class="headerlink" title="c = (int *) ((char *) c + 1) 与c=c+1的区别"></a>c = (int *) ((char *) c + 1) 与c=c+1的区别</h5><p><img src="https://s2.loli.net/2022/05/17/8CJDEayGtXoR3wp.png" alt="image-20220517161940295"></p>
<img src="https://s2.loli.net/2022/05/17/lh1UiAVvbOWjLay.png" alt="image-20220517162003852" style="zoom:67%;" />

<p>转换为char后，c只向前移动了1位，即八个bit。</p>
<p>*c=500，将灰色框内的值变为500.</p>
<img src="https://s2.loli.net/2022/05/17/4WlqerkMhyTUCsc.png" alt="image-20220517162103314" style="zoom:67%;" />

<p><strong>其他</strong><br>如果int *p=(int*)100,则(int)p+1和(int)(p+1)不同，前者是101，但后者是104。当指针加整数时，向第二个例子，整数隐式乘以指针所指向的对象的大小。<br>p[i]定义为和*(p+i)相同，代表p指向的内存的第i个对象，当对象大于1字节时，这条规则起作用<br>&amp;p[i]和(p+i)相同，代表p指向的内存的第i个对象的地址<br>在对内存地址进行加法时，要确定他是<strong>integer addition or pointer addition</strong></p>
<p>ref: <a target="_blank" rel="noopener" href="https://blog.csdn.net/han_hhh/article/details/121701438">https://blog.csdn.net/han_hhh/article/details/121701438</a></p>
<h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p>内核的文件头:</p>
<img src="https://s2.loli.net/2022/05/18/FfUZ5AkPBcNlCJV.png" alt="image-20220518152817746" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/18/myS4R9jDwvfcAJp.png" alt="image-20220518152831699" style="zoom:67%;" />

<p>得到了<code>Program Header</code>文件头，上面省略了余下的一些输出内容。每个<code>LOAD</code>都是一个<code>ELF</code>对象，里面包含了相对本文件的索引<code>off</code>、虚拟内址<code>vaddr</code>、物理地址<code>paddr</code>、对齐<code>align</code>、对象在文件和内存中的大小<code>filesz, memsz</code>。</p>
<p>这个<code>header</code>在<code>bootmain</code>函数中通过<code>readseg</code>函数加载到了内存中，位置在<code>0x10000</code>，并通过一个宏<code>ELFHDR</code>索引。<code>header</code>中存放的数据采用的是默认的对齐方式，所以可以直接通过一个<code>struct Elf</code>指针访问各个属性。</p>
<img src="https://s2.loli.net/2022/05/23/UxAbKhYMcvPr9Wl.png" alt="image-20220518153305171" style="zoom: 50%;" />

<p>在文件头<code>struct Elf</code>中，我们拿到了关于结构体<code>struct Proghdr</code>数组的信息<code>e_phoff</code>。从这个数组的成员中，我们拿到了关于每个<code>segment</code>的信息，也就可以把它们正式从硬盘中拷贝到内存中的指定位置。</p>
<img src="https://s2.loli.net/2022/05/23/3eNXsKyhPwFnWx9.png" alt="image-20220518153337802" style="zoom:50%;" />

<p>第一个<code>segment</code>对象的地址存放在<code>ELFHDR-&gt;e_phoff</code>中，是从硬盘中读入的原始数据。转化为指针如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br></pre></td></tr></table></figure>

<p>也就是加上了一个偏置。同样利用<code>elf</code>文件的数据，查出这个“对象数组”的长度，也就可以遍历这个<code>Proghdr</code>数组了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure>

<p><code>ph</code>是个<code>struct Proghdr</code>类型的指针，直接<code>++</code>让地址的值前进相应地址长度，非常方便。</p>
<p>至此，内核完全加载完毕。</p>
<p><img src="https://s2.loli.net/2022/05/18/WKgHeMSYBt3UV8O.png" alt="image-20220518154931248"></p>
<img src="https://s2.loli.net/2022/05/23/bziYmGwcqngRQoB.png" alt="image-20220518170934792" style="zoom: 67%;" />

<img src="https://s2.loli.net/2022/05/18/rNBvldLZ7WUufDe.png" alt="image-20220518170900480" style="zoom: 67%;" />

<p>获取kernel ELF文件的相关信息：</p>
<img src="https://s2.loli.net/2022/05/23/j4RoMerFKCsSQVd.png" alt="image-20220518173511422" style="zoom:67%;" />

<p>可看到程序入口的虚拟地址是0x10000c，程序头表偏移为52B，程序头表条目是2.</p>
<p><strong>如果你得到一个错误的引导加载器链接地址，通过再次跟踪引导加载器的前几个指令，你将会发现第一个指令会 “中断” 或者出错。然后在 <code>boot/Makefrag</code> 修改链接地址来修复错误，运行 <code>make clean</code>，使用 <code>make</code> 重新编译，然后再次跟踪引导加载器去查看会发生什么事情。不要忘了改回正确的链接地址，然后再次 <code>make clean</code>！</strong></p>
<p><img src="https://s2.loli.net/2022/05/18/vPznfE9bwAKSF4N.png" alt="image-20220518181251389"></p>
<p>修改0x7C00为0x7d00，使得bootloader无法正确加载。</p>
<p><img src="https://s2.loli.net/2022/05/18/roiDh2v3TskuRAx.png" alt="image-20220518181451276"></p>
<p><strong>可能</strong>就是GDT表加载错误才导致后面加载失败，因为加载信息都错掉了。</p>
<h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><p>在BIOS进入 the boot loader时检查内存0x00100000处的8个字，然后在 the boot loader进入内核时再检查一次。</p>
<p><img src="https://s2.loli.net/2022/05/18/D2cVRnXdpaiI5eP.png" alt="image-20220518185538199"></p>
<p><img src="https://s2.loli.net/2022/05/18/CXgSuAbDTMUPWNm.png" alt="image-20220518185555496"></p>
<p>0x00100000往后8个字前后不一样应该是由于bootmain将内核的某个section存入了该地址处。由于要在进入内核时再看一次，故第二个断点应该设置在call entry处，<br>即 *<em>b <em>0x7d69</em></em></p>
<p><img src="https://s2.loli.net/2022/05/18/ylz7Vrp5APt4Roh.png" alt="image-20220518185643002"></p>
<p><strong>内核的入口地址是0x0010000c，也在此范围中，可能是.text段的内容，因为内核最先加载的就是.text</strong></p>
<p>➜  lab git:(lab1) objdump -x obj/kern/kernel </p>
<p>obj/kern/kernel:     file format elf32-i386<br>obj/kern/kernel<br>architecture: i386, flags 0x00000112:<br>EXEC_P, HAS_SYMS, D_PAGED<br>start address 0x0010000c</p>
<p>Program Header:<br>    LOAD off    0x00001000 vaddr 0xf0100000 paddr 0x00100000 align 212<br>         filesz 0x0000ee68 memsz 0x0000ee68 flags r-x<br>    LOAD off    0x00010000 vaddr 0xf010f000 paddr 0x0010f000 align 212<br>         filesz 0x0000a948 memsz 0x0000a948 flags rw-</p>
<p>Sections:<br>Idx Name          Size      VMA       LMA       File off  Algn<br>  0 .text         0000178e  f0100000  00100000  00001000  22<br>                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br>  1 .rodata       00000704  f01017a0  001017a0  000027a0  25<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  2 .stab         000044d1  f0101ea4  00101ea4  00002ea4  22<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  3 .stabstr      00008af3  f0106375  00106375  00007375  20<br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  4 .data         0000a300  f010f000  0010f000  00010000  212<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  5 .bss          00000648  f0119300  00119300  0001a300  25<br>                  CONTENTS, ALLOC, LOAD, DATA<br>  6 .comment      00000011  00000000  00000000  0001a948  20<br>                  CONTENTS, READONLY</p>
<h1 id="The-kernel"><a href="#The-kernel" class="headerlink" title="The kernel"></a>The kernel</h1><h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><p>在0x0010000c处打上断点，si单步执行，直到 movl %eax, %cr0 前一步</p>
<img src="https://s2.loli.net/2022/05/22/JjV2Gl3Uy1RQ8Np.png" alt="image-20220522172810387" style="zoom:67%;" />

<p>查看0x00100000 和 0xf0100000 的内容</p>
<img src="https://s2.loli.net/2022/05/23/PBqscTj9QwiO4ed.png" alt="image-20220522172955485" style="zoom:67%;" />

<p>执行movl %eax, %cr0 ， 再次查看内容</p>
<p><img src="https://s2.loli.net/2022/05/22/B3xzQXu8ldivrNK.png" alt="image-20220522173104250"></p>
<p>发现VMA和LMA有相同的内容，这是因为分页后，0x00100000 被映射到了 0xf0100000 处，完成了分页操作。</p>
<p>make clean 后，注释掉movl %eax, %cr0  （kern/entry.S）</p>
<p>重新运行</p>
<img src="https://s2.loli.net/2022/05/22/46IQNuzcP17HJ8C.png" alt="image-20220522194929977" style="zoom:67%;" />

<p>qemu-system-i386 -nographic -drive file=obj/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::26000 -D qemu.log  -S<br><strong>qemu: fatal: Trying to execute code outside RAM or ROM at 0xf010002c</strong></p>
<p>EAX=f010002c EBX=00010074 ECX=00000000 EDX=000000d5<br>ESI=00010074 EDI=00000000 EBP=00007bf8 ESP=00007bec<br>EIP=f010002c EFL=00000086 [–S–P-] CPL=0 II=0 A20=1 SMM=0 HLT=0<br>ES =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>CS =0008 00000000 ffffffff 00cf9a00 DPL=0 CS32 [-R-]<br>SS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>DS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>FS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>GS =0010 00000000 ffffffff 00cf9300 DPL=0 DS   [-WA]<br>LDT=0000 00000000 0000ffff 00008200 DPL=0 LDT<br>TR =0000 00000000 0000ffff 00008b00 DPL=0 TSS32-busy<br>GDT=     00007c4c 00000017<br>IDT=     00000000 000003ff<br>CR0=00000011 CR2=00000000 CR3=00117000 CR4=00000000<br>DR0=00000000 DR1=00000000 DR2=00000000 DR3=00000000<br>DR6=ffff0ff0 DR7=00000400<br>CCS=00000084 CCD=80010011 CCO=EFLAGS<br>EFER=0000000000000000<br>FCW=037f FSW=0000 [ST=0] FTW=00 MXCSR=00001f80<br>FPR0=0000000000000000 0000 FPR1=0000000000000000 0000<br>FPR2=0000000000000000 0000 FPR3=0000000000000000 0000<br>FPR4=0000000000000000 0000 FPR5=0000000000000000 0000<br>FPR6=0000000000000000 0000 FPR7=0000000000000000 0000<br>XMM00=00000000000000000000000000000000 XMM01=00000000000000000000000000000000<br>XMM02=00000000000000000000000000000000 XMM03=00000000000000000000000000000000<br>XMM04=00000000000000000000000000000000 XMM05=00000000000000000000000000000000<br>XMM06=00000000000000000000000000000000 XMM07=00000000000000000000000000000000<br>make: *** [qemu-nox-gdb] Aborted (core dumped)</p>
<p><strong>由于未开启分页机制，虚拟地址还未映射到物理地址。</strong></p>
<h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><p>补全”%o”</p>
<img src="https://s2.loli.net/2022/05/23/bMnKRuqGXZOvY2l.png" alt="image-20220522213815891" style="zoom:67%;" />

<h4 id="problem-1"><a href="#problem-1" class="headerlink" title="problem 1"></a>problem 1</h4><p>解释<code>printf.c</code>和 <code>console.c</code>之间的接口。<code>具体来说， console.c</code>导出什么函数 ？<code>printf.c</code>如何使用这个函数 ？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// printf.c</span></span><br><span class="line"><span class="comment">// Simple implementation of cprintf console output for the kernel,</span></span><br><span class="line"><span class="comment">// based on printfmt() and the kernel console&#x27;s cputchar().</span></span><br><span class="line"><span class="comment">//为内核简单实现cprintf控制台输出，</span></span><br><span class="line"><span class="comment">//基于printfmt（）和内核控制台的cputchar（）。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">putch</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> *cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cputchar(ch);</span><br><span class="line">   *cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">vcprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, va_list ap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   vprintfmt((<span class="keyword">void</span>*)putch, &amp;cnt, fmt, ap);</span><br><span class="line">   <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">cprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   va_list ap;</span><br><span class="line">   <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">   va_start(ap, fmt);</span><br><span class="line">   cnt = vcprintf(fmt, ap);</span><br><span class="line">   va_end(ap);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/05/23/sLTgyRwqYd8EJcI.png" alt="image-20220522214112303" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/dJMHKFrN9vZ5t4a.png" alt="image-20220522214134785" style="zoom:67%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 03FD    r  line status register</span></span><br><span class="line"><span class="comment">       bit 7 = 0  reserved</span></span><br><span class="line"><span class="comment">       bit 6 = 1  transmitter shift and holding registers empty</span></span><br><span class="line"><span class="comment">       bit 5 = 1  transmitter holding register empty. Controller is</span></span><br><span class="line"><span class="comment">             ready to accept a new character to send.</span></span><br><span class="line"><span class="comment">       bit 4 = 1  break interrupt. the received data input is held in</span></span><br><span class="line"><span class="comment">             in the zero bit state longer than the time of start</span></span><br><span class="line"><span class="comment">             bit + data bits + parity bit + stop bits.</span></span><br><span class="line"><span class="comment">       bit 3 = 1  framing error. the stop bit that follows the last</span></span><br><span class="line"><span class="comment">             parity or data bit is a zero bit.</span></span><br><span class="line"><span class="comment">       bit 2 = 1  parity error. Character has wrong parity</span></span><br><span class="line"><span class="comment">       bit 1 = 1  overrun error. a character was sent to the receiver</span></span><br><span class="line"><span class="comment">             buffer before the previous character in the buffer</span></span><br><span class="line"><span class="comment">             could be read. This destroys the previous</span></span><br><span class="line"><span class="comment">             character.</span></span><br><span class="line"><span class="comment">       bit 0 = 1  data ready. a complete incoming character has been</span></span><br><span class="line"><span class="comment">             received and sent to the receiver buffer register.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">serial_putc</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// COM1 = 0x3F8, COM_LSR(Line Status Register) = 5, COM_LSR_TXRDY(传输缓冲区) = 0x20,</span></span><br><span class="line">    <span class="comment">// 0x03F8 + 5  =&gt; 0x03FD   0x03FD &amp; 0x20(0010 0000) =&gt; 取 bit 5</span></span><br><span class="line">    <span class="comment">// bti 5 = 1 :</span></span><br><span class="line">    <span class="comment">// transmitter holding register empty. Controller is ready to accept a new character to send.</span></span><br><span class="line">    <span class="comment">// 如果bit 5 = 1，那么传输方寄存器已空，controller可以接受一个新的字符了</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>;</span><br><span class="line">        !(inb(COM1 + COM_LSR) &amp; COM_LSR_TXRDY) &amp;&amp; i &lt; <span class="number">12800</span>;  <span class="comment">// bit 5 != 1  &amp;&amp; 没超时</span></span><br><span class="line">        i++)</span><br><span class="line">      delay();</span><br><span class="line">    <span class="comment">//COM_TX = 0    Out: Transmit buffer</span></span><br><span class="line">    <span class="comment">//serial_putc()函数的功能首先就是在bit 5 =1 的时候，跳出循环，否则只要 i &lt;12800就会一直循环等待。</span></span><br><span class="line">   outb(COM1 + COM_TX, c);   <span class="comment">// 将c写入I/O端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***** Parallel port output code *****/</span></span><br><span class="line"><span class="comment">// For information on PC parallel port programming, see the class References</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">// 并行端口输入</span></span><br><span class="line"><span class="comment">/* 0x378~0x37A parallel printer port</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0378    w    data port</span></span><br><span class="line"><span class="comment">0379    r/w    status port</span></span><br><span class="line"><span class="comment">         bit 7 = 0 busy * 0x80</span></span><br><span class="line"><span class="comment">         bit 6 = 0 acknowledge</span></span><br><span class="line"><span class="comment">         bit 5 = 1 out of paper</span></span><br><span class="line"><span class="comment">         bit 4 = 1 printer is selected</span></span><br><span class="line"><span class="comment">         bit 3 = 0 error</span></span><br><span class="line"><span class="comment">         bit 2 = 0 IRQ has occurred</span></span><br><span class="line"><span class="comment">         bit 1-0 reserved</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">037A    r/w    control port</span></span><br><span class="line"><span class="comment">         bit 7-5 reserved</span></span><br><span class="line"><span class="comment">         bit 4 = 1 enable IRQ</span></span><br><span class="line"><span class="comment">         bit 3 = 1 select printer    * 0x08</span></span><br><span class="line"><span class="comment">         bit 2 = 0 initialize printer *0x04</span></span><br><span class="line"><span class="comment">         bit 1 = 1 automatic line feed</span></span><br><span class="line"><span class="comment">         bit 0 = 1 strobe        * 0x01</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">lpt_putc</span><span class="params">(<span class="keyword">int</span> c)</span>   <span class="comment">// 并行端口输入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 0x379 &amp; 0x80   读取0x379的内容，和0x80相与，取bits 7，判断是否繁忙</span></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; !(inb(<span class="number">0x378</span>+<span class="number">1</span>) &amp; <span class="number">0x80</span>) &amp;&amp; i &lt; <span class="number">12800</span>; i++)   <span class="comment">// io端口不繁忙且未超时，一直等待，直到使用了端口或等待时间到</span></span><br><span class="line">      delay();</span><br><span class="line">   outb(<span class="number">0x378</span>+<span class="number">0</span>, c);  <span class="comment">// write char c</span></span><br><span class="line">   outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>|<span class="number">0x04</span>|<span class="number">0x01</span>);   <span class="comment">//初始化 printer</span></span><br><span class="line">   outb(<span class="number">0x378</span>+<span class="number">2</span>, <span class="number">0x08</span>);  <span class="comment">// 选择 printer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">cga_putc</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// if no attribute given, then use black on white</span></span><br><span class="line">    <span class="comment">// 如果没有给定属性，则使用黑白相间的颜色</span></span><br><span class="line">   <span class="keyword">if</span> (!(c &amp; ~<span class="number">0xFF</span>))    <span class="comment">// c 低16位为字符值，高16位为显示属性</span></span><br><span class="line">      c |= <span class="number">0x0700</span>;</span><br><span class="line">    <span class="comment">// crt_pos:当前输出位置指针，指向内存区中对应输出映射地址。</span></span><br><span class="line">   <span class="keyword">switch</span> (c &amp; <span class="number">0xff</span>) &#123;    <span class="comment">// 取低16位</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>:   <span class="comment">// backspace</span></span><br><span class="line">      <span class="keyword">if</span> (crt_pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         crt_pos--;</span><br><span class="line">         crt_buf[crt_pos] = (c &amp; ~<span class="number">0xff</span>) | <span class="string">&#x27; &#x27;</span>;  <span class="comment">// 删除处使用&#x27; &#x27;填充</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:    <span class="comment">// //new line：换行, 自动添加回车</span></span><br><span class="line">      crt_pos += CRT_COLS;   <span class="comment">// CRT_COLS默认输出格式下整个屏幕的列数，为80。</span></span><br><span class="line">        <span class="comment">// CRT_ROWS:默认输出格式下整个屏幕的行数，为25。</span></span><br><span class="line">      <span class="comment">/* fallthru */</span></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">      crt_pos -= (crt_pos % CRT_COLS);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:  <span class="comment">// tab  转换为五个 &#x27; &#x27;</span></span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      cons_putc(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      crt_buf[crt_pos++] = c;       <span class="comment">/* write the character */</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// What is the purpose of this?</span></span><br><span class="line">    <span class="comment">// CRT_SIZE:是CRT_COLS和CRT_ROWS的乘积，即2000=80*25，是不翻页时一页屏幕最大能容纳的字数。</span></span><br><span class="line">    <span class="comment">// 当前屏幕写满了，</span></span><br><span class="line">   <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">      <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 函数：memmove(): memmove(void *dst, const void *src, size_t n).</span></span><br><span class="line"><span class="comment">         * 意为将从src指向位置起的n字节数据送到dst指向位置，可以在两个区域重叠时复制。</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">// 所有数据向前挪动一行，最上面一行数据丢失</span></span><br><span class="line">      memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">      <span class="comment">// 清空最后一行，用空格填充</span></span><br><span class="line">        <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">         crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      crt_pos -= CRT_COLS;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 写光标位置</span></span><br><span class="line">   <span class="comment">/* move that little blinky thing */</span></span><br><span class="line">   outb(addr_6845, <span class="number">14</span>);</span><br><span class="line">   outb(addr_6845 + <span class="number">1</span>, crt_pos &gt;&gt; <span class="number">8</span>);</span><br><span class="line">   outb(addr_6845, <span class="number">15</span>);</span><br><span class="line">   outb(addr_6845 + <span class="number">1</span>, crt_pos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="problem-2"><a href="#problem-2" class="headerlink" title="problem 2"></a>problem 2</h4><ol>
<li><p>从console.c</p>
<p>解释以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1      if (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line">2              int i;</span><br><span class="line">3              memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));</span><br><span class="line">4              for (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line">5                      crt_buf[i] = 0x0700 | &#x27; &#x27;;</span><br><span class="line">6              crt_pos -= CRT_COLS;</span><br><span class="line">7      &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>见上</p>
<h4 id="problem-3"><a href="#problem-3" class="headerlink" title="problem 3"></a>problem 3</h4><ol>
<li><p>For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC’s calling convention on the x86.</p>
<p>Trace the execution of the following code step-by-step:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = 1, y = 3, z = 4;</span><br><span class="line">cprintf(&quot;x %d, y %x, z %d\n&quot;, x, y, z);</span><br></pre></td></tr></table></figure>

<ul>
<li>In the call to <code>cprintf()</code>, to what does <code>fmt</code> point? To what does <code>ap</code> point?</li>
<li>List (in order of execution) each call to <code>cons_putc</code>, <code>va_arg</code>, and <code>vcprintf</code>. For <code>cons_putc</code>, list its argument as well. For <code>va_arg</code>, list what <code>ap</code> points to before and after the call. For <code>vcprintf</code> list the values of its two arguments.</li>
</ul>
</li>
</ol>
<p>对于以下问题，您可能希望查阅第 2 讲的注释。这些注释涵盖了 GCC 在 x86 上的调用约定。</p>
<p>逐步跟踪以下代码的执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = 1, y = 3, z = 4;</span><br><span class="line">cprintf(&quot;x %d, y %x, z %d\n&quot;, x, y, z);</span><br></pre></td></tr></table></figure>

<h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><ul>
<li>在调用 to<code>cprintf()</code>时，<code>fmt</code>指向什么？<code>ap</code>指向什么？</li>
<li>列出（按执行顺序）对<code>cons_putc</code>、<code>va_arg</code>和 <code>vcprintf</code>的每个调用。对于<code>cons_putc</code>，也列出它的argument。对于 <code>va_arg</code>，列出<code>ap</code>调用前后所指向的内容。列出它的两个参数的<code>vcprintf</code>值。</li>
</ul>
<p>将代码复制到该位置</p>
<img src="https://s2.loli.net/2022/05/23/gJmLk95Ce7Z2jb8.png" alt="image-20220522214913927" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/M9Fv2azChmu6XpU.png" alt="image-20220522215011773" style="zoom:67%;" />

<p>在gdb给该行打断点</p>
<p><img src="https://s2.loli.net/2022/05/22/CJT36u1powsZPjS.png" alt="image-20220522215850429"></p>
<p>disassemble 反汇编当前代码段的部分指令</p>
<p><img src="https://s2.loli.net/2022/05/22/Z6QbjgWxeX21oCU.png" alt="image-20220522215943610"></p>
<p>在kernel.asm中查找该地址</p>
<p>（vim命令模式下，/+查找字符是向下查找，?是向上查找。 如果你要继续查找此关键字，敲字符n就可以继续查找了）</p>
<img src="https://s2.loli.net/2022/05/22/T4gfBOJXFW8Rjid.png" alt="image-20220522220412446" style="zoom: 67%;" />

<p>call 0xf0100906 &lt;cprintf&gt;</p>
<img src="https://s2.loli.net/2022/05/23/jCSTbcLE8UJzdRV.png" alt="image-20220522221005338" style="zoom:67%;" />

<p>va_start，函数名称，读取可变参数的过程其实就是在栈区中，使用指针,遍历栈区中的参数列表,从低地址到高地址一个一个地把参数内容读出来的过程·</p>
<p>可以看到 fmt 是 cprintf 函数的第一个参数，即指向字符串<code>&quot;x %d, y %x, z %d\n&quot;</code>的指针。</p>
<p>ap 指向第二个参数的地址。<strong>注意 ap 中存放的是第二个参数的地址，而非第二个参数。</strong></p>
<img src="https://s2.loli.net/2022/05/22/HJTjCcetVzk7buf.png" alt="image-20220522221407297" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/22/MQk6y5TJuNXf3Yz.png" alt="image-20220522221535010" style="zoom:67%;" />

<h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><p>调用关系为 cprintf -&gt; vcprintf -&gt; vprintfmt -&gt; putch -&gt; cputchar -&gt; cons_putc</p>
<p>接上图，可以看到vpprintf后是vprintfmt</p>
<p><img src="https://s2.loli.net/2022/05/22/RsxIbcmhAouZWJ1.png" alt="image-20220522222019680"></p>
<p><img src="https://s2.loli.net/2022/05/22/BlO5HewtJvWUdRG.png" alt="image-20220522222138140"></p>
<p>之后，vprintfmt依次调用putch和cputchar</p>
<p><img src="https://s2.loli.net/2022/05/22/84lAVsnb9TUjMvf.png" alt="image-20220522222344930"></p>
<p>cputchar调用 cons_putc</p>
<p><img src="https://s2.loli.net/2022/05/22/gNm5rjRT9S6iIWl.png" alt="image-20220522222504049"></p>
<img src="https://s2.loli.net/2022/05/22/IoJriQZ5zH7v9k4.png" alt="image-20220522222602885" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/NVXpFGzkdOghPEJ.png" alt="image-20220522222620191" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/6yoTIQYmvVL3USq.png" alt="image-20220522222706554" style="zoom:67%;" />

<p>0xf010022b之后，    准备输出</p>
<img src="https://s2.loli.net/2022/05/22/CREO15lqh9NfXDg.png" alt="image-20220522223041430" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/05/23/sNVe8uUR5aiJzMx.png" alt="image-20220522223632755" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/05/22/TSWJcyAMg6GzNZ1.png" alt="image-20220522223329251" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/8BRwLbQqtJD2O93.png" alt="image-20220522223357850" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/Sy7DiNdcsqnoR9Q.png" alt="image-20220522223512459" style="zoom:67%;" />

<p>120，32,  49， 44， 32， 121， 32， 51， 44， 32， 122， 32， 52， 10</p>
<p>ascii 码转换为char</p>
<img src="https://s2.loli.net/2022/05/22/m1pUGnx78lB5VjP.png" alt="image-20220522223726095" style="zoom: 67%;" />

<p><img src="https://s2.loli.net/2022/05/22/BUn6TOxev9pg3ul.png" alt="image-20220522223755233"></p>
<h4 id="problem-4"><a href="#problem-4" class="headerlink" title="problem 4"></a>problem 4</h4><p>Run the following code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise.</p>
<p>The output depends on that fact that the x86 is little-endian. If the x86 were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<p><img src="https://s2.loli.net/2022/05/23/3SezlGXtE7gMcTD.png" alt="image-20220523130430575"></p>
<img src="https://s2.loli.net/2022/05/23/8fuNUjOd9vnQEkH.png" alt="image-20220523131152245" style="zoom:80%;" />

<img src="https://s2.loli.net/2022/05/23/LZHfOB14oKDQedl.png" alt="image-20220523131208149" style="zoom:80%;" />

<img src="https://s2.loli.net/2022/06/03/Az8IQt2FhgD73d1.png" alt="image-20220523131709311" style="zoom:67%;" />

<p>71, 101, 49, 49, 48, 32, 87, 111, 114, 108, 100</p>
<p>He110 World</p>
<img src="https://s2.loli.net/2022/05/23/nrQyBk9HSv85XWC.png" alt="image-20220523131908104" style="zoom:67%;" />

<p>%x 指无符号十六进制数</p>
<img src="https://s2.loli.net/2022/06/03/EPGICj2LrVmTzqt.png" alt="image-20220523133643397" style="zoom:67%;" />

<p>57616转换为16进制，正好是e110</p>
<p>%s指字符串，0x00646c72在小端模式下对应的ASCII码为 0x72, 0x6c, 0x64, 0x00, 可得’rld’</p>
<p>如果是在大端 (big endian) 模式下要得到同样的输出，应该改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x726c6400</span>;</span><br><span class="line"><span class="built_in">cprintf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<h4 id="problem-5"><a href="#problem-5" class="headerlink" title="problem 5"></a>problem 5</h4><p>In the following code, what is going to be printed after ‘ y= ‘ ? (note: the answer is not a specific value.) Why does this happen?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(&quot;x=%d y=%d&quot;, 3);</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/05/23/ioOsFIc4qzEX5gC.png" alt="image-20220523141401716" style="zoom:67%;" />

<p><img src="https://s2.loli.net/2022/05/23/2GnipTQcFz5Rul4.png" alt="image-20220523144320399"></p>
<p>y的值没有给定，所以输出一个不确定的值</p>
<h4 id="problem-6"><a href="#problem-6" class="headerlink" title="problem 6"></a>problem 6</h4><p>Let’s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change <code>cprintf</code> or its interface so that it would still be possible to pass it a variable number of arguments?</p>
<h1 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h1><h3 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h3><p>确定内核初始化堆栈的位置，以及堆栈在内存中的确切位置。内核如何为其堆栈保留空间？堆栈指针初始化为指向该保留区域的哪一端？</p>
<img src="https://s2.loli.net/2022/05/23/2WT6iQGvJsgpR3a.png" alt="image-20220523172823907" style="zoom: 50%;" />

<p>bootstacktop是栈顶，地址为0xf0117000</p>
<p>mmu.h中</p>
<img src="https://s2.loli.net/2022/05/23/ZEQK9WBALjIfe3k.png" alt="image-20220523174049954" style="zoom:80%;" />

<p>memlayout.h</p>
<img src="https://s2.loli.net/2022/05/23/XgPc52kHWMnfwiD.png" alt="image-20220523174104956" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/05/23/zl42JmAv5B7cjV1.png" alt="image-20220523174140644" style="zoom:67%;" />

<p>栈大小是32KB，栈顶指针存在esp，为 0xf0117000</p>
<img src="https://s2.loli.net/2022/05/23/zahDgVRnyj6U9Od.png" alt="image-20220523174417402" style="zoom:67%;" />

<h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><p>要熟悉x86上的C调用约定，请在<strong>obj/kern/kernel.asm</strong>中找到<strong>test_backtrace</strong>函数的地址，在那里设置一个断点，并检查内核启动后每次调用它时会发生什么。test_backtrace的每个递归嵌套级别在堆栈上推送多少32位字，这些字是什么？</p>
<p><img src="https://s2.loli.net/2022/05/28/nZ2YagVsuP9FXSW.png" alt="image-20220528164332775"></p>
<p>给back_trace的test_backtrace(x-1); mon_backtrace(0, 0, 0);和 打上断点，    查看<code>esp</code>的初始值。</p>
<p><img src="https://s2.loli.net/2022/05/28/MjnGhxmEktR2NWP.png" alt="image-20220528165206593"></p>
<p>初始x传入值为5，向后执行直至x=0</p>
<p><img src="https://s2.loli.net/2022/05/28/Dsg8NQlOAvY2otG.png" alt="image-20220528171319674"></p>
<p>中途查看esp内容，发现第二列保存的是x的值。每次递归会保存两行。每一列的意思是</p>
<p><img src="https://s2.loli.net/2022/05/28/WKwp2NxBIPHaAX8.png" alt="image-20220528210745786"></p>
<p><img src="https://s2.loli.net/2022/05/28/hxk1DYoTrZwpB2P.png" alt="image-20220528211308210"></p>
<p><strong>x86堆栈要倒着长，如果以为push以后esp会增加可就大错特错了。。ebp虽然叫栈底，但是永远大于等于栈顶</strong></p>
<p>0xf0100069应该是test_backtrace的下一条的返回地址。</p>
<p><img src="https://s2.loli.net/2022/06/03/e9OsqWFKYv81B76.png" alt="image-20220528180523233"></p>
<p>test_backtrace(5)的栈帧范围是：esp: 0xf0116fc0      ebp: 0xf0116fc8</p>
<p>test_backtrace(4):   esp: 0xf0116fa0      ebp: 0xf0116fa8</p>
<p>test_backtrace(3):   esp: 0xf0116f80      ebp: 0xf0116f88</p>
<p>test_backtrace(2):   esp: 0xf0116f60      ebp: 0xf0116f68</p>
<p>test_backtrace(1):   esp: 0xf0116f40      ebp: 0xf0116f48</p>
<p>next x           |       this x     |    don’t know  | don’t know  | </p>
<p>don’t know  |        last  x   |     last ebp       |  return addr|</p>
<h3 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h3><p>implement a stack backtrace function</p>
<p>The backtrace function should display a listing of function call frames in the following format:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack backtrace:</span><br><span class="line">  ebp f0109e58  eip f0100a62  args 00000001 f0109e80 f0109e98 f0100ed2 00000031</span><br><span class="line">  ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>Each line contains an <code>ebp</code>, <code>eip</code>, and <code>args</code>.</p>
<p>运行 <code>make grade</code> 这个评级脚本去查看它的输出是否是我们的脚本所期望的结果/。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C函数调用时，首先将参数push入栈，然后push返回地址，接着将原来的EBP push入栈，然后将ESP的值赋给EBP，令ESP指向新的栈顶。而函数返回时，会将EBP的值赋予ESP，然后pop出原来的EBP的值赋予EBP指针。</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/05/28/SIWUp2ahfZOP4t8.png" alt="image-20220528223530430"></p>
<img src="https://s2.loli.net/2022/05/28/bVInmrfcN6YsqjB.png" alt="image-20220528223513219" style="zoom:67%;" />

<h3 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h3><p>修改堆栈回溯函数以显示每个<code>eip</code>对应的函数名、源文件名和行<code>号</code>。</p>
<p>在<code>debuginfo_eip</code>中，<code>__STAB_*</code>来自哪里？这个问题有一个很长的答案；为了帮助您找到答案，以下是您可能想做的一些事情：</p>
<ul>
<li>look in the file <code>kern/kernel.ld</code> for <code>__STAB_*</code></li>
<li>run objdump -h obj/kern/kernel</li>
<li>run objdump -G obj/kern/kernel</li>
<li>run gcc -pipe -nostdinc -O2 -fno-builtin -I. -MD -Wall -Wno-format -DJOS_KERNEL -gstabs -c -S kern/init.c, and look at init.s.</li>
<li>see if the bootloader loads the symbol table in memory as part of loading the kernel binary</li>
</ul>
<p>向内核监视器添加一个<code>backtrace </code>命令，并扩展您的实现<code>mon_backtrace</code>以调用<code>debuginfo_eip</code>并打印表单的每个堆栈帧的一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">K&gt; backtrace</span><br><span class="line">Stack backtrace:</span><br><span class="line">  ebp f010ff78  eip f01008ae  args 00000001 f010ff8c 00000000 f0110580 00000000</span><br><span class="line">         kern/monitor.c:143: monitor+106</span><br><span class="line">  ebp f010ffd8  eip f0100193  args 00000000 00001aac 00000660 00000000 00000000</span><br><span class="line">         kern/init.c:49: i386_init+59</span><br><span class="line">  ebp f010fff8  eip f010003d  args 00000000 00000000 0000ffff 10cf9a00 0000ffff</span><br><span class="line">         kern/entry.S:70: &lt;unknown&gt;+0</span><br><span class="line">K&gt; </span><br></pre></td></tr></table></figure>

<p>Each line gives the file name and line within that file of the stack frame’s <code>eip</code>, followed by the name of the function and the offset of the <code>eip</code> from the first instruction of the function (e.g., <code>monitor+106</code> means the return <code>eip</code> is 106 bytes past the beginning of <code>monitor</code>).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Include debugging information in kernel memory */</span></span><br><span class="line">.stab : &#123;</span><br><span class="line">	PROVIDE(__STAB_BEGIN__ = .);</span><br><span class="line">	*(.stab);</span><br><span class="line">	PROVIDE(__STAB_END__ = .);</span><br><span class="line">	BYTE(<span class="number">0</span>)		<span class="comment">/* Force the linker to allocate space</span></span><br><span class="line"><span class="comment">			   for this section */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.stabstr : &#123;</span><br><span class="line">	PROVIDE(__STABSTR_BEGIN__ = .);</span><br><span class="line">	*(.stabstr);</span><br><span class="line">	PROVIDE(__STABSTR_END__ = .);</span><br><span class="line">	BYTE(<span class="number">0</span>)		<span class="comment">/* Force the linker to allocate space</span></span><br><span class="line"><span class="comment">			   for this section */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/05/28/WMQfEjbsJgDlU4S.png" alt="image-20220528230025894"></p>
<p>可以得到stab和 stabstr的起始地址和结束地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__STAB_BEGIN__ = 0xf0101f2c</span><br><span class="line">__STAB_END__ = 0xf0101f2c + 00004549 - 1</span><br><span class="line">__STABSTR_BEGIN__ = 0xf0106475</span><br><span class="line">__STABSTR_END__ = 0xf0106475 + 00008b11 - 1</span><br></pre></td></tr></table></figure>

<p>objdump -G obj/kern/kernel 列出所有stab的信息</p>
<p><img src="https://s2.loli.net/2022/06/03/wJ6T2spyFvP7DxI.png" alt="image-20220528230955470"></p>
<p>进入内核后打个断点，查看stabstr内的内容</p>
<p><img src="https://s2.loli.net/2022/05/28/FszN2t4h6bVH3nG.png" alt="image-20220528232511341"></p>
<p>使用<code>objdump -G obj/kern/kernel &gt; output.md</code>将内核的符号表信息输出到output.md文件</p>
<p><img src="https://s2.loli.net/2022/06/03/oLO9PpUryhDSVeE.png" alt="image-20220603142339089"></p>
<p>观察kernel.asm</p>
<p><img src="https://s2.loli.net/2022/06/03/9I7hWzcHuRLlPUs.png" alt="image-20220603142401904"></p>
<p>观察entry.S</p>
<p><img src="https://s2.loli.net/2022/06/03/Cv6OTo4a31SArkx.png" alt="image-20220603142437259"></p>
<p>可以看到，output.md 中的各个字段，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symnum   下标，整个符号表看作一个数组，Symnum是当前符号在数组中的下标</span><br><span class="line">n_type   符号类型，FUN指函数名，SLINE指在text段中的行号</span><br><span class="line">n_othr   不清楚</span><br><span class="line">n_desc   在文件中的行号</span><br><span class="line">n_value  表示地址</span><br><span class="line">n_strx   </span><br><span class="line">String   保存信息（函数、语句啥的）</span><br></pre></td></tr></table></figure>

<p>在查看<code>kdebug.c</code>时候发现函数的参数为<code>int</code>类型，但是传入是<code>N_FUN</code>，于是翻了一下<code>stab.h</code></p>
<p><img src="https://s2.loli.net/2022/06/03/U61vX4bqchRWj37.png" alt="image-20220603145602882"></p>
<p>修改monitor.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> ebp;</span><br><span class="line">    <span class="keyword">uint32_t</span>* eip;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">    ebp = read_ebp();</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="comment">// ebp f0109ed8  eip f01000d6  args 00000000 00000000 f0100058 f0109f28 00000061</span></span><br><span class="line">    <span class="comment">// eip = *(uint32_t *(ebp + 4))</span></span><br><span class="line">    <span class="keyword">while</span>(ebp != <span class="number">0</span>)&#123;</span><br><span class="line">        eip = (<span class="keyword">uint32_t</span> *)(ebp+<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 08x   八位宽无符号16进制</span></span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>,</span><br><span class="line">                ebp, eip[<span class="number">0</span>], eip[<span class="number">1</span>], eip[<span class="number">2</span>], eip[<span class="number">3</span>], eip[<span class="number">4</span>], eip[<span class="number">5</span>]);</span><br><span class="line">        <span class="comment">// 打印行号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(debuginfo_eip(eip[<span class="number">0</span>], &amp;info)==<span class="number">0</span>)&#123;</span><br><span class="line">            cprintf(<span class="string">&quot;    %s:%d: %s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_name, eip[<span class="number">0</span>] - info.eip_fn_addr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取 ebp的 内容  返回</span></span><br><span class="line">        ebp = *((<span class="keyword">uint32_t</span> *) ebp);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/06/03/Ol4sxCRFyk765Z3.png" alt="image-20220603161956295"></p>
<p>可以看到后续多了<code>:F(0,15)</code></p>
<p>那么需要输出指定长度，以便把后面多余的字符删除。test_backtrace 和 i386_init 为函数名</p>
<p><img src="https://s2.loli.net/2022/06/03/ZtsXhU9qlTwdf5D.png" alt="image-20220603162303721"></p>
<p>使用<code>eip_fn_namelen</code>进行指定长度的输出</p>
<p>修改为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;    %s:%d: %.*s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, eip[<span class="number">0</span>] - info.eip_fn_addr);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/06/03/b5VjniJfOaTDpmW.png" alt="image-20220603162648588"></p>
<p>正常输出</p>
<p><code>make grade</code></p>
<p><img src="https://s2.loli.net/2022/06/03/YsG4kSha2vADzR7.png" alt="image-20220603162723295"></p>
<h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><ol>
<li>启动顺序   bios-&gt;bootloader-&gt;kernel</li>
</ol>
<p>bios: </p>
<p>0x000FFFFF~0x0010 0000</p>
<p>bootloader:</p>
<p>sectorsize(扇区大小)是512</p>
<p><img src="https://s2.loli.net/2022/06/03/SQLMoxtWkUBPyHg.png" alt="image-20220603165727917"></p>
<p>0x7c00~0x7dff</p>
<p>BIOS找到一个可引导的软盘或硬盘，它将512字节的引导扇区加载到物理地址0x7c00到0x7dff的内存中，然后使用jmp指令将CS:IP设置为0000:7c00，将控制权传递给<strong>the boot loader</strong>。</p>
<p>kern  入口LMA为 00100000 被映射到虚拟地址（LMA）0xf0100000<br>kernel最先加载的就是 .text<br>所作操作：开启内存分页机制，启用虚拟内存，I/O的实现，栈的初始化。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/16/centos%E6%98%BE%E7%A4%BA%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/16/centos%E6%98%BE%E7%A4%BA%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/" class="post-title-link" itemprop="url">centos扩展root</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-16 10:37:17 / 修改时间：10:40:28" itemprop="dateCreated datePublished" datetime="2022-05-16T10:37:17+08:00">2022-05-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p><strong>仅作记录</strong></p>
<p>ref: <a target="_blank" rel="noopener" href="https://blog.csdn.net/twilight1999/article/details/123840372">https://blog.csdn.net/twilight1999/article/details/123840372</a></p>
<p><img src="https://s2.loli.net/2022/05/16/WQNqYGo94wDTb6u.png" alt="image-20220516103804877"></p>
<p><img src="https://s2.loli.net/2022/05/16/3YptBci6qogIjkK.png" alt="image-20220516103901544"></p>
<p><img src="https://s2.loli.net/2022/05/16/ZiD4djJs3ExIqQc.png" alt="image-20220516103912000"></p>
<p><img src="https://s2.loli.net/2022/05/16/D1CGQ3R4rNHlqEv.png" alt="image-20220516103928952"></p>
<p><img src="https://s2.loli.net/2022/05/16/OTRvL1cHmiQbU6C.png" alt="image-20220516103939013"></p>
<p><img src="https://s2.loli.net/2022/05/16/GjIwrRZcJvd79ha.png" alt="image-20220516103947750"></p>
<p><img src="https://s2.loli.net/2022/05/16/gkFC9wuDfep8rP5.png" alt="image-20220516104001619"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/14/MIT6.828%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/14/MIT6.828%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">MIT6.828</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-14 15:55:56" itemprop="dateCreated datePublished" datetime="2022-05-14T15:55:56+08:00">2022-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-17 11:59:55" itemprop="dateModified" datetime="2022-05-17T11:59:55+08:00">2022-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>环境配置是个大坑</p>
<p>直接按照课程教程</p>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2017/tools.html">https://pdos.csail.mit.edu/6.828/2017/tools.html</a></p>
<p>安装ubuntu（32位），我之前安装64，后来各种报错。<strong>ubuntu安装时，插上蓝牙键盘或鼠标设备有时也报错，显示cpu不兼容。</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kinvy/p/15074844.html">https://www.cnblogs.com/kinvy/p/15074844.html</a>     &lt;———-亲测有效</p>
<p><strong>复制过来仅作记录</strong></p>
<h3 id="1-测试编译工具"><a href="#1-测试编译工具" class="headerlink" title="1.测试编译工具"></a>1.测试编译工具</h3><p>shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -i</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727123132004.png"><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727123132004.png" alt="image-20210727123132004"></a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -m32 -print-libgcc-file-name 		<span class="comment">#测试gcc</span></span></span><br></pre></td></tr></table></figure>

<p>上面这条命令是测试gcc的，一般系统是没有gcc的，需要安装</p>
<p>安装gcc , gdb, git, vim</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt-get install -y build-essential gdb git vim</span></span><br></pre></td></tr></table></figure>

<p>安装32位的支持库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt-get install gcc-multilib</span></span><br></pre></td></tr></table></figure>

<h3 id="2-编译安装工具链"><a href="#2-编译安装工具链" class="headerlink" title="2. 编译安装工具链"></a>2. 编译安装工具链</h3><h4 id="2-1下载以下工具包"><a href="#2-1下载以下工具包" class="headerlink" title="2.1下载以下工具包"></a>2.1下载以下工具包</h4><ul>
<li><a href="ftp://ftp.gmplib.org/pub/gmp-5.0.2/gmp-5.0.2.tar.bz2">ftp://ftp.gmplib.org/pub/gmp-5.0.2/gmp-5.0.2.tar.bz2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2">https://www.mpfr.org/mpfr-3.1.2/mpfr-3.1.2.tar.bz2</a></li>
<li><a target="_blank" rel="noopener" href="http://www.multiprecision.org/downloads/mpc-0.9.tar.gz">http://www.multiprecision.org/downloads/mpc-0.9.tar.gz</a></li>
<li><a target="_blank" rel="noopener" href="http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2">http://ftpmirror.gnu.org/binutils/binutils-2.21.1.tar.bz2</a></li>
<li><a target="_blank" rel="noopener" href="http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2">http://ftpmirror.gnu.org/gcc/gcc-4.6.4/gcc-core-4.6.4.tar.bz2</a></li>
<li><a target="_blank" rel="noopener" href="http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2">http://ftpmirror.gnu.org/gdb/gdb-7.3.1.tar.bz2</a></li>
</ul>
<p>第一个包可能下载不了，可以自己搜索，或是使用下面的链接</p>
<p><a target="_blank" rel="noopener" href="https://mirrors.sjtug.sjtu.edu.cn/gnu/gmp/gmp-5.0.2.tar.bz2">https://mirrors.sjtug.sjtu.edu.cn/gnu/gmp/gmp-5.0.2.tar.bz2</a></p>
<h4 id="2-2-编译安装"><a href="#2-2-编译安装" class="headerlink" title="2.2 编译安装"></a>2.2 编译安装</h4><p>为了方便，将以上6个压缩包放在一个文件夹下 ，<code>~/download/mit6.828</code></p>
<p>文件夹结构</p>
<p><a target="_blank" rel="noopener" href="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727131718755.png"><img src="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727131718755.png" alt="image-20210727131718755"></a></p>
<blockquote>
<p>以下的操作都是在 <code>~/download/mit6.828</code> 目录下</p>
</blockquote>
<ol>
<li><p>安装gmp-5.0.2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf gmp-5.0.2.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> gmp-5.0.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span>   <span class="comment"># 可能的错误：No usable m4 in $PATH or /usr/5bin (see config.log for reasons).</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span>             </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure>

<p>逐条执行命令，每执行一条后，输出无 <code>error</code> 就可往下执行，后面几个安装包也是一样的</p>
<blockquote>
<p>可能的错误是第3个命令，如果报错，执行以下命令，然后再次执行第3行命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt install m4</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装mpfr-3.1.2</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf mpfr-3.1.2.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> mpfr-3.1.2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span>           </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装mpc-0.9</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xzf mpc-0.9.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> mpc-0.9</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span>            </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装binutils-2.21.1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf binutils-2.21.1.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> binutils-2.21.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span> --target=i386-jos-elf --disable-werror</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install             <span class="comment"># This step may require privilege (sudo make install)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line"><span class="meta">$</span><span class="bash">i386-jos-elf-objdump -i</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功安装会输出类似下面的信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> BFD header file version (GNU Binutils) 2.21.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> elf32-i386</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  (header little endian, data little endian)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   i386...</span></span><br></pre></td></tr></table></figure></li>
<li><p>安装gcc-core-4.6.4</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf gcc-core-4.6.4.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> gcc-4.6.4</span></span><br><span class="line"><span class="meta">$</span><span class="bash">mkdir build</span>           </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash">../configure --prefix=/usr/<span class="built_in">local</span> \</span></span><br><span class="line"><span class="bash">    --target=i386-jos-elf --disable-werror \</span></span><br><span class="line"><span class="bash">    --disable-libssp --disable-libmudflap --with-newlib \</span></span><br><span class="line"><span class="bash">    --without-headers --enable-languages=c MAKEINFO=missing</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make all-gcc</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install-gcc</span>         </span><br><span class="line"><span class="meta">$</span><span class="bash">make all-target-libgcc		<span class="comment">#可能会报错 [configure-target-libgcc] Error 1</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install-target-libgcc</span>   </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ../..</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">测试</span></span><br><span class="line"><span class="meta">$</span><span class="bash">i386-jos-elf-gcc -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 成功安装会输出类似下面的信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Using built-in specs.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> COLLECT_GCC=i386-jos-elf-gcc</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> COLLECT_LTO_WRAPPER=/usr/<span class="built_in">local</span>/libexec/gcc/i386-jos-elf/4.6.4/lto-wrapper</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Target: i386-jos-elf</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>执行11行命令可能会报错，如果报错，执行以下命令，然后再次执行第11行命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/<span class="built_in">local</span>/lib</span> </span><br></pre></td></tr></table></figure></li>
<li><p>安装gdb-7.3.1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">tar xjf gdb-7.3.1.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> gdb-7.3.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash">./configure --prefix=/usr/<span class="built_in">local</span> --target=i386-jos-elf --program-prefix=i386-jos-elf- \</span></span><br><span class="line"><span class="bash">    --disable-werror</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make all			<span class="comment">#可能的错误 no termcap library found</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span>         </span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> ..</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可能报错的命令第5个，如果出现错误，执行以下命令，然后再执行该命令</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">wget http://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash">tar -zxv -f termcap-1.3.1.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> termcap-1.3.1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure</span> </span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="安装-QEMU"><a href="#安装-QEMU" class="headerlink" title="安装 QEMU"></a>安装 QEMU</h2><h3 id="1-安装工具包"><a href="#1-安装工具包" class="headerlink" title="1. 安装工具包"></a>1. 安装工具包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo apt install libsdl1.2-dev libtool-bin libglib2.0-dev  libz-dev  libpixman-1-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo apt install python2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-下载qemu"><a href="#2-下载qemu" class="headerlink" title="2. 下载qemu"></a>2. 下载qemu</h3><p>qemu需要用6.828定制的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">git <span class="built_in">clone</span> https://github.com/mit-pdos/6.828-qemu.git qemu</span></span><br></pre></td></tr></table></figure>

<h3 id="3-编译安装"><a href="#3-编译安装" class="headerlink" title="3. 编译安装"></a>3. 编译安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./configure --disable-kvm --disable-werror --prefix=/usr/<span class="built_in">local</span>  --target-list=<span class="string">&quot;i386-softmmu x86_64-softmmu&quot;</span> --python=python2</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo make install</span></span><br></pre></td></tr></table></figure>

<p>可能的错误：</p>
<ol>
<li><p>缺少一个头文件，错误如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qga/commands-posix.c: In function ‘dev_major_minor’:</span><br><span class="line">qga/commands-posix.c:633:13: error: In the GNU C Library, &quot;major&quot; is defined</span><br><span class="line"> by &lt;sys/sysmacros.h&gt;. For historical compatibility, it is</span><br><span class="line"> currently defined by &lt;sys/types.h&gt; as well, but we plan to</span><br><span class="line"> remove this soon. To use &quot;major&quot;, include &lt;sys/sysmacros.h&gt;</span><br><span class="line"> directly. If you did not intend to use a system-defined macro</span><br><span class="line"> &quot;major&quot;, you should undefine it after including &lt;sys/types.h&gt;. [-Werror]</span><br><span class="line">         *devmajor = major(st.st_rdev);</span><br><span class="line">             ^~~~~~~~~~~~~~~~~~~~~~~~~~   </span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决：在 qga/commands-posix.c文件中的 #include &lt;sys/types.h&gt; 下面增加#include &lt;sys/sysmacros.h&gt;即可</p>
</blockquote>
</li>
</ol>
<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载实验源码</span></span><br><span class="line"><span class="meta">$</span><span class="bash">git <span class="built_in">clone</span> https://pdos.csail.mit.edu/6.828/2018/jos.git lab</span></span><br><span class="line"><span class="meta">$</span><span class="bash"><span class="built_in">cd</span> lab</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make</span></span><br><span class="line"><span class="meta">$</span><span class="bash">make qemu-nox</span></span><br></pre></td></tr></table></figure>

<p>测试成功</p>
<p><a target="_blank" rel="noopener" href="https://kinvy-images.oss-cn-beijing.aliyuncs.com/Images/image-20210727171159202.png"><img src="https://s2.loli.net/2022/05/16/GwcegZSjm3AsvRU.png" alt="image-20210727171159202"></a></p>
<h2 id="vscode连接ubuntu"><a href="#vscode连接ubuntu" class="headerlink" title="vscode连接ubuntu"></a>vscode连接ubuntu</h2><p>连接时一直显示失败，但是termius可以连接上</p>
<p>应该是vscode不支持此版本的ubuntu</p>
<p>换到clion后，可以使用</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/14/vsvode%E4%BD%BF%E7%94%A8ssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/14/vsvode%E4%BD%BF%E7%94%A8ssh%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux/" class="post-title-link" itemprop="url">vsvode使用ssh远程连接linux</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-14 15:24:45 / 修改时间：15:25:31" itemprop="dateCreated datePublished" datetime="2022-05-14T15:24:45+08:00">2022-05-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1.找到自己电脑公钥C:<code>Users**用户名**.ssh</code>这个目录<br><code>id-rsa</code>和<code>id-rsa.pub</code>两个文件, 第一个是私钥文件,第二个是公钥文件</p>
<p>2.将公钥添加到远程linux系统中</p>
<p>sudo vim /root/.ssh/authorized_keys</p>
<p>:wq保存退出</p>
<p>3.启用秘钥方式登录</p>
<p>sudo vim /etc/ssh/sshd_config</p>
<p><code>PubkeyAuthentication</code> yes的注释去掉</p>
<p>:wq保存退出</p>
<p>4.检查ssh服务</p>
<p>sudo netstat -ntlp | grep ssh 如果有22端口说明已经启动，如果没有列出执行以下命令</p>
<p>/etc/init.d/ssh resart</p>
<p>5.配置vscode远程连接信息</p>
<p>  1.vscode安装Remote - SSH</p>
<p>  2.Remote Explorer里面选择SSH Targets</p>
<p>  3.选择+号添加连接信息， ssh <strong>user</strong>@<strong>ip</strong> -p 22, 其中user为远程电脑登录用户名，ip为远程电脑ip地址</p>
<p>  如果配置过程中出现 <strong>过程试图写入的管道不存在</strong>找到以下文件</p>
<p>  C:<code>Users**用户名**.sshconfig</code></p>
<p>``` 右键 属性-&gt;安全-&gt;高级-&gt;禁用继承/然后 添加-&gt;-&gt;高级-&gt;立即查找-&gt;选择你的用户名-&gt;添加上**修改**的权限`</p>
<p>`` 然后使用vscode再次连接，中间过程会弹出输入登录机器密码的对话框，输入即可</p>
<p>仅作记录</p>
<p>ref: <a target="_blank" rel="noopener" href="http://t.zoukankan.com/guanglin-p-14931464.html">http://t.zoukankan.com/guanglin-p-14931464.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/17/Cplusplus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/17/Cplusplus/" class="post-title-link" itemprop="url">Cplusplus</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-17 09:34:28" itemprop="dateCreated datePublished" datetime="2022-04-17T09:34:28+08:00">2022-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-25 13:45:57" itemprop="dateModified" datetime="2022-04-25T13:45:57+08:00">2022-04-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、计算机基础"><a href="#一、计算机基础" class="headerlink" title="一、计算机基础"></a>一、计算机基础</h1><ol>
<li>C/C++内存有哪几种类型？<br>C中，内存分为5个区：<strong>堆</strong>(malloc)、<strong>栈</strong>(如局部变量、函数参数)、<strong>程序代码区</strong>（存放二进制代码）、<strong>全局/静态存储区</strong>（全局变量、static变量）和<strong>常量存储区</strong>（常量）。此外，C++中有<strong>自由存储区</strong>（new）一说。<br>全局变量、static变量会初始化为缺省值，而堆和栈上的变量是随机的，不确定的。</li>
</ol>
<ol start="2">
<li><p>堆和栈的区别？<br> 1).堆存放动态分配的对象——即那些在程序运行时动态分配的对象，比如 new 出来的对象，其生存期由程序控制；<br> 2).栈用来保存定义在函数内的<strong>非static对象</strong>，如局部变量，仅在其定义的程序块运行时才存在；<br> 3).静态内存用来保存static对象，类static数据成员以及定义在任何函数外部的变量，static对象在使用之前分配，程序结束时销毁；<br> 4).栈和静态内存的对象由编译器自动创建和销毁。</p>
</li>
<li><p>堆和自由存储区的区别？<br>总的来说，堆是C语言和操作系统的术语，是操作系统维护的一块动态分配内存；自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。他们并不是完全一样。<br>从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。<strong>基本上，所有的C++编译器默认使用堆来实现自由存储</strong>，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/02/%E8%BF%90%E7%AD%B9%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/02/%E8%BF%90%E7%AD%B9%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">运筹优化知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-02 10:45:00" itemprop="dateCreated datePublished" datetime="2022-04-02T10:45:00+08:00">2022-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-25 13:46:12" itemprop="dateModified" datetime="2022-04-25T13:46:12+08:00">2022-04-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="optimization-problem"><a href="#optimization-problem" class="headerlink" title="optimization problem"></a>optimization problem</h1><ol>
<li>无约束的优化问题</li>
<li>带等式约束的优化问题</li>
<li>带不等式约束的优化问题</li>
</ol>
<h1 id="dual"><a href="#dual" class="headerlink" title="dual"></a>dual</h1><h2 id="KKT"><a href="#KKT" class="headerlink" title="KKT"></a>KKT</h2><p>经典注水问题：<br>$$<br>min -\sum^n_{i=1}log(\alpha + x_i) \<br>s.t.~~~~~~~~  x \geq, 1^Tx=1<br>$$<br>其中$\alpha_i &gt;0$ 。</p>
<p>令$x^*$ and $(\lambda^*,v*)$分别是原问题和对偶问题的某对最优解，对偶间隙为0，可以得到如下的KTT条件：<br>$$<br>x^* &gt; 0,~~~ 1^Tx^*=1,~~~\lambda^<em>\succeq0,~~~ \lambda_i^</em>x_i^*=0,i=1…n, \<br>\frac{-1}{\alpha_i + x_i^*}-\lambda_i^*+v^*=0, i=1…,n<br>$$<br>$\lambda^*$在最后一个方程里是一个松弛变量，可以消去。<br>$$<br>x^* &gt; 0,~~~ 1^Tx^*=1,~~~\lambda^<em>\succeq0,~~~ x_i^</em>(v^* - \frac{1}{\alpha_i + x_i^*})=0,i=1…n, \<br>v^* \geq \frac{1}{\alpha_i + x_i^*}, i=1…,n<br>$$<br>所以有下式：<br>$$<br>x_i^*=\left{ \begin{aligned} &amp;\frac{1}{v^*}-\alpha_i, &amp;v^* &lt; \frac{1}{\alpha^*} \<br>&amp;0 , &amp;v^<em>\geq \frac{1}{\alpha^</em>}<br>\end{aligned}<br>\right.<br>$$<br>更简洁地，$x^* = max{\frac{1}{v^*} - \alpha_i, 0}$, 将该值代入条件$1^Tx^*=1$，可以得到<br>$$<br>\sum^n_{i=1}max{ 0,\frac{1}{v^*}-\alpha_i }=1<br>$$</p>
<h1 id="单纯形法"><a href="#单纯形法" class="headerlink" title="单纯形法"></a>单纯形法</h1><p>单纯形算法适用的情况</p>
<p><strong>标准的线性规划格式</strong><br>$$<br>&amp; max~~~ c^Tx \<br>&amp; ~~~~~~~~~s.t. ~~~A*x \leq b \<br>&amp;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ x_i \geq 0, i = 1,2,3,…,n<br>$$<br><strong>松弛型</strong></p>
<img src="https://s2.loli.net/2022/04/11/OlA1U6KkL4q3DnC.png" alt="image-20220411162221373" style="zoom:50%;" />

<p>主问题是 $2x_1 + x_2$, 不是$x_3$</p>
<p>加入非负松弛变量</p>
<img src="https://s2.loli.net/2022/04/11/hCZbmrWAHNowYPa.png" alt="image-20220411162306991" style="zoom:50%;" />

<p><strong>单纯形</strong></p>
<img src="https://s2.loli.net/2022/04/11/NgPC9wDpdcuGBEy.png" alt="image-20220411162333695" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/04/11/mC6Bopq7vzXjfDW.png" alt="image-20220411162348367" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/04/12/ChxMY9U1AlRXao3.png" alt="image-20220411162407384" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/04/12/H4bA6pzI5sjwWLJ.png" alt="image-20220411162420712" style="zoom:50%;" />

<p>ref: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/388224103">https://zhuanlan.zhihu.com/p/388224103</a></p>
<h1 id="影子价格"><a href="#影子价格" class="headerlink" title="影子价格"></a>影子价格</h1><h1 id="Row-Generation（就是割平面法）"><a href="#Row-Generation（就是割平面法）" class="headerlink" title="Row Generation（就是割平面法）"></a>Row Generation（就是割平面法）</h1><p><strong>常用于整数规划</strong></p>
<p>割平面方法，从更宏观的角度，可以看作是一种行生成方法。这里的“行”（row），指的是线性不等式。每找到一个cut，就增加一个线性不等式。</p>
<p>线性规划的算法复杂度和连续变量呈多项式级关系，另外随着约束条件（不等式）个数的增加，求解时间也会随之增加。（不确定呈什么关系，求拍砖）</p>
<p>上面说到整数规划的算法复杂度和整数变量的个数n基本呈指数关系，那么它还和其他什么因素相关呢？答案是不等式的个数。（recall求解整数规划需要求解一个个的线性规划）</p>
<p>我们从线性规划角度，理解行生成方法的基本思想：形成极值（最优解）所需要的约束条件个数，往往远小于原问题的约束条件个数。因此为何不在需要的时候，才把这些“重要”的约束条件加上来呢？</p>
<p>下面举个简单例子：</p>
<p>如下图，原问题有5个不等式（一条红线代表一个不等式），但是最优解点D只需CD和DE 2个不等式即可表述。</p>
<img src="https://s2.loli.net/2022/04/12/2i4wUupVWlmx8Mr.png" alt="image-20220412174455417" style="zoom:50%;" />

<p>因此行生成方法的基本思路：先求解原问题的松弛问题，即初始问题（master problem）不加约束条件或只加其中几个约束，然后求解该松弛问题，如果得到的解是可行解，那么该解就是原问题的最优解（例如刚开始运气很好地加了CD和DE）。</p>
<p>如果得到的解对原问题是不可行的，例如解是（0，6）这个点（因为没有加BC这个约束），或者无界的，那么这时候加上BC这个不等式便可以把这个不可行解排除。</p>
<p>以此循环，直到松弛问题的解是可行的，那么该解也是原问题的最优解。</p>
<p>而通过行生成方法，上面问题本来需要5个约束条件，很可能只需要2-3个约束条件，上面的循环已经终止了。</p>
<p>在实际问题中，最优解所需要的约束条件往往远远小于原问题的约束条件个数。例如几万个约束条件，实际只有几百个是用来刻画最优解的。那么这个时候，割平面方法便可以大大提速线性规划的求解。</p>
<p>在上一节的TSP问题中，subtour elimination constraints的个数是指数级的（因此不可能把他们全部加进来），但是求解实际问题中，往往通过割平面方法只需找到其中几千或几百个，即可找到原问题的最优解。用到的，正是相似的思路。</p>
<p>其实TSP问题是有完整刻画的表达式的（Complete Formulation），这时的约束个数虽然不是指数级，但是数量也非常大，因此求解效率很低。割平面方法的引入，大大增加了TSP问题求解的高效性，这也是该方法一次完美的show off。</p>
<p>搜索Literature 行生成方法，最先映入眼帘的可能是Benders’ Decomposition。在那里，一般把整数和实数变量隔离做分解，然后有比较“严格”的如何选取初始约束以及如何一步步地增加约束（feasibility cut和optimality cut）。</p>
<p><strong>与行生成法对偶的方法，是列生成法</strong>（逐步增加变量个数）。其中的Dantzig-Wolfe分解法，是Benders’ Decomposition的dual problem。</p>
<p><strong>ref:</strong>    <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28387290?group_id=893712252413284352">https://zhuanlan.zhihu.com/p/28387290?group_id=893712252413284352</a></p>
<h1 id="column-generation"><a href="#column-generation" class="headerlink" title="column generation"></a>column generation</h1><p>列生成算法（Column Generation Algorithm）是一种用于求解<strong>大规模线性优化问题</strong>的高效算法，本质上来讲，列生成算法是单纯形法的一种形式，用来求解线性规划问题。</p>
<p>列生成算法已被应用于求解很多著名的NP-hard优化问题，如机组人员调度问题（Crew assignment problem）、切割问题（Cutting stock problem）、车辆路径问题（Vehicle routing problem）、单资源工厂选址问题（The single facility location problem）等</p>
<p><strong>基本思想</strong></p>
<p>列生成算法通过求解子问题（sub problem）来找到可以进基的非基变量，该非基变量在模型中并没有显性的写出来（可以看成是生成了一个变量，每个变量其实等价于一列，所以该方法被称为列生成算法）。如果找不到一个可以进基的非基变量，那么就意味着所有的非基变量的检验数（Reduced Cost，RC）都满足最优解的条件，也就是说，该线性规划的最优解已被找到。其思路如下：</p>
<p>1、先把原问题（Master Problem，MP）转换到一个规模更小（即变量数比原问题少）的问题上，这个只使用部分变量的模型被称为原问题的RMP 问题（Restricted Master Problem）。在RMP上用单纯形法求最优解，注意此时求得的最优解只是RMP上的，并不是MP的最优解。</p>
<p>2、然后需要通过一个子问题去检测在那些未被考虑的变量中是否有使得RC小于零的情况，如果有，那么就把这个变量的相关系数列加入到RMP的系数矩阵中，返回第1步。</p>
<p>经过反复迭代，直到子问题中的RC都大于等于零，此时就找到了MP的最优解。</p>
<p><strong>注意min和max问题的影子价格</strong></p>
<h1 id="拉格朗日松弛"><a href="#拉格朗日松弛" class="headerlink" title="拉格朗日松弛"></a>拉格朗日松弛</h1><p>拉格朗日对偶（问题）</p>
<h1 id="bender’s-decomposition"><a href="#bender’s-decomposition" class="headerlink" title="bender’s decomposition"></a>bender’s decomposition</h1><p>主要思想是行生成+割平面方法</p>
<h2 id="single-bender’s"><a href="#single-bender’s" class="headerlink" title="single bender’s"></a>single bender’s</h2><h2 id="multi-bender’s"><a href="#multi-bender’s" class="headerlink" title="multi bender’s"></a>multi bender’s</h2><h1 id="branch-and-bound（精确算法）"><a href="#branch-and-bound（精确算法）" class="headerlink" title="branch and bound（精确算法）"></a>branch and bound（精确算法）</h1><p><strong>分支定界</strong></p>
<p>分支定界算法始终围绕着一颗搜索树进行的，我们将原问题看作搜索树的根节点，从这里出发，分支的含义就是将大的问题分割成小的问题。大问题可以看成是搜索树的父节点，那么从大问题分割出来的小问题就是父节点的子节点了。分支的过程就是不断给树增加子节点的过程。而定界就是在分支的过程中检查子问题的上下界，如果子问题不能产生一比当前最优解还要优的解，那么砍掉这一支。直到所有子问题都不能产生一个更优的解时，算法结束。</p>
<img src="https://s2.loli.net/2022/04/12/tvXw4O9s8zVU3GB.png" alt="image-20220412155612418" style="zoom:33%;" />

<p><strong>例子</strong></p>
<p>对于一个整数规划模型：<br>$$<br>maximize~~~~~~&amp;4x_1+9x_2+6x_3 \<br>subject~ to~~~~&amp;5x_1+8x_2+6x_3 \leq 12 \<br>&amp;x_1,x_2,x_3 ~ are~ binary~ variable<br>$$<br>因为求解的是最大化问题，不妨先设当前的最优解为负无穷：-INF。</p>
<ol>
<li><strong>首先从主问题分出两支子问题：</strong></li>
</ol>
<img src="https://s2.loli.net/2022/04/12/ZdT1qGzwELYUjSC.png" alt="image-20220412160043235" style="zoom: 50%;" />

<p>通过线性松弛求得两个子问题的upper bound为Z_LP1 = 12.75，Z_LP2 = 12.2。由于Z_LP1 和Z_LP2都大于BestV=-INF，说明这两支均满足要求。继续往下。</p>
<ol start="2">
<li><strong>从节点 1 和节点 2 两个子问题再次分支，得到如下结果</strong></li>
</ol>
<img src="https://s2.loli.net/2022/04/12/aE4W5fBDbHTcvuG.png" alt="image-20220412161353856" style="zoom: 50%;" />

<p>子问题3已经不可行，无需再理。子问题4通过线性松弛得到最优解为10，刚好也符合原问题0的所有约束，在该支找到一个可行解，更新BestV = 10。</p>
<p>子问题5通过线性松弛得到upper bound为11.87&gt;当前的BestV = 10，因此子问题5还有戏，待下一次分支。而子问题6得到upper bound为9&lt;当前的BestV = 10，那么从该支下去找到的解也不会变得更好，所以剪掉！</p>
<ol start="3">
<li><strong>对结点5进行分支</strong></li>
</ol>
<img src="https://s2.loli.net/2022/04/12/uIATlUHx9jaoghs.png" alt="image-20220412161453040" style="zoom:50%;" />

<p>子问题7不可行，无需再理。子问题8得到一个满足原问题0所有约束的解，但是目标值为4&lt;当前的BestV=10，所以不更新BestV，同时该支下去也不能得到更好的解了。</p>
<ol start="4">
<li><strong>此时，所有的分支遍历都完成，我们最终找到了最优解。</strong></li>
</ol>
<p><strong>分支定界法（branch and bound）</strong>是一种<strong>求解整数规划问题</strong>的最常用算法。这种方法不但可以求解纯整数规划，<strong>还可以求解混合整数规划问题</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. Using a heuristic, find a solution xh to the optimization problem. Store its value, B = f(x_h). (If no heuristic is available, set B to infinity.) B will denote the best solution found so far, and will be used as an upper bound on candidate solutions.</span><br><span class="line"></span><br><span class="line">2. Initialize a queue to hold a partial solution with none of the variables of the problem assigned.</span><br><span class="line"></span><br><span class="line">3. Loop until the queue is empty:</span><br><span class="line"></span><br><span class="line">	3.1. Take a node N off the queue.</span><br><span class="line">	</span><br><span class="line">	3.2. If N represents a single candidate solution x and f(x) &lt; B, then x is the best solution so far. Record it and set B ← f(x).</span><br><span class="line">	</span><br><span class="line">	3.3. Else, branch on N to produce new nodes Ni. For each of these:</span><br><span class="line"></span><br><span class="line">		3.3.1. If bound(N_i) &gt; B, do nothing; since the lower bound on this node is greater than the upper bound of the problem, it will never lead to the optimal solution, and can be discarded.</span><br><span class="line">		</span><br><span class="line">		3.3.2. Else, store Ni on the queue.</span><br></pre></td></tr></table></figure>



<p><strong>ref:</strong>   <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dengfaheng/p/11225612.html">https://www.cnblogs.com/dengfaheng/p/11225612.html</a></p>
<h1 id="branch-and-cut"><a href="#branch-and-cut" class="headerlink" title="branch and cut"></a>branch and cut</h1><p>branch and cut其实还是和branch and bound脱离不了干系的。</p>
<p>在应用branch and bound求解整数规划问题的时候，如下图:</p>
<img src="https://s2.loli.net/2022/04/12/nvNTFE8UzOCZtWS.png" alt="image-20220412171138059" style="zoom:50%;" />

<p>假如，我们现在求一个整数规划最大化问题，在分支定界过程中，求解整数规划模型的LP松弛模型得到的非整数解作为上界，而此前找到的整数解作为下界。 如果出现某个节点upper bound低于现有的lower bound，则可以剪掉该节点。否则，如果不是整数解继续分支。</p>
<p>此外，在求解整数规划模型的LP松弛时，<strong>If cutting planes are used to tighten LP relaxations。</strong>那么这时候的branch and bound就变成了branch and cut。   <strong>割平面</strong></p>
<img src="https://s2.loli.net/2022/04/12/AMhmExzpJrowPLG.png" alt="image-20220412171238809" style="zoom:50%;" />

<p>红色部分是整数规划的可行解空间。<br>蓝色部分是整数规划的LP松弛可行解空间。<br>在求解LP松弛时，加入橙色的cut，缩小解空间，同时又不影响整数解的解空间，可使解收敛得更快。</p>
<p>这就是branch and cut的过程了。比branch and bound高明之处就在于多了一个cutting planes，可能使branch and bound的效率变得更高。</p>
<p><strong>例子</strong><br>$$<br>min~~~~~~~~~~~~~ &amp;z=-6x_1-5_2 \<br>subject~to~~~&amp;3x_1+x_2 \leq 11 \<br>&amp;-x_1+2x_2 \leq 5 \<br>&amp;x_1,x_2 \geq 0<br>$$<br><img src="https://s2.loli.net/2022/04/12/feg4ZSWLiKBYanc.png" alt="image-20220412171533780"></p>
<p><img src="https://s2.loli.net/2022/04/12/4rb9IVU3pRLSAY7.png" alt="image-20220412171629952"></p>
<p><strong>ref:</strong>     <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dengfaheng/p/11344488.html">https://www.cnblogs.com/dengfaheng/p/11344488.html</a></p>
<p><strong>更加详细的一个参考</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28387290?group_id=893712252413284352">https://zhuanlan.zhihu.com/p/28387290?group_id=893712252413284352</a></p>
<h1 id="内点法"><a href="#内点法" class="headerlink" title="内点法"></a>内点法</h1><h1 id="各类梯度下降法和牛顿法"><a href="#各类梯度下降法和牛顿法" class="headerlink" title="各类梯度下降法和牛顿法"></a>各类梯度下降法和牛顿法</h1><p><strong>批量梯度下降：</strong></p>
<ol>
<li><p>是最小化所有样本的损失函数，最终得到全局最优解。　　　　　　</p>
</li>
<li><p>由于每次更新参数需要重新训练一次全部的样本，代价比较大，适用于小规模样本训练的情况。</p>
</li>
</ol>
<p><strong>随机梯度下降：</strong></p>
<ol>
<li><p>是最优化每个样本的损失函数。每一次迭代得到的损失函数不是，每次每次向着全局最优的方向，但是大体是向着全局最优，最终的结果往往是在最优解的附近。　　　</p>
</li>
<li><p>当目标函数是凸函数的时候，结果一定是全局最优解。</p>
<p>　　　　　　　3. 适合大规模样本训练的情况。</p>
</li>
</ol>
<p><strong>小批量梯度下降法：</strong></p>
<p>　将上述两种方法作结合。每次利用一小部分数据更新迭代参数。即样本在1和m之间。</p>
<h3 id="牛顿法："><a href="#牛顿法：" class="headerlink" title="牛顿法："></a>牛顿法：</h3><p>是通过求解目标函数的一阶导数为0时的参数，进而求出目标函数最小值时的参数。</p>
<p>优点：收敛速度很快。海森矩阵的逆在迭代过程中不断减小，可以起到逐步减小步长的效果。</p>
<p>缺点：海森矩阵的逆计算复杂，代价比较大，因此有了拟牛顿法。</p>
<p>x多变量时，二阶导使用hessian 矩阵</p>
<h3 id="梯度下降法："><a href="#梯度下降法：" class="headerlink" title="梯度下降法："></a>梯度下降法：</h3><p>是通过梯度方向和步长，直接求解目标函数的最小值时的参数。</p>
<p>越接近最优值时，步长应该不断减小，否则会在最优值附近来回震荡。</p>
<img src="https://s2.loli.net/2022/04/05/7TF6qYWKdtrQwzy.png" alt="image-20220405211558700" style="zoom: 67%;" />

<img src="https://s2.loli.net/2022/04/05/y1hXAfk682Hc4DE.png" alt="image-20220405211627441" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/04/05/1aAoWc8OKds3PJU.png" alt="image-20220405211655906" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/04/05/StCsT3KaGL64cxE.png" alt="image-20220405211707643" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/04/12/xad3FKUT1eiwvWR.png" alt="image-20220405211722098" style="zoom:67%;" />

<p><strong>使用牛顿法/拟牛顿法收敛更快。但是每次迭代的时间比梯度下降法长。</strong></p>
<p>ref: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112416130">https://zhuanlan.zhihu.com/p/112416130</a></p>
<h1 id="CO"><a href="#CO" class="headerlink" title="CO"></a>CO</h1><h1 id="MIP"><a href="#MIP" class="headerlink" title="MIP"></a>MIP</h1><h2 id="MILP"><a href="#MILP" class="headerlink" title="MILP"></a>MILP</h2><p>非线性转为线性</p>
<p>基于CO，CO做了有功和无功的平衡</p>
<p>将约束条件转换为惩罚项。使得主问题变为线性问题，求解MILP</p>
<h1 id="RO"><a href="#RO" class="headerlink" title="RO"></a>RO</h1><p>苏文藻课程</p>
<h1 id="SO"><a href="#SO" class="headerlink" title="SO"></a>SO</h1><p>苏文藻课程</p>
<h1 id="distributionally-robust-optimization"><a href="#distributionally-robust-optimization" class="headerlink" title="distributionally robust optimization"></a>distributionally robust optimization</h1><p>苏文藻课程</p>
<h1 id="粒子群算法（PSO）和遗传算法"><a href="#粒子群算法（PSO）和遗传算法" class="headerlink" title="粒子群算法（PSO）和遗传算法"></a>粒子群算法（PSO）和遗传算法</h1><p>PSO: partivcle swarm optimizatioin</p>
<p>GA: genetic algorithm</p>
<p>PSO和GA的<strong>相同点：</strong></p>
<ol>
<li>都属于仿生算法。PSO主要模拟鸟类觅食、人类认知等社会行为而提出；GA主要借用生物进化论中”适者生存“的规律。</li>
<li>都属于全局优化方法。两种算法都是在解空间随机产生初始种群，因为算法在全局的解空间进行搜索，且将搜索重点集中在性能高的部分。</li>
<li>都属于随机搜索算法。都是通过随机优化方法更新种群和搜索最优点。PSO中认知项和社会项前都加有随机数。GA的遗传操作均属于随即操作。</li>
<li>都隐含并行性。搜索过程是从问题解的一个集合开始，而不是从单个个体开始，具有隐含并行搜索特性，从而减小了陷入局部极小的可能性。</li>
<li>根据个体的适配信息进行搜索，因此不受函数约束条件的限制，如连续性、可导性等。</li>
<li>对高维复杂问题，往往会遇到早熟收敛和收敛性能差的缺点，都无法保证收敛到最优点。</li>
</ol>
<p>PSO和GA的<strong>不同点：</strong></p>
<ol>
<li>PSO有记忆，好的解的所有粒子均保存，而GA没有记忆，以前的知识随着种群的改变而被破坏。</li>
<li>GA算法中，染色体之间相互共享信息，所以整个种群的移动是比较均匀的向最优区域移动。PSO中的例子仅仅通过当前搜索到的最优点进行共享信息，所以很大程度上这是一种单项信息共享机制，整个搜索更新过程是跟随当前最优解的过程。<strong>在大多数情况下，所有粒子可能比遗传算法中的进化个体以更快速度收敛于最优解。</strong> </li>
<li>PSO相对于GA，不需要编码，没有交叉和变异操作，粒子只是通过内部速度进行更新，因此原理更简单、参数更少、实现更容易。</li>
<li>PSO算法主要应用于连续问题，包括神经网络训练和函数优化等，而GA除了连续问题之外，还可应用于离散问题，比如TSP问题、货郎担问题、工作车间调度等。</li>
</ol>
<h1 id="禁忌搜索算法"><a href="#禁忌搜索算法" class="headerlink" title="禁忌搜索算法"></a>禁忌搜索算法</h1><p>禁忌搜索(Tabu Search, TS)也是属于模拟人类智能的一种优化算法。</p>
<img src="https://s2.loli.net/2022/04/15/Iz2RtKDcQdZrkEV.jpg" alt="img" style="zoom: 67%;" />

<p><strong>禁忌表（Tabu List，TL）</strong><br><strong>是用来存放（记忆）禁忌对象的表</strong>。它是禁忌搜索得以进行的基本前提。禁忌表本身是有容量限制的，它的大小对存放禁忌对象的个数有影响，会影响算法的性能。</p>
<p><strong>禁忌对象（Tabu Object，TO）</strong><br><strong>是指禁忌表中被禁的那些变化元素</strong>。禁忌对象的选择可以根据具体问题而制定。例如在旅行商问题（Traveling Salesman Problem，TSP）中可以将交换的城市对作为禁忌对象，也可以将总路径长度作为禁忌对象。</p>
<p><strong>禁忌期限（Tabu Tenure，TT）</strong><br>也叫禁忌长度，<strong>指的是禁忌对象不能被选取的周期</strong>。禁忌期限过短容易出现循环，跳不出局部最优，长度过长会造成计算时间过长。</p>
<p><strong>渴望准则（Aspiration Criteria，AC）</strong><br>也称为特赦规则。<strong>当所有的对象都被禁忌之后，可以让其中性能最好的被禁忌对象解禁</strong>，或者当某个对象解禁会带来目标值的很大改进时，也可以使用特赦规则。</p>
<p><strong>非对称的旅行商问题（ATSP）</strong></p>
<p><img src="https://s2.loli.net/2022/04/15/tRMBUr7ebDYcZIi.png" alt="image-20220415155952005"></p>
<p>分析：这是一个简单的问题,利用枚举的方法也可以找到最优的答案，但是，找到答案不是我们的目的，我们主要是想通过一一个简单的例子来理解禁忌搜索是如何进行工作的。从距离矩阵D可以看到，这是一个<strong>非对称</strong>的TSP问题，但是这并不影响算法的执行。由于题目假设了邻域构造的方式，而且规定了始点和终点都是城市a，因此，在以下的求解过程中，我们不使用城市a和其他城市进行交换，这样的操作并不会影响全局寻优的能力。</p>
<img src="https://pic3.zhimg.com/80/v2-d325fe1019c1c1b584a9f460eeca7df2_720w.jpg" alt="img" style="zoom: 67%;" />

<p><strong>注：</strong>在实际应用中，通过选择更高的禁忌对象，设置合理的禁忌期限，或者采用其他更好的的参数，都可以避免循环（反复出现同种情况的邻域值）的出现，提高算法的性能。</p>
<h1 id="常见的机器学习算法"><a href="#常见的机器学习算法" class="headerlink" title="常见的机器学习算法"></a>常见的机器学习算法</h1><h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><img src="https://s2.loli.net/2022/04/04/31WiDgLGTE8dM4l.jpg" alt="43E6AF2BAF69572D95CD2DBEAECD8CB2" style="zoom: 80%;" />

<img src="https://s2.loli.net/2022/04/04/V6lH1xLfmhgTZnw.jpg" alt="IMG_0397" style="zoom:33%;" />



<img src="https://s2.loli.net/2022/04/04/3zKRPoN5IMLc1QX.jpg" alt="IMG_0399" style="zoom:50%;" />

<p><img src="https://s2.loli.net/2022/04/05/aux2AeH3yhLnEG5.jpg" alt="IMG_0400"></p>
<p><img src="https://s2.loli.net/2022/04/05/enNSxgiFrtEhfKy.jpg" alt="QQ图片20220404232547"></p>
<p>机器学习给的KKT和凸优化给的不同。但是我认为二者是等价的，应该可以互推。</p>
<p>这个是凸优化上的条件。</p>
<p><img src="https://s2.loli.net/2022/04/05/mP3SAVBihEr1Rxy.png" alt="image-20220405110624726"></p>
<h2 id="贝叶斯"><a href="#贝叶斯" class="headerlink" title="贝叶斯"></a>贝叶斯</h2><p>后验概率的获得主要有两种策略</p>
<ol>
<li> 给定x，直接建模$P(c|x)$来预测c，这样叫做”判别式模型“</li>
<li>先对联合概率分布$P(x|c)$建模，然后再由此获得$P(c|x)$.</li>
</ol>
<p>$$<br>P(c|x)&amp;= \frac{P(cx)}{P(x)} =\frac{P(c)P(x|c)}{P(x)} \<br>&amp;=\frac{P(c)}{P(x)}\cdot\frac{P(x|c)}{P(x)}\<br>&amp;= \frac{P(c)}{P(x)}\cdot \prod_{i=1}^{d}P(x_i|c)<br>$$</p>
<p>$P(cx) = P(c)P(x|c) = P(x)P(x|c)$</p>
<p>朴素贝叶斯要求独立同分布。</p>
<p>半朴素贝叶斯分类器，对属性条件独立性假设进行了一定程度的放松。</p>
<p><img src="https://s2.loli.net/2022/04/05/qzYdSFNCRwMITJg.jpg" alt="IMG_0408"></p>
<p>贝叶斯网，借助有向无环图来刻画属性之间的依赖关系。用条件概率表来描述属性的联合概率分布。</p>
<h3 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h3><p>我们一直假设训练样本的所有属性都被观测到，即训练样本是完整的，但是现实中常遇到不完整的样本，这种未能观测到的特征称为”隐变量“。</p>
<p>令<strong>X</strong>表示已观测到的变量集，<strong>Z</strong>表示隐变量集，$\Theta$表示模型参数，若欲对$\Theta$做极大似然估计，则应该最大化对数似然。<br>$$<br>LL(\Theta|X,Z) = \ln P(X,Z|\Theta)<br>$$<br>由于<strong>Z</strong>是隐变量，该式无法求解，此时可以通过对<strong>Z</strong>计算期望，来最大化已观测数据的对数”边际似然“</p>
<img src="https://s2.loli.net/2022/04/05/znXsWkHx1uKr6wS.jpg" alt="IMG_0406" style="zoom:50%;" />



<img src="https://s2.loli.net/2022/04/05/Jz3ME2Uustfwd7W.png" alt="image-20220405163218219" style="zoom:50%;" />



<img src="https://s2.loli.net/2022/04/05/E7epgyfWKiRzuvh.png" alt="image-20220405163353314" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/04/05/OU6KCEBo3lHDLjc.png" alt="image-20220405163644044" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/04/05/rwm2iCGY7ZKX3Bp.jpg" alt="IMG_0407" style="zoom: 50%;" />

<img src="https://s2.loli.net/2022/04/05/oWbzHIuAx2NSdCk.png" alt="image-20220405164448434" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/04/12/k7JlOnXshWMopT1.png" alt="image-20220405170825391" style="zoom:50%;" />

<p>$\propto$正比于</p>
<img src="https://s2.loli.net/2022/04/12/GwrPcM8OuxULJYv.png" alt="image-20220405171059473" style="zoom:50%;" />



<h2 id="Linear-model"><a href="#Linear-model" class="headerlink" title="Linear model"></a>Linear model</h2><h2 id="HMM"><a href="#HMM" class="headerlink" title="HMM"></a>HMM</h2><p>隐马尔科夫模型是结构最简单的动态贝叶斯网，是一种著名的有向图模型，主要用于时序数据建模，在语音识别、自然语言处理等领域有广泛应用。</p>
<p>三个基本步骤</p>
<ol>
<li><p>给定参数，观测序列，计算条件概率</p>
</li>
<li><p>参数学习，给定序列，反推参数</p>
</li>
<li><p>解码。给定参数和观测序列，求最大可能性。</p>
</li>
</ol>
<h2 id="次梯度"><a href="#次梯度" class="headerlink" title="次梯度"></a>次梯度</h2><p>支撑超平面的斜率就是次梯度。</p>
<p>最起码是凸函数才能保证任意一点的次梯度存在。</p>
<p><strong>次梯度下降</strong></p>
<p><img src="https://s2.loli.net/2022/04/05/2QC5DFW8OPVRBeq.png" alt="image-20220405135334199"></p>
<h2 id="近端梯度"><a href="#近端梯度" class="headerlink" title="近端梯度"></a>近端梯度</h2><p><img src="https://s2.loli.net/2022/04/05/JMpbdenLoHl4WsK.png" alt="image-20220405150019553"></p>
<p><img src="https://s2.loli.net/2022/04/05/2lS9qtzTc4X1vw5.png" alt="image-20220405150032359"></p>
<p><img src="https://s2.loli.net/2022/04/05/2xA4BL5z1Eok7M9.png" alt="image-20220405150045008"></p>
<p><img src="https://s2.loli.net/2022/04/05/1gvUwrqYBSt9V5j.png" alt="image-20220405150056680"></p>
<p><img src="https://s2.loli.net/2022/04/05/ro8kEHKAIxg1hXQ.png" alt="image-20220405150213656"></p>
<p><img src="https://s2.loli.net/2022/04/05/QT9DgAbnELmwtd8.png" alt="image-20220405150221222"></p>
<p>ref：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38290475/article/details/81052206">https://blog.csdn.net/qq_38290475/article/details/81052206</a></p>
<h1 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h1><p><img src="https://s2.loli.net/2022/04/05/Ov49MyQBKW8jcpI.jpg" alt="img"></p>
<h3 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h3><img src="https://pica.zhimg.com/v2-e47296e78fff3d97eea11d0657ddcb81_1440w.jpg?source=172ae18b" alt="【机器学习】降维——PCA（非常详细）" style="zoom: 33%;" />



<p>风电数据</p>
<p>构建DRO时候，不同机组的历史数据不同，</p>
<p><img src="https://s2.loli.net/2022/04/05/q4QFwmU5SvfK1rH.png" alt="img"></p>
<h1 id="LDR变换"><a href="#LDR变换" class="headerlink" title="LDR变换"></a>LDR变换</h1><h1 id="pickup-and-delivery-problem-with-time-windows"><a href="#pickup-and-delivery-problem-with-time-windows" class="headerlink" title="pickup and delivery problem with time-windows"></a>pickup and delivery problem with time-windows</h1><p>求解PDPTW问题的算法包括：<strong>列生成算法</strong>（column generation）、<strong>分支切割</strong>（branch-and-cut）、<strong>分支切割定价</strong>（branch-and-cut-and-price）<em>等精确计算算法</em>，<strong>禁忌搜索</strong>（tabu search）、<strong>模拟退火</strong>（simulated annealing algorithm）、<strong>基于插入搜索的算法</strong>（insertion-based heuristic）、<strong>自适应大邻域搜索</strong>（adaptive large neighborhood search）、<strong>变深度搜索</strong>（variable-depth search algorithm）。由于在配送场景下，对算法时效性有极高的要求，上述算法均无法适用于配送场景的问题。在后文中，我们将介绍路径规划的问题模型，以及提出的启发式算法（Two-Stage Fast Heuristic），同时给出了一些仿真结果。</p>
<p>ref: <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000024516742">https://segmentfault.com/a/1190000024516742</a></p>
<h1 id="指派问题-Assignment-Problems-AP"><a href="#指派问题-Assignment-Problems-AP" class="headerlink" title="指派问题(Assignment Problems - AP)"></a>指派问题(Assignment Problems - AP)</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38361726/article/details/120738776">https://blog.csdn.net/qq_38361726/article/details/120738776</a></p>
<h1 id="车辆路径问题-VRP"><a href="#车辆路径问题-VRP" class="headerlink" title="车辆路径问题(VRP)"></a>车辆路径问题(VRP)</h1><p>VRP是指一定数量的客户，各自有不同数量的货物需求，配送中心向客户提供货物，由一个车队负责分送货物，组织适当的行车路线，目标是使得客户的需求得到满足，并能在一定的约束下，达到诸如路程最短、成本最小、耗费时间最少等目的。</p>
<p>TSP是VRP问题的特例。</p>
<h1 id="旅行商问题-TSP"><a href="#旅行商问题-TSP" class="headerlink" title="旅行商问题(TSP)"></a>旅行商问题(TSP)</h1><p><img src="https://pic4.zhimg.com/80/v2-e0921653dd164fded4bb4256283e66ff_720w.jpg" alt="img"></p>
<img src="https://pic3.zhimg.com/80/v2-9c5e778c1ce83c44f661abc525f34876_720w.jpg" alt="img" style="zoom: 67%;" />

<p>其中约束(3)尽管可被简化但仍使得该问题成为了NP问题，因此基于上述讨论，本文将简单介绍可用于解决TSP的启发式算法。</p>
<h2 id="非对称旅行商问题（ATSP）"><a href="#非对称旅行商问题（ATSP）" class="headerlink" title="非对称旅行商问题（ATSP）"></a>非对称旅行商问题（ATSP）</h2><h2 id="非对称旅行商问题（STSP）"><a href="#非对称旅行商问题（STSP）" class="headerlink" title="非对称旅行商问题（STSP）"></a>非对称旅行商问题（STSP）</h2><h1 id="凸包算法"><a href="#凸包算法" class="headerlink" title="凸包算法"></a>凸包算法</h1><h2 id="Graham-scan"><a href="#Graham-scan" class="headerlink" title="Graham scan"></a>Graham scan</h2><p><img src="https://s2.loli.net/2022/04/23/piQgGPzcaZCMI8A.png" alt="image-20220423094807908"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/20/%E5%89%91%E6%8C%87offer%E5%9B%9E%E5%BF%86%E5%BD%95%EF%BC%88%E9%80%9F%E5%88%B7%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的一些记录">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/20/%E5%89%91%E6%8C%87offer%E5%9B%9E%E5%BF%86%E5%BD%95%EF%BC%88%E9%80%9F%E5%88%B7%EF%BC%89/" class="post-title-link" itemprop="url">剑指offer回忆录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-20 10:45:00" itemprop="dateCreated datePublished" datetime="2022-03-20T10:45:00+08:00">2022-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-19 11:46:15" itemprop="dateModified" datetime="2022-06-19T11:46:15+08:00">2022-06-19</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><strong>从尾到头打印链表</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 栈</span><br><span class="line"><span class="number">2.</span> insert</span><br><span class="line"><span class="number">3.</span>递归</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec, ListNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next)&#123;</span><br><span class="line">            <span class="built_in">backtrace</span>(vec, p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="built_in">backtrace</span>(vec, head);</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在vector对象<strong>尾部之外的位置</strong>插入或删除元素可能很慢，那么结合链表与顺序表的特性可以认为vector对象的元素所使用的数据结构应该是顺序表。</p>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><strong>反转链表</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;  <span class="comment">//头插法反转</span></span><br><span class="line">        ListNode* newHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>); <span class="comment">//新的头节点</span></span><br><span class="line">        <span class="keyword">while</span>(pHead != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode* nxt = pHead-&gt;next;  <span class="comment">//提前保存head的下一个结点，防止赋值后head更改</span></span><br><span class="line">            pHead-&gt;next = newHead-&gt;next;</span><br><span class="line">            newHead-&gt;next = pHead;</span><br><span class="line">            pHead = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a><strong>合并两个排序的链表</strong></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pHead2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 节省空间就不创建新的链表了，较小的当第一个节点</span></span><br><span class="line">        ListNode *nh = pHead1-&gt;val &lt;= pHead2-&gt;val?pHead1:pHead2;</span><br><span class="line">        ListNode *prev = nh; <span class="comment">// 尾结点</span></span><br><span class="line">        ListNode *nxt = <span class="literal">nullptr</span>; <span class="comment">// temp</span></span><br><span class="line">        <span class="keyword">while</span>(pHead1 &amp;&amp; pHead2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val &lt;= pHead2-&gt;val)&#123;</span><br><span class="line">                nxt = pHead1;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nxt = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev-&gt;next = nxt;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pHead1)&#123;</span><br><span class="line">            prev-&gt;next = pHead1;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            pHead1 = pHead1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pHead2)&#123;</span><br><span class="line">            prev-&gt;next = pHead2;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">            pHead2 = pHead2-&gt;next;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> nh;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a><strong>复杂链表的复制</strong></h2><p>每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点。对此链表进行深拷贝。</p>
<p><strong>浅拷贝：</strong>又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。</p>
<p><strong>深拷贝：</strong>拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，<strong>深拷贝情况下，不会出现重复释放同一块内存的错误。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    struct RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment">    RandomListNode(int x) :</span></span><br><span class="line"><span class="comment">            label(x), next(NULL), random(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先拷贝原链表</span></span><br><span class="line">        RandomListNode* pre = <span class="keyword">new</span> <span class="built_in">RandomListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        RandomListNode* last = pre, * p = pHead;</span><br><span class="line">        unordered_map&lt;RandomListNode*, RandomListNode*&gt; mp;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            RandomListNode* new_node = <span class="keyword">new</span> <span class="built_in">RandomListNode</span>(p-&gt;label);</span><br><span class="line">            mp[p] = new_node;  <span class="comment">// 旧结点对应的新结点</span></span><br><span class="line">            last-&gt;next = new_node;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            last = last-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [key, value]:mp)&#123;</span><br><span class="line">            <span class="comment">// key 旧结点    value为新结点</span></span><br><span class="line">            value-&gt;random = key-&gt;random == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span>:mp[key-&gt;random];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="排序的循环链表"><a href="#排序的循环链表" class="headerlink" title="排序的循环链表"></a>排序的循环链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal);</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            node-&gt;next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1个</span></span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next == head)&#123;</span><br><span class="line">            head-&gt;next = node;</span><br><span class="line">            node-&gt;next = head;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        Node* nxt = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(nxt!=head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(insertVal&gt;=cur-&gt;val &amp;&amp; insertVal &lt;= nxt-&gt;val)&#123;  <span class="comment">//  正常递增</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val &gt; nxt-&gt;val)&#123;  <span class="comment">// nxt已经到了最小元素</span></span><br><span class="line">                <span class="keyword">if</span>(insertVal &gt; cur-&gt;val || insertVal &lt; nxt-&gt;val)&#123;</span><br><span class="line">                    <span class="comment">// insertVal &gt; cur-&gt;val 说明 insertval是最大值  3 5 1  插入值为6  结果为 3561</span></span><br><span class="line">                    <span class="comment">// insertVal &lt; nxt-&gt;val 说明 insertval是最小值  3 5 1  插入值为0  结果为 3501</span></span><br><span class="line">                    <span class="comment">// 这两种情况都可以插入在 5 和 1 之间</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = nxt;</span><br><span class="line">            nxt = nxt-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        node-&gt;next = nxt;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a><strong>树的子结构</strong></h2><p>判断一棵树是不是另一棵树的子结构.</p>
<p>没啥好解释的，我直接暴力穷举。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot1 || !pRoot2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(TreeNode*, TreeNode*)&gt; compareVal = [&amp;](TreeNode* p, TreeNode* q)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(q == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(p == <span class="literal">nullptr</span> || p-&gt;val != q-&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">compareVal</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">compareVal</span>(p-&gt;right,q-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">bool</span> tag = <span class="literal">false</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(pRoot1);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            tag = <span class="built_in">compareVal</span>(temp, pRoot2);</span><br><span class="line">            <span class="keyword">if</span>(tag)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><strong>二叉树的镜像</strong></h2><p>我第一反应想的是层次遍历倒序</p>
<p>发现前序，中序获得，倒序构建貌似也可以。没实验过</p>
<p>递归操作也可以用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Mirror</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;   <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot-&gt;left &amp;&amp; !pRoot-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot;  <span class="comment">// 单节点返回自身, &#123;1&#125; return 1;</span></span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* temp = pRoot-&gt;left;</span><br><span class="line">        pRoot-&gt;left = pRoot-&gt;right;</span><br><span class="line">        pRoot-&gt;right = temp;</span><br><span class="line">        <span class="built_in">Mirror</span>(pRoot-&gt;left);</span><br><span class="line">        <span class="built_in">Mirror</span>(pRoot-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pRoot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a><strong>对称的二叉树</strong></h2><p>判断二叉树是否对称。</p>
<p>中序遍历拆开   或者  不拆开直接判断，即递归，一样的。</p>
<p>非递归方法，使用stack，每次成双取出，判断p1-&gt;left == p2-&gt;right &amp;&amp; p1-&gt;right == p2-&gt;left。然后成双放入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span> || (!pRoot-&gt;left &amp;&amp; !pRoot-&gt;right))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(TreeNode*, TreeNode*)&gt; cpr = [&amp;](TreeNode* leftt, TreeNode* rightt)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftt == <span class="literal">nullptr</span> &amp;&amp; rightt == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 说明不全空</span></span><br><span class="line">            <span class="keyword">if</span>(leftt==<span class="literal">nullptr</span> || rightt == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//一空一不空</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> leftt-&gt;val == rightt-&gt;val</span><br><span class="line">                   &amp;&amp; <span class="built_in">cpr</span>(leftt-&gt;right, rightt-&gt;left)</span><br><span class="line">                   &amp;&amp; <span class="built_in">cpr</span>(leftt-&gt;left, rightt-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cpr</span>(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>边界条件处我犯了错。状态判断不好。</p>
<h2 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a><strong>从上往下打印二叉树</strong></h2><p>层次遍历。不赘述</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)&#123;</span><br><span class="line">                que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a><strong>二叉搜索树的后序遍历序列</strong></h2><p>二叉搜索树的中序遍历是递增的。</p>
<p>后序遍历的最后一位是根节点root</p>
<p>说明序列中，小于root-&gt;val的都是左子树，大于的都是右子树</p>
<p>接下来，相似的操作。</p>
<p>如  2 4 3 6 8 7 5   -&gt;    root = 5     left: 2 4 3   right: 6 8 7</p>
<p>2 4 3 -&gt; root=3  left = 2  right = 4             6 8 7 -&gt;  root = 7  left = 6  right = 8 </p>
<p><strong>递归</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">       std::function&lt;<span class="built_in"><span class="keyword">bool</span></span>(vector&lt;<span class="keyword">int</span>&gt;&amp;, <span class="keyword">size_t</span>, <span class="keyword">size_t</span>)&gt; judge = </span><br><span class="line">           [&amp;](vector&lt;<span class="keyword">int</span>&gt;&amp; seq, <span class="keyword">size_t</span> l, <span class="keyword">size_t</span> r)-&gt;<span class="keyword">bool</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> temp = seq[r];  <span class="comment">// root</span></span><br><span class="line">           <span class="keyword">int</span> i = r - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(i&gt;l &amp;&amp; seq[i]&gt;temp)&#123;</span><br><span class="line">               --i;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//找到分界点了</span></span><br><span class="line">           <span class="comment">// 判断左侧是否全部都是小于temp的</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">size_t</span> j = l;j&lt;i;++j)&#123;</span><br><span class="line">               <span class="keyword">if</span>(seq[j]&gt;temp)&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">judge</span>(seq, l, i) &amp;&amp; <span class="built_in">judge</span>(seq, i+<span class="number">1</span>, r<span class="number">-1</span>);</span><br><span class="line">       &#125;;</span><br><span class="line">        <span class="keyword">if</span>(sequence.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> n = sequence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(sequence, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树中和为某一值的路径-二"><a href="#二叉树中和为某一值的路径-二" class="headerlink" title="二叉树中和为某一值的路径(二)"></a><strong>二叉树中和为某一值的路径(二)</strong></h2><p>找出二叉树中结点值的和为目标值的所有路径（<strong>路径指根节点到叶子</strong>）</p>
<p><del>可以及时剪枝。</del>  </p>
<p>先序遍历的做法来遍历。</p>
<p>考虑负数！负数的话，大于的判断符号就没法使用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> expect;    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">FindPath</span>(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;expect = expectNumber;</span><br><span class="line">        </span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(TreeNode*, <span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp;)&gt; dfs = </span><br><span class="line">            [&amp;](TreeNode* rt, <span class="keyword">int</span> sum,vector&lt;<span class="keyword">int</span>&gt; temp, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans) -&gt; <span class="keyword">void</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rt == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=rt-&gt;val;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(rt-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(sum == expect &amp;&amp; rt-&gt;left == <span class="literal">nullptr</span> &amp;&amp; rt-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">                temp.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// &lt;</span></span><br><span class="line">            <span class="keyword">if</span>(rt-&gt;left)</span><br><span class="line">                <span class="built_in">dfs</span>(rt-&gt;left, sum, temp, ans);</span><br><span class="line">            <span class="keyword">if</span>(rt-&gt;right)</span><br><span class="line">                <span class="built_in">dfs</span>(rt-&gt;right, sum, temp, ans);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>, temp, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><strong>二叉搜索树与双向链表</strong></h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。</p>
<p>方法一：直接中序重新构造</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(TreeNode*, TreeNode*&amp;)&gt; trans = [&amp;](TreeNode* root, TreeNode*&amp; last)-&gt;<span class="keyword">void</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">                <span class="built_in">trans</span>(root-&gt;left, last);</span><br><span class="line">            &#125;</span><br><span class="line">            last-&gt;right = root;</span><br><span class="line">            root-&gt;left = last;</span><br><span class="line">            last = root;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">                <span class="built_in">trans</span>(root-&gt;right, last);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        TreeNode* p = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">-1</span>);</span><br><span class="line">        TreeNode* q = p;</span><br><span class="line">        <span class="built_in">trans</span>(pRootOfTree, q);</span><br><span class="line">        p=p-&gt;right;</span><br><span class="line">        p-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>方法二：不开辟新的结点，直接在原节点操作。<strong>这就需要保存中序遍历过程中的前继结点。</strong>给个全局变量，保存前继。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* preNode;  <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先找到preNode</span></span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(TreeNode*)&gt; trans = [&amp;](TreeNode* root)-&gt;<span class="keyword">void</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">trans</span>(root-&gt;left);  <span class="comment">//走到起始点</span></span><br><span class="line">            <span class="comment">// 找到最左侧，此时root == p</span></span><br><span class="line">        root-&gt;left = preNode;</span><br><span class="line">        preNode-&gt;right = root;</span><br><span class="line">        preNode = root;    </span><br><span class="line">        <span class="built_in">trans</span>(root-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        TreeNode* p = pRootOfTree;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;left)&#123;</span><br><span class="line">            p = p-&gt;left;  <span class="comment">// 链表的起始节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        preNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">trans</span>(pRootOfTree);</span><br><span class="line">        p-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> p;  <span class="comment">// 链表的头</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a><strong>序列化二叉树</strong></h2><p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">		TreeNode* left;</span><br><span class="line">		TreeNode* right;</span><br><span class="line">		<span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">	<span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		TreeNode* p = root;</span><br><span class="line">		<span class="built_in">preOrder</span>(p, res);</span><br><span class="line">		<span class="comment">// 使用递归，把最后一个逗号删除</span></span><br><span class="line">		res.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用迭代，最后还少个&quot;X&quot;</span></span><br><span class="line">		<span class="comment">// preOrder_case2(p, res);</span></span><br><span class="line">		<span class="comment">// res += &quot;X&quot;;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用递归方式</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root, string&amp; str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">			str += <span class="string">&quot;X&quot;</span>;</span><br><span class="line">			str += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		str += <span class="built_in">to_string</span>(root-&gt;val);</span><br><span class="line">		str += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">		<span class="built_in">preOrder</span>(root-&gt;left, str);</span><br><span class="line">		<span class="built_in">preOrder</span>(root-&gt;right, str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 非递归方式 进行前序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">preOrder_case2</span><span class="params">(TreeNode* root, string&amp; str)</span> </span>&#123;</span><br><span class="line">		stack&lt;TreeNode*&gt; st;</span><br><span class="line">		st.<span class="built_in">push</span>(root);</span><br><span class="line">		str = str + <span class="built_in">to_string</span>(root-&gt;left-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">		TreeNode* temp = root;</span><br><span class="line">		<span class="keyword">int</span> visited_node = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (temp!= <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp!=<span class="literal">nullptr</span>) &#123;  <span class="comment">// 一直向左走</span></span><br><span class="line">				st.<span class="built_in">push</span>(temp);</span><br><span class="line">				str += <span class="built_in">to_string</span>(temp-&gt;val);   <span class="comment">// 不断保存经过的结点</span></span><br><span class="line">				str += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">				temp = temp-&gt;left;  <span class="comment">// 走到最左</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123; <span class="comment">// 找右子树</span></span><br><span class="line">				str += <span class="string">&quot;X&quot;</span>;   <span class="comment">// 不断保存经过的结点</span></span><br><span class="line">				str += <span class="string">&quot;,&quot;</span>;</span><br><span class="line">				temp = st.<span class="built_in">top</span>();  <span class="comment">// 回溯到父结点</span></span><br><span class="line">				st.<span class="built_in">pop</span>();</span><br><span class="line">				temp = temp-&gt;right;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;  <span class="comment">// 只给了一个string ，说明不能通过 前/中 + 后序  来确定唯一的二叉树</span></span><br><span class="line">		deque&lt;string&gt; que;</span><br><span class="line">		stringstream ss;</span><br><span class="line">		string temp;</span><br><span class="line">		ss &lt;&lt; data;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">getline</span>(ss, temp, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">			que.<span class="built_in">push_back</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 按照 ’,‘ 分割好了</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">anls</span>(que);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从左到右解析字符串</span></span><br><span class="line">	<span class="function">TreeNode* <span class="title">anls</span><span class="params">(deque&lt;string&gt;&amp; que)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// que 从前往后</span></span><br><span class="line">		<span class="keyword">if</span> (!que.<span class="built_in">empty</span>() &amp;&amp; que.<span class="built_in">front</span>() == <span class="string">&quot;X&quot;</span>) &#123;  <span class="comment">// 为空结点</span></span><br><span class="line">			que.<span class="built_in">pop_front</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> temp = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(que.<span class="built_in">front</span>()));</span><br><span class="line">		que.<span class="built_in">pop_front</span>();</span><br><span class="line">		temp-&gt;left = <span class="built_in">anls</span>(que);</span><br><span class="line">		temp-&gt;right = <span class="built_in">anls</span>(que);</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">删除二叉搜索树中的节点</a></h2><p>leetcode450</p>
<p>难点主要在于删除操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// cur的左右节点都为空，cur可以直接删除</span></span><br><span class="line">    <span class="comment">// 右节点为空，找左节点的最大值</span></span><br><span class="line">    <span class="comment">// 左节点为空，找右节点的最小值</span></span><br><span class="line">    <span class="comment">// 左右节点均不为空，那么去左边找最大值或右边找最小值都可以,来替换掉cur</span></span><br><span class="line">    <span class="comment">// 解法可以看作不断地重构二叉搜索树(BST)</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; key)&#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&gt; key)&#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left,key);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==key)&#123;  <span class="comment">// ==</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="comment">// 直接删除root</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span>)&#123;  <span class="comment">// 右空，找左边最大值,刚好是左边第一个</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span>)&#123; <span class="comment">// 左空，找右边最小值，刚好是右边第一个</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 两侧都不为空</span></span><br><span class="line">            <span class="comment">// 这里找右边最小值，换掉root</span></span><br><span class="line">            TreeNode* rep = root-&gt;right;</span><br><span class="line">            <span class="comment">// 如果右边第一个有左子树，那么就一直找,因为最小值如果在左子树，那么肯定在第一个结点的左子树</span></span><br><span class="line">            <span class="keyword">while</span>(rep-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                rep = rep-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时已经找到最小值的结点了</span></span><br><span class="line">            <span class="comment">// 重构需要删除结点的右子树， 值要根据rep（即替换节点的值重构</span></span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, rep-&gt;val);</span><br><span class="line">            <span class="comment">// 把这个结点替换掉需要删除的结点 root</span></span><br><span class="line">            rep-&gt;right = root-&gt;right;</span><br><span class="line">            rep-&gt;left = root-&gt;left;</span><br><span class="line">            <span class="keyword">return</span> rep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a>最小的K个数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数</span></span><br><span class="line"><span class="comment">// [0,1,2,1,2],3    -&gt;   [0,1,1]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* case1  直接排序取前K</span></span><br><span class="line"><span class="comment">* case2  容量为K的优先队列(大顶堆)。 小于则进去且弹出堆顶</span></span><br><span class="line"><span class="comment">* case3  topK算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case1略</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// case2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="（大顶）堆的建立，插入，删除"><a href="#（大顶）堆的建立，插入，删除" class="headerlink" title="（大顶）堆的建立，插入，删除"></a><strong>（大顶）堆的建立，插入，删除</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapBID</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 数组下标从0开始</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;  <span class="comment">// 向下调整</span></span><br><span class="line">		<span class="keyword">int</span> leftChild = k * <span class="number">2</span> + <span class="number">1</span>, rightChild = k * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> maxIndex = k; <span class="comment">//假设在当前节点，及其左、右子节点，共三个节点中，最大的是当前这个节点。后序我们就要更新max，看到底哪个才是最大的，把最大的那个和当前节点交换</span></span><br><span class="line">		<span class="keyword">if</span> (leftChild &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[leftChild] &gt; nums[maxIndex])</span><br><span class="line">			maxIndex = leftChild;</span><br><span class="line">		<span class="keyword">if</span> (rightChild &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[rightChild] &gt; nums[maxIndex])</span><br><span class="line">			maxIndex = rightChild;</span><br><span class="line">		<span class="keyword">if</span> (maxIndex != k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">swap</span>(nums[maxIndex], nums[k]);</span><br><span class="line">			<span class="built_in">shiftDown</span>(nums, maxIndex); <span class="comment">// 如果原k节点调整了位置(上一步swap调整)，那么就要将k继续做shiftDown操作，直到它比它的左、右孩子都大</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//  建立的是大顶堆</span></span><br><span class="line">	<span class="comment">// 向上调整，删除堆顶时候使用</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;  <span class="comment">// 向上调整</span></span><br><span class="line">		<span class="comment">// 首先将最后一个孩子节点插入到头节点</span></span><br><span class="line">		<span class="keyword">int</span> child = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> parent = (child - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span> (child &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[parent] &lt; nums[child]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(nums[parent], nums[child]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			child = parent;</span><br><span class="line">			parent = (child - <span class="number">1</span>) / <span class="number">2</span>;  <span class="comment">// 换层</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; ++i) &#123;  <span class="comment">// 从第一个非叶子节点开始，从下往上，将每棵子树调整成最大堆</span></span><br><span class="line">			<span class="built_in">shiftDown</span>(nums, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		nums.<span class="built_in">push_back</span>(x);</span><br><span class="line">		<span class="built_in">shiftUp</span>(nums);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pollHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> oldVal = nums[<span class="number">0</span>]; <span class="comment">// 头元素</span></span><br><span class="line">		nums[<span class="number">0</span>] = nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">		nums.<span class="built_in">pop_back</span>(); <span class="comment">// 弹出末尾</span></span><br><span class="line">		<span class="built_in">shiftDown</span>(nums, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; nums&#123; <span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span> &#125;;</span><br><span class="line">	HeapBID h;</span><br><span class="line">	h.<span class="built_in">buildMaxHeap</span>(nums);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;build heap&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; a : nums) &#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;insert&quot;</span> &lt;&lt; endl;</span><br><span class="line">	h.<span class="built_in">inHeap</span>(nums,<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; a : nums) &#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pop &quot;</span> &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">	h.<span class="built_in">pollHeap</span>(nums);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; a : nums) &#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;pop all&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		cout &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		h.<span class="built_in">pollHeap</span>(nums);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2022/06/02/me9Agf8YLG5KMw7.png" alt="image-20220602224323732" style="zoom:67%;" />



<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><strong>顺时针打印矩阵</strong></h2><p>从外向里以顺时针打印。</p>
<p>螺旋输出，小心单行的情况，要判断 <code>if (top != bottom)</code>  和 <code>if (left != right)</code></p>
<p>在这里犯了错。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">printMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, bottom = m<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right &amp;&amp; top&lt;=bottom)&#123;</span><br><span class="line">            <span class="comment">// 左到右</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left;i&lt;=right;++i)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上到下</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top+<span class="number">1</span>;i&lt;=bottom;++i)&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 小心单行的情况</span></span><br><span class="line">            <span class="comment">//右到左</span></span><br><span class="line">            <span class="keyword">if</span> (top != bottom)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = right<span class="number">-1</span>; i&gt;=left;--i)&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下到上</span></span><br><span class="line">            <span class="keyword">if</span> (left != right)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom<span class="number">-1</span>;i&gt;top;--i)&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="队列-amp-栈"><a href="#队列-amp-栈" class="headerlink" title="队列&amp;栈"></a>队列&amp;栈</h1><h2 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a><strong>包含min函数的栈</strong></h2><p>用了个辅助栈，保存当前最小值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; aux_st;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        st.<span class="built_in">push</span>(value);</span><br><span class="line">        <span class="keyword">if</span>(aux_st.<span class="built_in">empty</span>() || aux_st.<span class="built_in">top</span>() &gt;= value)&#123;</span><br><span class="line">            aux_st.<span class="built_in">push</span>(value);   <span class="comment">//保存当前最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(temp == aux_st.<span class="built_in">top</span>())&#123;</span><br><span class="line">            aux_st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aux_st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a><strong>栈的压入、弹出序列</strong></h2><p>判断出栈序列有没有可能是入栈序列的对应序列。</p>
<p>入栈1,2,3,4,5</p>
<p>出栈4,5,3,2,1</p>
<p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p>
<p>此时栈顶2≠4，继续入栈3</p>
<p>此时栈顶3≠4，继续入栈4</p>
<p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p>
<p>此时栈顶3≠5，继续入栈5</p>
<p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p>
<p>….</p>
<p>依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; pushV,vector&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; aux_st;</span><br><span class="line">        <span class="keyword">size_t</span> n = pushV.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">size_t</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">            aux_st.<span class="built_in">push</span>(pushV[i]);  <span class="comment">// 当前值入辅助栈</span></span><br><span class="line">            <span class="keyword">while</span>((!aux_st.<span class="built_in">empty</span>() &amp;&amp; aux_st.<span class="built_in">top</span>()==popV[j]))&#123;</span><br><span class="line">                <span class="comment">// 判断辅助栈当前顶部能否弹出和当前出栈序列对应的值</span></span><br><span class="line">                aux_st.<span class="built_in">pop</span>();</span><br><span class="line">                ++j;  <span class="comment">// 出栈序列后移一位</span></span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aux_st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h1 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h1><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><strong>字符串的排列</strong></h2><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="字符串的排列-1"><a href="#字符串的排列-1" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p><code>tag: 字符串  递归</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; vec;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string内没有重复字母</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permu_unique</span><span class="params">(string&amp; str, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == str.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index;i&lt;str.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(str[i], str[index]);</span><br><span class="line">            <span class="built_in">permu_unique</span>(str, index + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(str[i], str[index]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">permu_unique</span>(str, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string内有重复字母</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; visited; <span class="comment">// 记录重复字母</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// index代表选择的字母个数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permu</span><span class="params">(string&amp; str, <span class="keyword">int</span> index, string&amp; temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == str.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;str.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] || (i&gt;<span class="number">0</span> &amp;&amp; !visited[i<span class="number">-1</span>] &amp;&amp; str[i<span class="number">-1</span>] == str[i]))&#123;</span><br><span class="line">                <span class="comment">//!visited[i-1] &amp;&amp; str[i-1] == str[i]</span></span><br><span class="line">                <span class="comment">//这句代表，前一个是没访问过的状态，并且当前字母等于前一个字母</span></span><br><span class="line">                <span class="comment">// 说明  前一个字母已经遍历完了，把状态重置为0，才来这个字母</span></span><br><span class="line">                <span class="comment">// 而两个字母相同，所以不该对当前字母再进行搜索</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 选当前</span></span><br><span class="line">            temp.<span class="built_in">push_back</span>(str[i]);</span><br><span class="line">            <span class="comment">// 标记为已用</span></span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">permu</span>(str, index+<span class="number">1</span>, temp);</span><br><span class="line">            <span class="comment">// 回退</span></span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">            visited[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">        string temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        visited.<span class="built_in">resize</span>(str.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">permu</span>(str, <span class="number">0</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h1><h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  题目输入保证有解，不需要在进行验证</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a : numbers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;  <span class="comment">// 还没选数字</span></span><br><span class="line">                num  = a;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(a == num)&#123;  <span class="comment">// 相同则给当前数字投一票</span></span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    --cnt;  <span class="comment">// 不同则减去一票</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>




















      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
